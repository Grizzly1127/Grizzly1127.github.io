<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ STL库底层数据结构</title>
    <url>/c/cpp-STL-brief/</url>
    <content><![CDATA[<p>STL容器可以分为以下几大类：<br>① 序列容器：vector、list、deque、string<br>② 关联容器：set、multiset、unorderd_set、unorderd_multiset、map、multimap、unorderd_map、unorderd_multimap<br>③ 其他容器：stack、queue、valarray、bitset<br><a id="more"></a></p>
<h2 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h2><p>内部数据结构：<strong>数组</strong>。<br>vector 数组动态增加大小，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对 vector 的任何操作，一旦引起空间重新配置，同时指向原vector 的所有迭代器就都失效了。<br>vector 常用来保存需要经常进行随机访问的内容，并且不需要经常对中间元素进行添加删除操作。</p>
<h2 id="2-list"><a href="#2-list" class="headerlink" title="2. list"></a>2. list</h2><p>内部数据结构：<strong>环状双向链表</strong>。<br>不能随机访问元素，可双向遍历。增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。</p>
<h2 id="3-deque"><a href="#3-deque" class="headerlink" title="3. deque"></a>3. deque</h2><p>内部数据结构：<strong>数组</strong>。<br>deque 是支持向两端高效地插入数据、支持随机访问的容器。deque 的数据被表示为一个分段数组，容器中的元素分段存放在一个个大小固定的数组中，此外容器还需要维护一个存放这些数组首地址的索引数组。</p>
<p>总结：<br>1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用 vector；<br>2、如果你需要大量的插入和删除，而不关心随即存取，则应使用 list；<br>3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用 deque。</p>
<h2 id="4-stack"><a href="#4-stack" class="headerlink" title="4. stack"></a>4. stack</h2><p>内部数据结构：底层以某种容器（ <strong>list 或 deque（缺省）</strong>）作为数据结构。<br>stack 是一种先进后出（FILO）的数据结构。它只有一个出口，stack 允许新增元素，移除元素，取得最顶端元素。但除了最顶端外，没有任何其它方法可以存取stack的其它元素，stack不允许遍历行为。<br>缺省情况下以 deque 作为底部数据结构，并封闭其头端开口，便能实现一个 deuqe。</p>
<h2 id="5-queue"><a href="#5-queue" class="headerlink" title="5. queue"></a>5. queue</h2><p>内部数据结构：底层以某种容器（ <strong>list 或 deque（缺省）</strong>）作为数据结构。<br>queue 是一种先进先出（First In First Out,FIFO）的数据结构。它有两个出口，queue 允许新增元素，移除元素，从最底端加入元素，取得最顶端元素。但除了最底端可以加入，最顶端可以取出外，没有任何其它方法可以存取 queue 的其它元素。<br>缺省情况下以 deque 作为底部数据结构，并封闭其头端入口和尾端出口，便能实现一个 queue。</p>
<p>stack 和 queue 其实是适配器，而不叫容器，因为是对容器的再封装。</p>
<h2 id="6-set和multiset"><a href="#6-set和multiset" class="headerlink" title="6. set和multiset"></a>6. set和multiset</h2><p>内部数据结构：<strong>RB-tree</strong>。<br>set 底层是通过红黑树（RB-tree）来实现的，由于红黑树是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的 STL 的 set 即以 RB-Tree 为底层机制。又由于 set 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 set 操作行为，都只有转调用 RB-tree 的操作行为而已。<br>multiset的特性以及用法和 set 完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制是 RB-tree 的 insert_equal() 而非 insert_unique()。</p>
<h2 id="7-map和multimap"><a href="#7-map和multimap" class="headerlink" title="7. map和multimap"></a>7. map和multimap</h2><p>内部数据结构：<strong>RB-tree</strong>。<br>与set的结构一样，都是使用 RB-tree 实现的，只不过map的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。<br>multimap 的特性以及用法与 map 完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制 RB-tree 的 insert_equal() 而非 insert_unique。</p>
<h2 id="8-unordered-set和unordered-multiset"><a href="#8-unordered-set和unordered-multiset" class="headerlink" title="8. unordered_set和unordered_multiset"></a>8. unordered_set和unordered_multiset</h2><p>内部数据结构：<strong>hash table</strong>。<br>底层由哈希表实现。无序，查找元素的时间复杂度为常数。</p>
<h2 id="9-unordered-map和unordered-multimap"><a href="#9-unordered-map和unordered-multimap" class="headerlink" title="9. unordered_map和unordered_multimap"></a>9. unordered_map和unordered_multimap</h2><p>内部数据结构：<strong>hash table</strong>。<br>底层由哈希表实现。无序，查找元素的时间复杂度为常数。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前中后序递归法和迭代法</title>
    <url>/DataStructure/binary-tree-traversal/</url>
    <content><![CDATA[<h1 id="二叉树的前中后序递归法和迭代法"><a href="#二叉树的前中后序递归法和迭代法" class="headerlink" title="二叉树的前中后序递归法和迭代法"></a>二叉树的前中后序递归法和迭代法</h1><p>二叉树根据遍历方式，分为<strong>深度优先搜索（DFS）</strong>和<strong>广度优先搜索（BFS）</strong>。</p>
<p>二叉树的深度优先搜索：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>二叉树的广度优先搜索：</p>
<ul>
<li>层序遍历<a id="more"></a>
</li>
</ul>
<p><img src="https://i.loli.net/2021/02/04/e1dnxwVrZ2oLyEu.png" alt="binary-tree-traversal.png"></p>
<p>以上二叉树中，深度优先搜索结果：</p>
<ul>
<li>前序遍历（<strong>中</strong>左右）：1 2 4 5 8 3 6 7 9</li>
<li>中序遍历（左<strong>中</strong>右）：4 2 5 8 1 6 3 9 7</li>
<li>后续遍历（左右<strong>中</strong>）：4 8 5 2 6 9 7 3 1</li>
</ul>
<p>广度优先搜索结果：</p>
<ul>
<li>层序遍历：1 2 3 4 5 6 7 8 9</li>
</ul>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>递归算法三要素：</p>
<ol>
<li><p>确定递归的返回值和参数：</p>
<p>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
</li>
<li><p>确定递归的终止条件：</p>
<p>操作系统通过栈结构来存储每一层递归的信息，而栈空间是有限的，如果递归没有终止，则会一直递归下去，操作系统的内存栈必然会溢出，导致程序崩溃。</p>
<p>所以何时终止？如何终止？这都是必须要考虑到的。</p>
</li>
<li><p>确定单层递归的处理逻辑：</p>
<p>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
</li>
</ol>
<p>下面以<strong>返回前序遍历的数组</strong>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> v) : val(v), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>确定递归的返回值和参数：要求返回前序遍历的数组，所以递归函数不需要返回值，参数里需要传入二叉树的当前节点和 vector 用于存放遍历的数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>确定递归的终止条件:在递归过程中，为了防止无限递归下去，需要一个终止条件，本例子中，当前节点为空时，不需要（也不能）处理任何信息，所以直接返回就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定单层递归的处理逻辑:前序遍历是以<code>中-&gt;左-&gt;右</code>来进行遍历的，所以优先处理中节点信息，然后再往左节点和右节点递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec.push_back(node-&gt;val);</span><br><span class="line">traversal(node-&gt;left, vec);</span><br><span class="line">traversal(node-&gt;right, vec);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根据以上要素，完成前序遍历的完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        vec.push_back(node-&gt;val);</span><br><span class="line">        traversal(node-&gt;left, vec);</span><br><span class="line">        traversal(node-&gt;right, vec);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据三要素的思想，不难写出中序遍历和后续遍历，如下：</p>
<p>中序遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    traversal(node-&gt;left, vec);</span><br><span class="line">    vec.push_back(node-&gt;val);</span><br><span class="line">    traversal(node-&gt;right, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    traversal(node-&gt;left, vec);</span><br><span class="line">    traversal(node-&gt;right, vec);</span><br><span class="line">    vec.push_back(node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>递归法的实现就是每一次递归调用都会把函数的局部变量，参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>所以通过栈结构，无需递归也可以实现二叉树的前中后序遍历。</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历就是优先处理中间节点，然后再进行左右节点的处理。所以入栈顺序应该是先压入根节点，接着将右节点压入栈中，再加入左节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;	<span class="comment">// 辅助栈</span></span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(node-&gt;val);	<span class="comment">// 中节点处理</span></span><br><span class="line">            <span class="comment">// 根据栈的特性（先进后出），需要先压入右节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                st.push(node-&gt;right);		<span class="comment">// 右节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                st.push(node-&gt;left);		<span class="comment">// 左节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进 result 数组中），这就造成了处理顺序和访问顺序是不一致的。</p>
<p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">midOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;    <span class="comment">// 辅助栈</span></span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur) &#123;  <span class="comment">// 先访问到二叉树的最底层</span></span><br><span class="line">                st.push(cur);   <span class="comment">// 将访问到的节点压入栈中</span></span><br><span class="line">                cur = cur-&gt;left;            <span class="comment">// 左节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 此时当前节点为空（无左节点）</span></span><br><span class="line">                cur = st.top();	<span class="comment">// 从栈里弹出节点</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val); <span class="comment">// 中节点的数据处理</span></span><br><span class="line">                cur = cur-&gt;right;           <span class="comment">// 右节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>前序遍历的遍历顺序是：<code>左右中</code>，后序遍历的顺序是：<code>中左右</code>。</p>
<p>那么我只需要在前序遍历时，将<code>左右中</code>改为<code>右左中</code>，然后再将数组反转（<code>中左右</code>），即可得到后序遍历的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;    <span class="comment">// 辅助栈</span></span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(node-&gt;val);    <span class="comment">// 中节点处理</span></span><br><span class="line">            <span class="comment">// 此时先压入左节点，将前序遍历改为 右左中</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                st.push(node-&gt;left);        <span class="comment">// 左节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                st.push(node-&gt;right);       <span class="comment">// 右节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="迭代方式统一写法"><a href="#迭代方式统一写法" class="headerlink" title="迭代方式统一写法"></a>迭代方式统一写法</h2><p>因为迭代法实现的前中后序风格不统一，除了前序和后序有关联，中序完全就是另一种写法了。</p>
<p>针对三种遍历方式，使用迭代法是可以写出统一风格的代码的。</p>
<p>不统一的问题是：无法同时解决访问节点和处理节点不一致的情况。</p>
<p>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</p>
<p>如何标记呢？<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p>
<p>完整代码如下：</p>
<h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">                st.pop();   <span class="comment">// 将该节点弹出，避免重复操作，下面再将右左中节点添加到栈中</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.push(node-&gt;right);  <span class="comment">// 添加右节点</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.push(node-&gt;left);    <span class="comment">// 添加左节点</span></span><br><span class="line"></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">nullptr</span>);   <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();   <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.top();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(node-&gt;val);    <span class="comment">// 处理节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">midOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.push(node-&gt;right);  <span class="comment">// 添加右节点</span></span><br><span class="line"></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.push(node-&gt;left);    <span class="comment">// 添加左节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                node = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line"></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.push(node-&gt;right);  <span class="comment">// 添加右节点</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.push(node-&gt;left);    <span class="comment">// 添加左节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                node = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体中的位域</title>
    <url>/c/cpp-bit-field/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有些信息存储时，并不需要占用一整个完整的字节，而只需要占几个或一个二进制位。例如存放一个开关变量时，只需要用到0或1两种状态，用一位二进制位即可。所以，为了节省空间，C语言提供了一种叫<strong>位域</strong>的数据结构。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    type [member_name] : width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>元素</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>只能为int, unsigned int, signed int三种类型</td>
</tr>
<tr>
<td>member_name</td>
<td>位域的名称</td>
</tr>
<tr>
<td>width</td>
<td>位域中位的数量。宽度必须小于或等于指定类型的位宽度</td>
</tr>
</tbody>
</table>
</div>
<p>位域的使用：</p>
<ol>
<li>位域成员的类型必须指定为unsigned或int类型。</li>
<li>一个位段必须存储在同一存储单元中，不能跨两个单元。如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段。</li>
<li>可以定义无名位域（形式：type :0;），无名位域用于填充内存布局，表示下一个位域从下一个内存边界开始。</li>
<li>位域的长度不能大于存储单元的长度，也不能定义位域数组。</li>
<li>位域可以用整型格式符输出。</li>
<li>位域可以在数值表达式中引用，它会被系统自动地转换成整型数。</li>
<li>位域定义的第一个位域长度不能为0。</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>             <span class="comment">// 64b</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>             <span class="comment">// 64b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;                      <span class="comment">// 64b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;                        <span class="comment">// 32b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;                <span class="comment">// 16b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;              <span class="comment">// 2b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;             <span class="comment">// 2b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>;            <span class="comment">// 1b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>;    <span class="comment">// 1b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>;                <span class="comment">// 10b</span></span><br><span class="line">&#125; quicklistNode;                            <span class="comment">// = (256b / 8) = 32Byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;quicklistNode size: %d\n&quot;</span>, <span class="keyword">sizeof</span>(struct quicklistNode));</span><br><span class="line">    <span class="comment">// output :</span></span><br><span class="line">    <span class="comment">// quicklistNode size: 32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>位域</tag>
        <tag>bitfield</tag>
      </tags>
  </entry>
  <entry>
    <title>C++实现高性能日志框架</title>
    <url>/c/cpp-asynclogging/</url>
    <content><![CDATA[<p>在一个优秀的系统中，日志是不可或缺的组成部分。尤其是在服务端编程中，日志更是必不可少的，如果没有日志，我们将不得不依赖客户或支持团队，让他们描述在什么情况下发生了什么。随后在开发环境中重现问题，并进行各种调试，直至完全修复错误为止，然而这一般耗费很长时间。如果有了日志的帮助，可以从日志中快速的定位异常，并解决问题。<br>使用日志的好处并不止以上一点，还包括：<br><a id="more"></a></p>
<ol>
<li>采集和分析用户行为</li>
<li>可用于数据统计及分析</li>
<li>追踪程序执行的过程</li>
<li>程序性能检测</li>
<li>等等。</li>
</ol>
<h2 id="关于重复造轮子"><a href="#关于重复造轮子" class="headerlink" title="关于重复造轮子"></a>关于重复造轮子</h2><p>在开源技术大爆发的时代，每一个领域中都有很多很好的解决方案。C++ 日志框架也很等多成熟的方案，如：Boost.Log、glog、Log4cpp、log4cplus、loguru、Easylogging++ 等等的优秀日志框架可以使用。<br>那么已经有了这么多成熟的方案下，还有必要去重新造轮子吗？没有必要。话虽如此，但是还是有必要去了解关于轮子的各个细节。在学习轮子的过程中，也能提高我们自己的编程能力和各种技术的理解。</p>
<h2 id="高性能的日志库"><a href="#高性能的日志库" class="headerlink" title="高性能的日志库"></a>高性能的日志库</h2><p>在陈硕先生的《Linux多线程服务端编程》一书中提到，一个高性能的日志库应具备以下需求：</p>
<ul>
<li>功能需求：<ol>
<li>日志消息多种级别（level）。（必须）</li>
<li>日志消息可能有多个目的地（文件、socket、SMTP等）。（非必须）</li>
<li>日志消息格式可配置。（非必须）</li>
<li>可以设置运行时过滤器。（非必须）</li>
</ol>
</li>
<li>性能需求：<ol>
<li>每秒写几千上万条日志的时候没有明显的性能损失。</li>
<li>能应对一个进程产生大量日志数据的场景。</li>
<li>不阻塞正常的执行流程。</li>
<li>在多线程程序中，不造成争用。</li>
</ol>
</li>
</ul>
<p>在一个复杂的系统环境中，每一条日志应该对应不同的级别，比如 INFO、WARNING、ERROR 等，在开发环境中应增加 TRACE、DEBUG 等，这有助于开发人员快速定位问题和后续对日志数据进行统计以及分析。在不同的环境中调整不同级别的日志等级，还可减少日志的数目，如在生产环境中，可关闭掉 TRACE 和 DEBUG 日志的输出，只留下重要的日志。<br>性能要求是重中之重，一个程序的大部分资源应该用于处理业务，只有少部分资源来用做日志输出，所有只有日志库足够高效，程序员才敢在代码中输出足够多的诊断信息。</p>
<h2 id="如何实现高性能的日志框架"><a href="#如何实现高性能的日志框架" class="headerlink" title="如何实现高性能的日志框架"></a>如何实现高性能的日志框架</h2><p>我所设想的日志库应该满足以下需求：</p>
<ol>
<li>多线程程序并发写日志，即线程安全。</li>
<li>一个进程的多线程只写到一个文件中。</li>
<li>文件滚动，在日志文件满足特定需求（文件大小、特定时间等）后，需要将后续日志写入到新的日志文件中。</li>
<li>只能占用程序少量资源。</li>
</ol>
<p>为了满足以上需求，异步日志是必须的，因为在业务处理线程中直接往磁盘写数据的话，写操作可能会阻塞业务线程，这将导致程序性能下降。<br>一个解决方案是，将日志进行分离，专门启动一条线程用于写磁盘的操作，业务线程发来的数据插入到一个队列中（或者一个buffer块中），后端线程取出数据并写入磁盘，这样就不会影响到业务线程了。<br>那么使用队列还是双缓冲技术呢？<br>这里我采用双缓冲技术，因为使用队列的话，每次产生一条日志消息都需要通知(notify_one())后端线程。<br>双缓冲技术的基本思路是，使用两块 buffer，其中，buffer A 专门用于前端业务填充数据，后端线程负责将 buffer B 中的数据写入到文件中，当 buffer A 写满后，交换 A 和 B，让后端将 A 中的数据写入到文件中，而前端则往 B 中填数据。实际编写过程中，将不止用到两块 buffer，如果两块 buffer 都满了，并且后端线程还在进行磁盘 IO 操作的话，则需要临时申请 buffer 用来填充数据。当后端线程能正常处理数据后，将临时申请的 buffer 销毁，只保留两块 buffer。<br>这样做的好处是，创建日志消息时不需要等待磁盘文件操作，也避免了每条日志都需要触发后端日志线程。</p>
<p>如下图所示，异步日志的框架图：</p>
<p><img src="https://i.loli.net/2020/10/29/1HQT9A4Z2iranfV.png" alt="AsyncLogging.png"></p>
<p>根据以上的大致思路，我实现了一个异步日志库 <a href="https://github.com/Grizzly1127/momoko-log">momoko-log</a>，已托管到 github 上。</p>
<h2 id="momoko-log"><a href="#momoko-log" class="headerlink" title="momoko-log"></a>momoko-log</h2><p>momoko-log 是基于 C++11 开发的高性能异步日志框架，该框架只能用于 Linux 中，不支持跨平台。<br>momoko-log 日志库特点如下：</p>
<ol>
<li>每秒可写百万条数据到磁盘中。</li>
<li>多线程程序并发写日志到一个日志文件中。</li>
<li>文件滚动。</li>
<li>日志多级别输出。</li>
<li>接口简单(重载了多种数据类型的 <code>&lt;&lt;</code> 操作符)，使用方便。</li>
<li>采用批处理方式记录日志。</li>
</ol>
<p>momoko-log 日志输出格式固定，以避免频繁改动日志格式对后面日志数据分析加强难度。<br>日志格式如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">timestamp threadId logLevel file:line -&gt;  content</span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;momoko-log/logger.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set log level</span></span><br><span class="line">    <span class="comment">//SET_LOGLEVEL(momoko::Logger::INFO)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set to asynchronous logger</span></span><br><span class="line">    LOG_SET_ASYNC(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;info message, num.&quot;</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;warning message, num.&quot;</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">&quot;error message, num.&quot;</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>async</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 内存大小端模式</title>
    <url>/c/cpp-byte-endian/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>维基百科：</strong><br>字节顺序，又称端序或尾序（英语：<strong>Endianness</strong>），在计算机科学领域中，指存储器中或在数字通信链路中，组成多字节的字的字节的排列顺序。<br><a id="more"></a><br>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。</p>
<p>字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。</p>
<p>例如假设上述变量x类型为int，位于地址0x100处，它的值为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..。</p>
<p><strong>百度百科：</strong><br>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p>
<p>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p>
<h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><p>以unsigned int value = 0x12345678为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内存地址</th>
<th>小端模式（Little-Endian）</th>
<th>大端模式（Big-Endian）</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x100（低地址）</td>
<td>0x78</td>
<td>0x12</td>
</tr>
<tr>
<td>0x101</td>
<td>0x56</td>
<td>0x34</td>
</tr>
<tr>
<td>0x102</td>
<td>0x34</td>
<td>0x56</td>
</tr>
<tr>
<td>0x103（高地址）</td>
<td>0x12</td>
<td>0x78</td>
</tr>
</tbody>
</table>
</div>
<h2 id="redis中的大小端"><a href="#redis中的大小端" class="headerlink" title="redis中的大小端"></a>redis中的大小端</h2><p>为了兼容不同目标机的字节顺序，redis统一采用了小端字节序的方式存储。对于字节序的转码，redis提供了16byte、32byte、64byte字节的转换，代码在endianconv.c和endianconv.h中。代码很简单，看一下就能明白。<br>贴上代码：<br><strong>endianconv.h</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev16</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev32</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev64</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">intrev16</span><span class="params">(<span class="keyword">uint16_t</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">intrev32</span><span class="params">(<span class="keyword">uint32_t</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">intrev64</span><span class="params">(<span class="keyword">uint64_t</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (BYTE_ORDER == LITTLE_ENDIAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev16ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev32ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev64ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev16ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev32ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev64ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev16ifbe(p) memrev16(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev32ifbe(p) memrev32(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev64ifbe(p) memrev64(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev16ifbe(v) intrev16(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev32ifbe(v) intrev32(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev64ifbe(v) intrev64(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (BYTE_ORDER == BIG_ENDIAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> htonu64(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ntohu64(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> htonu64(v) intrev64(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ntohu64(v) intrev64(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endianconvTest</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>endianconv.c</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev16</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev32</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">3</span>];</span><br><span class="line">    x[<span class="number">3</span>] = t;</span><br><span class="line">    t = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = x[<span class="number">2</span>];</span><br><span class="line">    x[<span class="number">2</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev64</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">7</span>];</span><br><span class="line">    x[<span class="number">7</span>] = t;</span><br><span class="line">    t = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = x[<span class="number">6</span>];</span><br><span class="line">    x[<span class="number">6</span>] = t;</span><br><span class="line">    t = x[<span class="number">2</span>];</span><br><span class="line">    x[<span class="number">2</span>] = x[<span class="number">5</span>];</span><br><span class="line">    x[<span class="number">5</span>] = t;</span><br><span class="line">    t = x[<span class="number">3</span>];</span><br><span class="line">    x[<span class="number">3</span>] = x[<span class="number">4</span>];</span><br><span class="line">    x[<span class="number">4</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">intrev16</span><span class="params">(<span class="keyword">uint16_t</span> v)</span> </span>&#123;</span><br><span class="line">    memrev16(&amp;v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">intrev32</span><span class="params">(<span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">    memrev32(&amp;v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">intrev64</span><span class="params">(<span class="keyword">uint64_t</span> v)</span> </span>&#123;</span><br><span class="line">    memrev64(&amp;v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>大端</tag>
        <tag>小端</tag>
        <tag>endian</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 编译与链接</title>
    <url>/c/cpp-compilie-link/</url>
    <content><![CDATA[<h2 id="1-编译系统"><a href="#1-编译系统" class="headerlink" title="1. 编译系统"></a>1. 编译系统</h2><p>从源码文件到可执行程序是如何实现的呢？下面写个简单的程序来进行说明。<br>以下是一个 hello.c 程序：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Linux系统上，由编译器把源文件转换为可执行文件的命令如下：</p>
<blockquote>
<p>gcc hello.c -o hello</p>
</blockquote>
<p>这是gcc编译器一步到位将源文件编译成了可执行文件，其中省略了的几个步骤，由gcc编译器自动执行。我们拆开来看，整个编译分为四个步骤：</p>
<blockquote>
<p>1-&gt; gcc -E hello.c -o hello.i<br>2-&gt; gcc -S hello.i -o hello.s<br>3-&gt; gcc -c hello.s -o hello.o<br>4-&gt; gcc hello.o -o hello</p>
</blockquote>
<p>步骤1：<strong>预处理阶段</strong>，处理以 # 开头的预处理命令；<br>步骤2：<strong>编译阶段</strong>，翻译成汇编文件；<br>步骤3：<strong>汇编阶段</strong>，将汇编文件翻译成可重定位目标文件（.o文件）；<br>步骤4：<strong>链接阶段</strong>，将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。<br><img src="https://qqadapt.qpic.cn/txdocpic/0/8a5e60d8034df3a7be257782321abbca/0" alt="compilie&amp;link"><br>以上就是编译链接成可执行文件的过程，下面介绍两种链接方式：<strong>静态链接</strong>和<strong>动态链接</strong>。</p>
<h2 id="2-静态链接"><a href="#2-静态链接" class="headerlink" title="2. 静态链接"></a>2. 静态链接</h2><h3 id="2-1-为什么需要静态链接"><a href="#2-1-为什么需要静态链接" class="headerlink" title="2.1 为什么需要静态链接"></a>2.1 为什么需要静态链接</h3><p>在实际开发中，我们不可能把所有的代码都写在一个源文件中，所以会出现很多源文件。这些源文件并非是独立的，而是有一定的依赖关系，如一个源文件需要调用另一个源文件中的函数，但是每个源文件都是独立编译的，即每个 <strong>.c</strong> 将会编译成对应的 <strong>.o</strong> 文件，那么就需要将这些目标文件进行链接，从而生成一个可执行文件，这个过程就是静态链接。</p>
<h3 id="2-2-静态链接的过程"><a href="#2-2-静态链接的过程" class="headerlink" title="2.2 静态链接的过程"></a>2.2 静态链接的过程</h3><p>在Linux中，静态链接库以 .a 为文件后缀，如 libc.a 为 c语言的静态链接库。<br>在示例程序中，调用了 stdio.h 中的 printf 函数，在 libc.a 中找到 printf.o 和它的依赖目标文件，然后将这些依赖文件和我们的 hello.o 文件链接打包成一个可执行文件，过程如下图：<br><img src="https://qqadapt.qpic.cn/txdocpic/0/830e5f24d85ce1067c6bc9125e003bc9/0" alt="static"></p>
<h3 id="2-3-静态链接的优缺点"><a href="#2-3-静态链接的优缺点" class="headerlink" title="2.3 静态链接的优缺点"></a>2.3 静态链接的优缺点</h3><p><strong>优点：</strong></p>
<ol>
<li>因为可执行程序中已经具备了执行程序所需要的所有东西，所以程序加载速度快，执行速度也快。</li>
<li>只需要保证开发者计算机上有正确的 .a 文件，在发布可执行程序时，不需要考虑发布机器上是否存在 .a 文件。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>使用静态链接生成的可执行文件体积较大，包含了相同的公共代码，造成空间浪费。</li>
<li>更新困难，如果静态库文件更新，需要重新编译链接整个可执行文件，再行发布。</li>
</ol>
<h2 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h2><p>为了解决静态链接的缺点，就需要使用到动态链接。<br>在Linux中，动态链接库以 .so 为文件后缀。<br>动态链接的思想就是将程序按照模块拆分为各个相对独立的部分，在程序运行时才将它们链接在一起形成完整的程序。<br><img src="https://qqadapt.qpic.cn/txdocpic/0/4f8013511ac6fbf141ebdfe1a1d065aa/0" alt="mem"><br><strong>优点：</strong></p>
<ol>
<li>更加节省内存并减少页面交换。</li>
<li>更新方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。</li>
<li>可是实现进程之间的资源共享。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>当某个动态库更新后，如果依赖该动态库的程序与更新后的动态库不兼容，则该程序将无法正常执行。</li>
<li>因为是运行时加载，所以相对于静态链接，性能会有所下降。</li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>编译</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 内存对齐</title>
    <url>/c/cpp-memory-alignment/</url>
    <content><![CDATA[<h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>内存对齐，也叫字节对齐。<br>现代计算机中，内存空间都是按照字节划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。<br><a id="more"></a></p>
<p>CPU每次从内存中取出数据或者指令时，并非想象中的一个一个字节取出拼接的，而是根据自己的字长，也就是CPU一次能够处理的数据长度取出内存块，比如32位处理器将取出32位也就是4个字节的内存块进行处理。</p>
<h2 id="为什么需要内存对齐"><a href="#为什么需要内存对齐" class="headerlink" title="为什么需要内存对齐"></a>为什么需要内存对齐</h2><p>1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。<br>2、性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
<h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><p>每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数，例如32位处理器，默认为4，64位处理器，默认为8)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。<br>规则：<br>1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。<br>2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。<br>3、结合1、2可推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。  </p>
<p>根据上述规则，得到整体对齐系数= min((max(type1,type2,type3,…), n)<br>其中type为结构体中的类型的字节大小，n为#pragma pack(n)设定值  </p>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n) <span class="comment">/* n = 1, 2, 4, 8, 16 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 4byte</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 1byte</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 2byte</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 1byte</span></span><br><span class="line">&#125; ma;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ma size=%ld\n&quot;</span>, <span class="keyword">sizeof</span>(ma));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1. #pragma pack(1)</strong></p>
<p>按照1字节对齐的结果：<br>ma size=8<br>分析：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按1对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按1对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按1对齐；偏移量为5；存放位置区间[5,6]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按1对齐；偏移量为7；存放位置区间[7]</span></span><br><span class="line">    <span class="comment">// 共8个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure>
<p>   整体对齐系数=min(max(int, char, short, char), 1) = 1<br>所以不需要再进行整体对齐。整体大小就为8。  </p>
<p><strong>2. #pragma pack(2)</strong></p>
<p>按照2字节对齐的结果：<br>ma size=16<br>分析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按2对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按2对齐；偏移量为8；存放位置区间[8]</span></span><br><span class="line">    <span class="comment">// 共9个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure>
<p>整体对齐系数=min(max(int, char, short, char), 2) = 2<br>将9提升到2的倍数，则为10，所以最终结果为10个字节。</p>
<p><strong>3. #pragma pack(4)</strong></p>
<p>按照4字节对齐的结果：<br>ma size=12<br>分析：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按2对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按2对齐；偏移量为8；存放位置区间[8]</span></span><br><span class="line">    <span class="comment">// 共9个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure>
<p>整体对齐系数=min(max(int, char, short, char), 4) = 4<br>将9提升到4的倍数，则为12，所以最终结果为12个字节。</p>
<p><strong>4. #pragma pack(8)</strong></p>
<p>按照8字节对齐的结果：<br>ma size=12<br>分析：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按2对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按2对齐；偏移量为8；存放位置区间[8]</span></span><br><span class="line">    <span class="comment">// 共9个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure>
<p>整体对齐系数=min(max(int, char, short, char), 8) = 4<br>将9提升到4的倍数，则为12，所以最终结果为12个字节。</p>
<p><strong>5. #pragma pack(16)</strong></p>
<p>按照16字节对齐的结果：<br>ma size=12<br>分析：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按2对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按2对齐；偏移量为8；存放位置区间[8]</span></span><br><span class="line">    <span class="comment">// 共9个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure>
<p>整体对齐系数=min(max(int, char, short, char), 16) = 4<br>将9提升到4的倍数，则为12，所以最终结果为12个字节。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c</tag>
        <tag>内存对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存淘汰算法LRU与LFU</title>
    <url>/c/cpp-lru-lfu/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>常用的缓存过期淘汰策略有：LRU、LFU、FIFO等，因为FIFO（First in first out）算法是一种先进先出的队列，算法很简单，就不具体描述了，下面介绍LRU和LFU的算法策略。<br><a id="more"></a><br>LRU：最近最少使用淘汰算法（Least Recently Used）。如果一个数据在最近一段时间内没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此当空间满时，最久没有被访问的数据最先被淘汰。<br>LFU：最不经常使用淘汰算法（Least Frequently Used），如果一个数据在最近一段时间内很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此当空间满时，最小频率访问的数据最先被淘汰。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p><strong>LRU：</strong><br>最常见的算法是使用一个链表保存缓存数据，不考虑时间复杂度的基本算法思想如下：  </p>
<ol>
<li>新数据插入到链表头。</li>
<li>缓存命中的数据（被访问到的），将移到链表头。</li>
<li>当链表满时，将链表尾部数据淘汰（丢弃）。</li>
</ol>
<p>leetcode上关于LRU算法的题目：<a href="https://leetcode-cn.com/problems/lru-cache/">https://leetcode-cn.com/problems/lru-cache/</a>  </p>
<p>O(1)时间复杂度的解法：<br>【哈希表+双向链表】算法思想：  </p>
<p>定义一个哈希表ket_table，该哈希表的索引为key，每个索引存放链表里的内存地址，链表中存放着缓存数据。  </p>
<p>当执行get(key)操作时，如果该key存在于哈希表中，通过key可以直接得到缓存的内存地址，将值取出返回，如果不存在则返回-1。当查找到缓存时，需要将缓存数据置于链表头部，表示该缓存是最新被访问的。  </p>
<p>当执行put(key, value)操作时，如果key存在于哈希表中，删除链表中的数据，再将新数据插入到链表头部，并将头部的内存地址赋值给该key的哈希表中，如果不存在，则判断是否缓存已满，没有满则直接插入链表和哈希表中，满了则删除链表尾部的缓存数据，然后再进行插入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_capacity;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; lrus;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator&gt; m_key_table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        m_capacity = capacity;</span><br><span class="line">        m_key_table.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_key_table.count(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果key存在，则取出value，并把数据移到链表头</span></span><br><span class="line">            <span class="keyword">int</span> value = m_key_table[key]-&gt;second;</span><br><span class="line">            lrus.erase(m_key_table[key]);</span><br><span class="line">            lrus.push_front(&#123;key, value&#125;);</span><br><span class="line">            m_key_table[key] = lrus.begin();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_key_table.count(key)) &#123;</span><br><span class="line">             <span class="comment">// 如果存在，则删除链表里的数据</span></span><br><span class="line">            lrus.erase(m_key_table[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_key_table.size() == m_capacity) &#123;</span><br><span class="line">             <span class="comment">// 如果超出了缓存容量，则需要链表尾部删除</span></span><br><span class="line">            m_key_table.erase(lrus.back().first);</span><br><span class="line">            lrus.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新插入的数据放到链表头</span></span><br><span class="line">        lrus.push_front(&#123;key, value&#125;);</span><br><span class="line">        m_key_table[key] = lrus.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>LFU：</strong><br>leetcode上关于LFU算法的题目：<a href="https://leetcode-cn.com/problems/lfu-cache/">https://leetcode-cn.com/problems/lfu-cache/</a><br>O(1)时间复杂度解法：<br>【哈希表+双向链表】算法思想：  </p>
<p>该算法与LRU算法类似，不过LFU需要用到访问频率信息，所以该算法需要两个哈希表实现。  </p>
<p>第一个哈希表freq_table的索引为freq（访问频率），每个索引存放一个双向链表，第二个哈希表key_table的索引为key，每个索引存放该key在链表中的内存地址。还需要一个类变量m_min_freq用于保存最小的访问频率，当需要进行删除缓存的时候，可以用该变量定位缓存的位置进行删除。  </p>
<p>当执行get(key)操作时，通过key在key_table中获取缓存的内存地址，如果不存在，则返回-1，如果存在，则取出缓存数据，访问频率需要增加1，所以要将缓存放入freq_table[freq+1]的链表头部。  </p>
<p>当执行put(key, value)操作时，判断该key是否在key_table中，如果不存在，并且容量没有满，则直接插入到freq_table[1]的链表中，如果容量满了，则通过m_min_freq找到最小访问频率的链表，从尾部删除数据，然后将新数据直接插入到freq_table[1]的链表头部。如果key存在与key_table中，则取出链表中的缓存数据，更新新的value，并增加访问频率(freq+1)，将插入到freq_table[1]的链表头部。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LFUStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value, freq;</span><br><span class="line">    LFUStruct (<span class="keyword">int</span> k, <span class="keyword">int</span> v, <span class="keyword">int</span> f) : key(k), value(v), freq(f) &#123;&#125;</span><br><span class="line">&#125; lfu;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_capacity;</span><br><span class="line">    <span class="keyword">int</span> m_min_freq;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;lfu&gt;::iterator&gt; m_key_table;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;lfu&gt;&gt; m_freq_table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        m_capacity = capacity;</span><br><span class="line">        m_min_freq = <span class="number">0</span>;</span><br><span class="line">        m_key_table.clear();</span><br><span class="line">        m_freq_table.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = m_key_table.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m_key_table.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存在key，则取出value并且freq+1，把节点移入到m_freq_table[freq+1]的链表顶部</span></span><br><span class="line">        <span class="keyword">auto</span> get_it = it-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> value = get_it-&gt;value;</span><br><span class="line">        <span class="keyword">int</span> freq = get_it-&gt;freq;</span><br><span class="line">        m_freq_table[freq].erase(get_it);</span><br><span class="line">        <span class="keyword">if</span> (m_freq_table[freq].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            m_freq_table.erase(freq);</span><br><span class="line">            <span class="keyword">if</span> (m_min_freq == freq) m_min_freq += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_freq_table[freq + <span class="number">1</span>].push_front(lfu(key, value, freq + <span class="number">1</span>));</span><br><span class="line">        m_key_table[key] = m_freq_table[freq + <span class="number">1</span>].begin();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = m_key_table.find(key);</span><br><span class="line">        <span class="comment">// 如果没有找到该key，表明不存在，则插入</span></span><br><span class="line">        <span class="keyword">if</span> (it == m_key_table.end()) &#123;</span><br><span class="line">            <span class="comment">// 当缓存达到最大容量时，需要删除访问频率最少的键</span></span><br><span class="line">            <span class="keyword">if</span> (m_key_table.size() &gt;= m_capacity) &#123;</span><br><span class="line">                <span class="keyword">auto</span> del = m_freq_table[m_min_freq].back(); <span class="comment">// 链表末尾弹出需要删除的节点</span></span><br><span class="line">                m_freq_table[m_min_freq].pop_back();</span><br><span class="line">                m_key_table.erase(del.key);</span><br><span class="line">                <span class="keyword">if</span>(m_freq_table[m_min_freq].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    m_freq_table.erase(m_min_freq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入新缓存</span></span><br><span class="line">            m_freq_table[<span class="number">1</span>].push_front(lfu(key, value, <span class="number">1</span>));</span><br><span class="line">            m_key_table[key] = m_freq_table[<span class="number">1</span>].begin();</span><br><span class="line">            m_min_freq = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果找到key，则更新</span></span><br><span class="line">            <span class="keyword">auto</span> update_it = it-&gt;second;</span><br><span class="line">            <span class="keyword">int</span> freq = update_it-&gt;freq;</span><br><span class="line">            m_freq_table[freq].erase(update_it); <span class="comment">// 删除freq_table里的缓存节点</span></span><br><span class="line">            <span class="keyword">if</span> (m_freq_table[freq].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                m_freq_table.erase(freq);</span><br><span class="line">                <span class="keyword">if</span> (m_min_freq == freq) &#123;</span><br><span class="line">                    m_min_freq += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m_freq_table[freq + <span class="number">1</span>].push_front(lfu(key, value, freq + <span class="number">1</span>));</span><br><span class="line">            m_key_table[key] = m_freq_table[freq + <span class="number">1</span>].begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>lru</tag>
        <tag>lfu</tag>
      </tags>
  </entry>
  <entry>
    <title>gohbase二次封装</title>
    <url>/golang/go-hbase-encapsulation/</url>
    <content><![CDATA[<p>对 <a href="https://github.com/tsuna/gohbase">gohbase</a> 进行封装，提供简单的 API 接口以方便使用。<br><a id="more"></a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hbase</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/tsuna/gohbase&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/tsuna/gohbase/hrpc&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HbaseClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    host        <span class="keyword">string</span></span><br><span class="line">    option      <span class="keyword">string</span></span><br><span class="line">    client      gohbase.Client</span><br><span class="line">    adminClient gohbase.AdminClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工厂模式创建实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHbaseClient</span><span class="params">(host <span class="keyword">string</span>)</span> *<span class="title">HbaseClient</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;HbaseClient&#123;</span><br><span class="line">        host: host,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接hbase</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">Connect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hb.client = gohbase.NewClient(hb.host)</span><br><span class="line">    hb.adminClient = gohbase.NewAdminClient(hb.host)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">CreateTable</span><span class="params">(table <span class="keyword">string</span>, families <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    createRequest := hrpc.NewCreateTable(context.Background(), []<span class="keyword">byte</span>(table), families)</span><br><span class="line">    <span class="keyword">if</span> err = hb.adminClient.CreateTable(createRequest); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[CreateTable] CreateTable error! table-&gt;%s, error-&gt;%v&quot;</span>, table, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">DeleteTable</span><span class="params">(table <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    delRequest := hrpc.NewDeleteTable(context.Background(), []<span class="keyword">byte</span>(table))</span><br><span class="line">    <span class="keyword">if</span> err = hb.adminClient.DeleteTable(delRequest); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[DeleteTable] DeleteTable error! table-&gt;%s, error-&gt;%v&quot;</span>, table, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">PutsByRowkey</span><span class="params">(table, rowKey <span class="keyword">string</span>, values <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    putRequest, err := hrpc.NewPutStr(context.Background(), table, rowKey, values)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[PutsByRowkey] NewPutStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = hb.client.Put(putRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[PutsByRowkey] Put error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">UpdateByRowkey</span><span class="params">(table, rowKey <span class="keyword">string</span>, values <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    putRequest, err := hrpc.NewPutStr(context.Background(), table, rowKey, values)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[UpdateByRowkey] NewPutStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = hb.client.Put(putRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[UpdateByRowkey] Put error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查rowkey</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">GetsByRowkey</span><span class="params">(table, rowKey <span class="keyword">string</span>)</span> <span class="params">(*hrpc.Result, error)</span></span> &#123;</span><br><span class="line">    getRequest, err := hrpc.NewGetStr(context.Background(), table, rowKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[GetsByRowkey] NewGetStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := hb.client.Get(getRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[GetsByRowkey] Get error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查rowkkey的某些列族</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">GetsByRowkeyCF</span><span class="params">(table, rowKey <span class="keyword">string</span>, families <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span> <span class="params">(*hrpc.Result, error)</span></span> &#123;</span><br><span class="line">    getRequest, err := hrpc.NewGetStr(context.Background(), table, rowKey, hrpc.Families(families))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[GetsByRowkeyCF] NewGetStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := hb.client.Get(getRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[GetsByRowkeyCF] Get error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">DeleteByRowkey</span><span class="params">(table, rowKey <span class="keyword">string</span>, value <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    delRequest, err := hrpc.NewDelStr(context.Background(), table, rowKey, value)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[DeleteByRowkey] NewDelStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err = hb.client.Delete(delRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[DeleteByRowkey] Delete error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">ScanByTable</span><span class="params">(table, startRow, stopRow <span class="keyword">string</span>)</span> <span class="params">([]*hrpc.Result, error)</span></span> &#123;</span><br><span class="line">    scanRequest, err := hrpc.NewScanRangeStr(context.Background(), table, startRow, stopRow)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[ScanByTable] NewScanRangeStr error! table-&gt;%s, startRow-&gt;%s, endRow-&gt;%s, error-&gt;%v&quot;</span>, table, startRow, stopRow, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    scan := hb.client.Scan(scanRequest)</span><br><span class="line">    <span class="keyword">var</span> res []*hrpc.Result</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        getRsp, err := scan.Next()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF || getRsp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;[ScanByTable] scan.Next error! table-&gt;%s, error-&gt;%v&quot;</span>, table, err)</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, getRsp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">IsExistRowKey</span><span class="params">(table, rowKey <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    res, err := hb.GetsByRowkey(table, rowKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(res.Cells) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>hbase</tag>
        <tag>gohbase</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O模型浅析</title>
    <url>/net/net-io-model/</url>
    <content><![CDATA[<h2 id="I-O概念"><a href="#I-O概念" class="headerlink" title="I/O概念"></a>I/O概念</h2><p>众所周知，在 Linux 的世界中一切皆为文件，而文件的本质其实就是一串二进制流，不管是 socket 还是 FIFO、管道、终端等，对于Linux来说，一切都是文件、一切都是流。在信息交换过程中，我们对这些流进行收/发操作，这一过程简称为 I/O 操作（input and output）。<br><a id="more"></a></p>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>在了解了什么是 I/O 后，接下来介绍五种 I/O 模型：阻塞I/O(blocking I/O)、非阻塞I/O(non-blocking I/O)、多路复用I/O( I/O multiplexing )、信号驱动I/O(signal blocking I/O) 以及 异步I/O(Asynchronous I/O)。</p>
<h3 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h3><p>顾名思义，当进程在等待数据时，若该数据一直没有产生，则该进程将会一直等待，直到产生数据为止，这一过程中，进程的状态是阻塞的。<br>在 Linux 中，默认情况下所有的 socket 都是 blocking，一个典型的操作流程大概是这样的：<br><img src="https://i.loli.net/2020/10/29/KHLImifA9rzw6Od.png" alt="blockingIO.png"><br>当用户态进程调用了 recvfrom 这个系统调用接收数据，内核（kernel）就开始了 I/O 的第一个阶段：准备数据。对于网络 I/O 来说，很多数据一开始还没有到达，这个时候内核就要等待足够的数据到达。<br>该用户态进程将一直在此等待，不会进行其他的操作，直到内核态准备好了数据后，将数据从内核态拷贝到用户态内存空间，然后 recvfrom 成功返回，用户进程才解除<strong>阻塞</strong>的状态，开始处理收到的数据。<br><strong>所以，阻塞 I/O 的特点就是在 I/O 执行的两个阶段（等待数据和拷贝数据两个阶段）都被 block 了。</strong></p>
<h3 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h3><p>在非阻塞I/O模型中，用户态进程等待内核的数据，当内核数据尚未准备好的时候，用户态进程将会不断的询问内核，直到内核准备好数据。<br><img src="https://i.loli.net/2020/10/29/bUONl3pc9oCf2g8.png" alt="non-blockingIO.png"><br>Linux下，可以通过设置 socket 使其变为non-blocking。<br>当用户态进程调用了 recvfrom 这个系统调用接收数据，当前内核并没有数据报文产生，此时 recvfrom 返回 EWOULDBLOCK，用户态进程会一直调用 recvfrom 询问内核，待内核准备好数据后，将数据从内核态拷贝到用户态内存空间，recvfrom 成功返回，用户态进程才开始处理收到的数据。</p>
<h3 id="多路复用I-O"><a href="#多路复用I-O" class="headerlink" title="多路复用I/O"></a>多路复用I/O</h3><p>如果一个进程需要处理多种不同的消息，那么可能的做法是开启多条线程，每条线程接收处理一类消息，如果每条线程都采用阻塞 I/O 模型，那么也就是多线程中使用阻塞式 I/O。<br>对于上述的场景中，其实可以使用多路复用 I/O 模型处理，无需采用多线程监听消息的方式，这其中涉及到 select、poll、epoll 等不同的方法。<br><img src="https://i.loli.net/2020/10/29/6KFHMhLrBVNQE8T.png" alt="IOMultiplexing.png"><br>如上图所示，用户态进程采用 select 的方法，通过 select 可以等待多个不同类型的消息，如果其中有一个类型的消息准备好，则 select 会返回信息，然后用户态进程调用 recvfrom 接收数据。<br>select、poll、epoll 的区别和用法会单独开一篇文章来讲。</p>
<h3 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h3><p>在信号驱动式 I/O 模型中，与阻塞式和非阻塞式有了一个本质性的区别，那就是用户态不再等待内核态的数据准备好，就可以直接去做别的事了。<br><img src="https://i.loli.net/2020/10/29/NIw8LKDy4asjehJ.png" alt="singleIO.png"><br>如上图所示，当需要等待数据的时候，首先用户态进程会向内核发送一个信号，告诉内核需要什么数据，然后用户态就可以去做别的事了。而当内核态数据准备好后，内核立刻发给用户态一个信号，告知数据已准备好，用户态进程收到后，立马调用 recvfrom，等数据从内核空间拷贝到用户内存空间，待完成之后，recvfrom 成功返回，用户态进程开始处理数据。</p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>异步 I/O 模型相对于信号驱动 I/O 模型就更彻底了。<br><img src="https://i.loli.net/2020/10/29/DaCjP1SvlJbN9Tu.png" alt="asyncIO.png"><br>首先用户态进程会告诉内核需要什么数据（上图中通过 aio_read），然后用户态进程就不管了，内核等待用户态需要的数据准备好，然后将数据拷贝到用户态空间，此时才通知用户态进程数据已准备好，然后用户态进程直接处理用户态空间中的数据。</p>
<h2 id="I-O模型比较"><a href="#I-O模型比较" class="headerlink" title="I/O模型比较"></a>I/O模型比较</h2><p>一张图解释所有：<br><img src="https://i.loli.net/2020/10/29/QTr9RNWb1eYUnKm.png" alt="IOCompare.png"></p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>I/O模型</tag>
      </tags>
  </entry>
  <entry>
    <title>挖矿与矿池</title>
    <url>/blockchain/minging-miningpool/</url>
    <content><![CDATA[<h2 id="1-挖矿"><a href="#1-挖矿" class="headerlink" title="1. 挖矿"></a>1. 挖矿</h2><h3 id="1-1-什么是挖矿"><a href="#1-1-什么是挖矿" class="headerlink" title="1.1 什么是挖矿"></a>1.1 什么是挖矿</h3><p>挖矿的本质就是构造符合规则（PoW共识机制）的区块并进行全网验证的过程。作为激励，矿工成功挖掘到区块后，可以从中获取区块奖励和交易费奖励。</p>
<p>下面以BTC为例，阐述挖矿的运作流程。</p>
<a id="more"></a>
<h3 id="1-2-BTC如何挖矿？"><a href="#1-2-BTC如何挖矿？" class="headerlink" title="1.2 BTC如何挖矿？"></a>1.2 BTC如何挖矿？</h3><p><img src="https://i.loli.net/2021/07/08/lgS1IYWGuPKbrTN.png" alt="block_package.png"></p>
<p>上面这张图描述了如何构造一个比特币区块。区块构造流程：</p>
<ol>
<li>从未确定交易池中选取交易，通常尽可能多的优先选择手续费高的交易。</li>
<li>构造coinbase交易，计算打包交易中的挖矿手续费和coinbase奖励。</li>
<li>矿工将所有交易（包含coinbase交易）添加到区块体中。</li>
<li>对所有交易（包含coinbase交易）进行hash计算，并构造出merkle树，得到merkle树根哈希值。</li>
<li>根据当前环境填充区块头中的当前版本、父区块哈希、时间戳和难度，自行填写nNonce，与得到的merkle树根哈希值一同构成区块头。</li>
</ol>
<p>完成以上步骤，一个比特币区块就构建好了。</p>
<h3 id="1-3-BTC挖矿过程"><a href="#1-3-BTC挖矿过程" class="headerlink" title="1.3 BTC挖矿过程"></a>1.3 BTC挖矿过程</h3><p><img src="https://i.loli.net/2021/07/08/Silnx2oewNPvURD.png" alt="block_verify.png"></p>
<p>下面我们来看一下比特币的挖矿验证过程：</p>
<ol>
<li>区块打包成功后，对区块中的区块头进行hash256运算并得到结果。</li>
<li><p>将区块头哈希值与当前target（由nBits解压得来的）比对，这时比对结果会有两种情况：</p>
<ul>
<li>若区块头哈希值大于target，则表明不符合规则，需要重新构造区块头继续循环验证。</li>
<li>若区块头哈希值小于等于target，则全网节点广播验证，节点验证成功后，成功加入到区块链中。<br>以上就是比特币挖矿的全过程。</li>
</ul>
</li>
</ol>
<p>在区块头中，当前版本、父区块哈希、难度是固定不可改变的，那么想要改变区块头哈希值，需要调整nNonce、nTime和coinbase交易，而交易merkle树根的哈希值会随着coinbase交易的改变而改变。</p>
<h3 id="1-4-BTC的coinbase结构"><a href="#1-4-BTC的coinbase结构" class="headerlink" title="1.4 BTC的coinbase结构"></a>1.4 BTC的coinbase结构</h3><p>我们来看一下coinbase交易的结构，在下面的表格中可以看到在coinbase交易中，唯一能改变的就是coinbase data这个字段。所以该字段数据可由矿工自定义，用于增加区块头哈希的搜索空间。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>32 bytes</td>
<td>Transaction Hash</td>
<td>32字节全部为0</td>
</tr>
<tr>
<td>4 bytes</td>
<td>Output Index</td>
<td>固定值：0xFFFFFFFF</td>
</tr>
<tr>
<td>1-9 bytes(VarInt)</td>
<td>Coinbase Data size</td>
<td>coinbase数据的长度</td>
</tr>
<tr>
<td>Variable</td>
<td>Coinbase Data</td>
<td>数据由矿工自定义，用于增加搜索空间</td>
</tr>
<tr>
<td>4 bytes</td>
<td>Sequence Number</td>
<td>固定值：0xFFFFFFFF</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-5-BTC中目标、难度概念理解"><a href="#1-5-BTC中目标、难度概念理解" class="headerlink" title="1.5 BTC中目标、难度概念理解"></a>1.5 BTC中目标、难度概念理解</h3><p>我们前面说过，比特币挖矿需要<code>区块头的哈希值</code>与<code>当前的目标</code>进行对比。所以我们需要理解一下什么是目标、什么是难度。</p>
<p><strong>目标（target）</strong>：矿工计算的区块HASH值需要小于等于目标值才能有效出块。<br><strong>难度（difficulty）</strong>：难度是对挖矿困难程度的度量，即指：计算符合给定目标的一个Hash值的困难程度。<br><strong>nBits</strong>：目标值被压缩在区块头的nBits字段中，nBits字段以十六进制表示，总共有4个字节，前1个字节为<code>指数（exponent）</code>，后3个字节为<code>系数（coefficient）</code>。</p>
<p>目标可由nBits计算得到，目标计算公式如下：</p>
<blockquote>
<p>target = coefficient * 256^(exponent - 0x03)</p>
</blockquote>
<p>而难度由目标计算得到，难度计算公式如下：</p>
<blockquote>
<p>difficulty = 创世区块target / 当前区块target</p>
</blockquote>
<p>从比特币区块浏览器中可以查到，创世区块的nBits为<code>0x1D00FFFF</code>，其中指数为<code>0x1D</code>，系数为<code>0x00FFFF</code>，将其代入到目标计算公式中，可得创世区块的目标值：</p>
<blockquote>
<p>target = 0x00FFFF * 256^(0x1D - 0x03)</p>
<p>target = 0x00000000FFFF0000000000000000000000000000000000000000000000000000</p>
</blockquote>
<p>我们以高度为<code>686,580</code>这个高度区块为例子：</p>
<p><img src="https://i.loli.net/2021/07/08/hsrc1zMva2n9tkI.png" alt="block_case.png"></p>
<p>通过公式，可以计算出：</p>
<blockquote>
<p>current_target = 0x0d5f7b * 256^(0x17 - 0x03)</p>
<p>current_target = 0x0000000000000000000d5f7b0000000000000000000000000000000000000000</p>
</blockquote>
<p>得到了当前的目标值与创世区块目标值，通过难度公式，可计算出高度<code>686,580</code>的难度为：</p>
<blockquote>
<p>difficulty = init_target / current_target = 21,047,730,572,451 ≈ 21.05T</p>
</blockquote>
<h3 id="1-6-能不能一次挖多个币呢？"><a href="#1-6-能不能一次挖多个币呢？" class="headerlink" title="1.6 能不能一次挖多个币呢？"></a>1.6 能不能一次挖多个币呢？</h3><p><strong>答案是肯定的。</strong></p>
<p>当前存在一种机制，可以使得矿工在不影响挖比特币的同时，还能顺带挖另外几种虚拟币，以增加额外的收入，该机制就是联合挖矿。</p>
<h2 id="2-联合挖矿"><a href="#2-联合挖矿" class="headerlink" title="2. 联合挖矿"></a>2. 联合挖矿</h2><h3 id="2-1-ViaBTC矿池联合挖矿赠币规则"><a href="#2-1-ViaBTC矿池联合挖矿赠币规则" class="headerlink" title="2.1 ViaBTC矿池联合挖矿赠币规则"></a>2.1 ViaBTC矿池联合挖矿赠币规则</h3><p>目前许多主流的矿池都上线了挖矿赠币业务，例如在我们的矿池服务中，挖BTC可以额外获得NMC、EMC、SYS和ELA的赠币，挖LTC可以额外获得DOGE的赠币。</p>
<p><img src="https://i.loli.net/2021/07/08/qQo8PCYU3BSwexy.png" alt="merge_mining_rule.png"></p>
<p>下面我们来看一下联合挖矿的实现原理。</p>
<h3 id="2-2-联合挖矿实现"><a href="#2-2-联合挖矿实现" class="headerlink" title="2.2 联合挖矿实现"></a>2.2 联合挖矿实现</h3><ol>
<li><p>通过 rpc 调用辅链节点的 <code>getauxblock</code> 或者 <code>createauxblock</code> 方法，创建新块。返回结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hash&quot;                (string) hash of the created block</span><br><span class="line">  &quot;chainid&quot;             (numeric) chain ID for this block</span><br><span class="line">  &quot;previousblockhash&quot;   (string) hash of the previous block</span><br><span class="line">  &quot;coinbasevalue&quot;       (numeric) value of the block&#x27;s coinbase</span><br><span class="line">  &quot;bits&quot;                (string) compressed target of the block</span><br><span class="line">  &quot;height&quot;              (numeric) height of the block</span><br><span class="line">  &quot;_target&quot;             (string) target in reversed byte order, deprecated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Bitcoin的coinbase交易中，coinbase data字段可以写入任意自定义数据，那么通过写入规定格式的数据。我们在coinbase的coinbase data中添加以下信息：</p>
<p><img src="https://i.loli.net/2021/07/08/mV6sGop1d4iY2nQ.png" alt="coinbase_structure.png"></p>
<p>当有多条辅链时，需要用多条辅链的block_hash来构建出merkle树。那么就需要考虑辅链在merkle树底部的插槽位置。使用以下算法将chain ID转换为辅链的block_hash所在的merkle树的插槽位置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal_merkle_index</span><span class="params">(<span class="keyword">int</span> chain_id, <span class="keyword">int</span> nonce, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rand = nonce;</span><br><span class="line">    rand = rand * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    rand += chain_id;</span><br><span class="line">    rand = rand * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> rand % size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>矿工照常以挖比特币的方式挖矿，但有一点不同的是，需要判断以下三种情况：</p>
<ul>
<li>btc_hash_value &lt;= btc_target：矿工广播区块，矿工可以得到BTC的挖矿奖励和NMC辅链的挖矿奖励。</li>
<li>btc_target &lt; btc_hash_value &lt;= aux_target：矿工广播区块，矿工不能获取BTC的挖矿奖励，但是能获取辅链的挖矿奖励。</li>
<li>btc_hash_value &gt; aux_target：矿工不会广播。</li>
</ul>
</li>
<li><p>当矿工挖出区块后，通过 rpc 调用辅链节点的 <code>submitauxblock</code> 方法提交区块验证，参数与结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arguments:</span><br><span class="line">1. hash       (string, required) Hash of the block to submit</span><br><span class="line">2. auxpow     (string, required) Serialised auxpow found</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">xxxxx         (boolean) whether the submitted block was correct</span><br></pre></td></tr></table></figure>
<p>其中，auxpow包含以下内容：</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Variable</td>
<td>coinbase</td>
<td>主链的coinbase信息</td>
</tr>
<tr>
<td>32 bytes</td>
<td>block_hash</td>
<td>主链区块hash值</td>
</tr>
<tr>
<td>Variable</td>
<td>coinbase_branch</td>
<td>主链的交易merkle分支</td>
</tr>
<tr>
<td>Variable</td>
<td>blockchain_branch</td>
<td>多个辅链的merkle分支</td>
</tr>
<tr>
<td>80 bytes</td>
<td>parent_block</td>
<td>主链区块头信息</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-个人（solo）挖矿的劣势"><a href="#2-3-个人（solo）挖矿的劣势" class="headerlink" title="2.3 个人（solo）挖矿的劣势"></a>2.3 个人（solo）挖矿的劣势</h3><p><img src="https://i.loli.net/2021/07/08/YrjJdNhtVQcRFn2.png" alt="solo_mining.png"></p>
<p>随着挖矿的人越来越多，挖矿设备也从cpu到显卡gpu再到专业矿机，算力越来越大，独立矿工挖到区块的概率越来越小，收益也越来越低，如果继续投入资金购买电脑，显卡、矿机等硬件设备，会大大提高成本，风险也越来越大，所以很多矿工不会选择 Solo 挖矿这种投资方式。</p>
<p>劣势：</p>
<ol>
<li>硬盘和带宽要求大</li>
<li>挖矿成功概率极低</li>
</ol>
<p>于是就有人提出把大家的算力集中在一起挖矿，算力大了，挖到区块的概率就会大大提高，然后再根据每个参与的矿工所占算力配额来进行奖励分配。<br>使用这种方法建立的特殊节点，就是矿池。</p>
<h2 id="3-矿池"><a href="#3-矿池" class="headerlink" title="3 矿池"></a>3 矿池</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>我们来看一下这张图，左边是区块链网络，上面这个是solo矿工，相比于全网算力来说自身的算力非常小，挖矿成功的概率也极小，下面的是矿池。</p>
<p><img src="https://i.loli.net/2021/07/08/dyp6fKmPYNXLSCu.png" alt="pool.png"></p>
<p>矿池是矿工的<strong>集合地</strong>，任何矿工都可以加入，无论个体还是组织，无论专业还是业余，都能为矿池提供自己的一份算力。加入到矿池的矿工挖到矿后，获得的奖励会被分配到矿池，然后矿池再根据预先设定的分红规则并结合各个矿工的算力进行奖励发放。<br>加入到矿池的矿工，只需要做一件事，那就是不停的计算矿池下发的任务，算出符合矿池难度的区块就进行提交。<br>矿池的工作就是需要对矿工进行管理，统计矿工算力和贡献，挖矿任务管理等。<br>矿池与矿工之间使用的是stratum矿池协议进行交互的，这是很重要的交互协议。</p>
<h3 id="3-2-stratum矿池协议"><a href="#3-2-stratum矿池协议" class="headerlink" title="3.2 stratum矿池协议"></a>3.2 stratum矿池协议</h3><p>stratum矿池协议有很多方法，最重要的就是以下几种方法：</p>
<ul>
<li><p><strong>订阅消息（mining.subscribe）</strong></p>
<p>矿机想参与挖矿，需要主动连接到矿池，向矿池申请加入挖矿，一般会附带自己挖矿软件的版本。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">矿机消息：</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;method&quot;:&quot;mining.subscribe&quot;,&quot;params&quot;:[version]&#125;\n</span><br><span class="line">矿池响应消息：</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;result&quot;:[[[&quot;mining.set_difficulty&quot;,&quot;1&quot;],[&quot;mining.notify&quot;,&quot;1&quot;]],&quot;&#123;extraNonce1&#125;&quot;,&#123;extraNonce2_len&#125;],“error”:null&#125;\n</span><br></pre></td></tr></table></figure>
<p><strong>extraNonce1</strong>：该字段由矿池为矿工分配，为了确保每个矿工不会做重复工作。<br><strong>extraNonce2_len</strong>：设定extraNonce2字段的长度，一般为4或8个字节，矿工挖矿时，通过该字段增加搜索空间。<br>现在，我们至少有了8个字节的搜索空间，即<code>nNonce</code>的4个字节，以及<code>extraNonce2</code>的4个字节。</p>
</li>
<li><p><strong>授权消息（mining.authorize）</strong></p>
<p>矿机使用帐号和密码登录到矿池，矿池返回true则登录成功。该方法必须是在初始化连接之后马上进行，否则矿机得不到矿池任务。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">矿机消息：</span><br><span class="line">&#123;&quot;id&quot;:2,&quot;method&quot;:&quot;mining.authorize&quot;,&quot;params&quot;:[&quot;&#123;account&#125;&quot;,&quot;&#123;password&#125;&quot;]&#125;\n</span><br><span class="line">矿池响应消息：</span><br><span class="line">&#123;&quot;id&quot;:2,&quot;result&quot;:true,&quot;error&quot;:null&#125;\n</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>下发难度（mining.set_difficulty）</strong></p>
<p>矿机被授权后，那么矿池会下发任务难度给矿机，后面矿机的挖矿，必须达到任务难度要后，矿池才登记贡献。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">矿池发送消息：</span><br><span class="line">&#123;&quot;id&quot;:null,&quot;method&quot;:&quot;mining.set_difficulty&quot;,&quot;params&quot;:[&#123;难度值&#125;]&#125;\n</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>下发任务（mining.notify）</strong></p>
<p>矿池会不断向矿机下发任务，矿机接到任务后，根据任务的标示，可以继续挖上一个任务，还是立即开始新的任务挖矿。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">矿池发送消息：</span><br><span class="line">&#123;&quot;id&quot;:null,&quot;method&quot;:&quot;mining.notify&quot;,&quot;params&quot;:[&quot;&#123;jobId&#125;&quot;,&quot;&#123;prev hash&#125;&quot;,&quot;&#123;coinbase1&#125;&quot;,&quot;&#123;coinbase2&#125;&quot;,[&#123;区块交易merkle_branch&#125;],&quot;&#123;version&#125;&quot;,&quot;&#123;nBits&#125;&quot;,&quot;&#123;nTime&#125;&quot;,&#123;是否立即更换任务&#125;]&#125;\n</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交消息（mining.submit）</strong></p>
<p>矿机根据挖矿任务开始挖矿，直到发现了满足矿池难度的区块后，将构造区块头必要的信息提交给矿池验证并广播。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">矿机消息：</span><br><span class="line">&#123;&quot;id&quot;:3,&quot;method&quot;:&quot;mining.submit&quot;,&quot;params&quot;:[&quot;&#123;account&#125;&quot;,&quot;&#123;jobId&#125;&quot;,&quot;&#123;extraNonce2&#125;&quot;,&quot;&#123;time&#125;&quot;,&quot;&#123;nonce&#125;&quot;]&#125;\n</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-3-如何增加矿工的搜索空间"><a href="#3-3-如何增加矿工的搜索空间" class="headerlink" title="3.3 如何增加矿工的搜索空间"></a>3.3 如何增加矿工的搜索空间</h3><p>如果仅仅给矿工可以改变nNonce（4字节，搜索空间4294967296大约43亿）和nTime（可变动范围很小）字段，则交互的数据量很少，但这点搜索空间肯定是不够的。<br>想要增加搜索，只能从<code>hashMerkleRoot</code>下功夫，如果让矿工自己构造coinbase，进而影响hashMerkleRoot值，那么搜索空间的问题将迎刃而解。<br>而构造Merkle树并不需要所有的交易数据，只需要某几个节点上的hash值，即可计算出修改coinbase后的hashMerkleRoot值。如下图：</p>
<p><img src="https://i.loli.net/2021/07/08/7mdoVCrY1W8xTOk.png" alt="merkle_branch.png"></p>
<p>我们将交易列表顺序固定下来后，只需要将merkle树中的一小部分节点的哈希值发给矿工，矿工就可以根据这些节点进行计算得到merkle树根。</p>
<h3 id="3-4-矿工的挖矿步骤"><a href="#3-4-矿工的挖矿步骤" class="headerlink" title="3.4 矿工的挖矿步骤"></a>3.4 矿工的挖矿步骤</h3><ol>
<li><p>构造coinbase交易</p>
<blockquote>
<p>coinbase = coinbase1 + extraNonce1 + extraNonce2 + coinbase2</p>
</blockquote>
<p>对于矿工来说，<code>coinbase1</code>、<code>extraNonce1</code>、<code>coinbase2</code>都是固定的，这是由矿池来填写，矿工只关心 <code>extraNonce2</code> 的长度。矿工生成指定长度的<code>extraNonce2</code>来增加搜索空间。</p>
</li>
<li><p>构建hashMerkleRoot</p>
<p>利用coinbase和merkle_branch，生成hashMerkleRoot。</p>
</li>
<li><p>构建区块头</p>
<p>填充余下的5个字段，现在，矿工可以在 nTime、nNonce 和 extraNonce2 里搜索进行挖矿，如果嫌搜索空间还不够，只要增加Extranonce2_size为多几个字节就可轻而易举解决。</p>
</li>
</ol>
<h2 id="4-ViaBTC矿池实现"><a href="#4-ViaBTC矿池实现" class="headerlink" title="4. ViaBTC矿池实现"></a>4. ViaBTC矿池实现</h2><p>项目路径：<a href="https://github.com/viabtc/viabtc_mining_server">https://github.com/viabtc/viabtc_mining_server</a></p>
<h3 id="4-1-ViaBTC矿池架构图"><a href="#4-1-ViaBTC矿池架构图" class="headerlink" title="4.1 ViaBTC矿池架构图"></a>4.1 ViaBTC矿池架构图</h3><p><img src="https://i.loli.net/2021/07/08/cawiHMVkBtgWI4N.png" alt="mining_pool_arch.png"></p>
<p>这张图是viabtc矿池的server层架构图，接下来我将讲解每个服务的作用与功能。</p>
<h3 id="4-2-bitpeer"><a href="#4-2-bitpeer" class="headerlink" title="4.2 bitpeer"></a>4.2 bitpeer</h3><p><img src="https://i.loli.net/2021/07/08/AyrhiqYwXGoP15k.png" alt="bitpeer.png"></p>
<ul>
<li>bitpeer实现了btc的p2p网络协议，可以把它当成是一个简化版的BTC节点，实现了p2p的部分功能。</li>
<li>部署多个bitpeer，可加速区块在btc网络中的广播。</li>
<li>当区块高度更新时，需要通知jobmaster放弃旧块的挖掘转而开始新块任务</li>
</ul>
<h3 id="4-3-blockmaster"><a href="#4-3-blockmaster" class="headerlink" title="4.3 blockmaster"></a>4.3 blockmaster</h3><p><img src="https://i.loli.net/2021/07/08/cnFzt4Khwe8HU7g.png" alt="blockmaster.png"></p>
<p>blockmaster的主要功能有：</p>
<ol>
<li><p>将矿工挖掘到的区块发送给bitpeer进行广播。</p>
</li>
<li><p>为了更快的进行区块广播，blockmaster将区块处理成瘦块广播。</p>
</li>
</ol>
<p><strong>瘦块原理：</strong></p>
<p>为了更快的进行区块广播，blockmaster将区块处理成瘦块，原理是剔除掉区块交易（不包括coinbase交易）中除了交易哈希值之外的交易信息，因为交易详细信息可通过交易哈希值向节点查询，所以大大减少了区块的大小，瘦块在网络上传输将会加快，将瘦块发送给其他地区的blockmaster组装成完整的区块进行广播。</p>
<p><img src="https://i.loli.net/2021/07/08/cxTVYO489NPHmnF.png" alt="thin_block.png"></p>
<p><code>bitpeer</code> 和 <code>blockmaster</code> 这两个服务的主要功能是为了加速区块的广播，毕竟比别人先一步将区块进行广播到全网验证，就能抢先一步将区块加到链中，获得奖励。</p>
<h3 id="4-3-jobmaster"><a href="#4-3-jobmaster" class="headerlink" title="4.3 jobmaster"></a>4.3 jobmaster</h3><p>主要功能：</p>
<ol>
<li><p>构造区块信息给gateway发送挖矿任务。</p>
</li>
<li><p>接收gateway提交的区块，并进行广播。</p>
</li>
</ol>
<h3 id="4-4-gateway"><a href="#4-4-gateway" class="headerlink" title="4.4 gateway"></a>4.4 gateway</h3><p>主要功能：</p>
<ol>
<li>管理矿工、矿场管理员。</li>
<li>矿工难度值动态调整。</li>
<li>实现stratum矿池协议与矿工交互。</li>
<li><p>测算各个矿工的算力。</p>
</li>
<li><p>验证矿工提交的share，并进行验证统计。</p>
</li>
</ol>
<h3 id="4-5-poolbench"><a href="#4-5-poolbench" class="headerlink" title="4.5 poolbench"></a>4.5 poolbench</h3><p>监控其他矿池的状态，如果其他矿池的区块高度有更新，则通知jobmaster开始挖新块。</p>
<h3 id="4-6-mineragent"><a href="#4-6-mineragent" class="headerlink" title="4.6 mineragent"></a>4.6 mineragent</h3><ol>
<li>gateway代理，从gateway接收挖块任务。</li>
<li><p>实现stratum协议，为矿工分配任务。</p>
</li>
<li><p>主要用于矿机数量庞大的矿场，部署在矿场中，可以有效节省带宽，提升性能。</p>
</li>
</ol>
<h3 id="4-7-算力统计"><a href="#4-7-算力统计" class="headerlink" title="4.7 算力统计"></a>4.7 算力统计</h3><p>为统计矿工的算力贡献，矿池会为每个矿工设置难度值，当矿工挖掘的区块达到难度值要求时，就提交一次share，矿池可通过矿工难度测算出矿工的算力。<br>矿池要求矿工大约每4秒提交一次share，那么，如何控制矿工难度来达到该要求呢？</p>
<ol>
<li>新的矿工连接到矿池，矿池会为矿工分配一个默认难度值（1024）。</li>
<li>矿池给矿工下发任务和该难度值，矿工开始挖矿。</li>
<li>矿工挖出区块达到该难度值的要求后，提交share给矿池。</li>
<li>矿池收到后，判断矿工此次提交的share是否有效，有效则记录此次提交的时间间隔，计算此次矿工的工作量与挖矿难度的比例（goal），矿池计算矿工多次提交share的平均时间（avg）后，进行如下判断：<ul>
<li>如果avg大于4s，并且（avg / 4s）大于1.5，则矿工难度值需要<strong>减半</strong>。</li>
<li>如果avg小于4s，并且（avg / 4s）小于0.7，则矿工难度值需要<strong>增加一倍</strong>。</li>
</ul>
</li>
<li>每次有效提交share，矿池会将矿工的<code>难度值</code>、<code>有效提交share次数</code>和 <code>goal</code> 收集起来，每隔60秒将数据提交给metawriter，metawriter会将数据记录到redis，用于计算矿工的收益。</li>
</ol>
<h3 id="4-8-收益结算"><a href="#4-8-收益结算" class="headerlink" title="4.8 收益结算"></a>4.8 收益结算</h3><p>矿池常用的分红规则如下：</p>
<ul>
<li><p><strong>PPS（pay per share）</strong></p>
<p>矿池对矿工提交的每一个工作量证明 (share) 按照理论收益付费，相当于矿工给矿池打工，根据提供的算力稳定获取收益。 由于矿工不承担风险，矿池承担了运气风险和孤块风险，所以收取相对较高的费用。</p>
</li>
<li><p><strong>PPLNS（Pay Per Last N Shares）</strong></p>
<p>矿池每发现有效的区块， 根据过去 N 个难度周期中用户算力占矿池算力的比例进行分配，矿工费也参与分配。 矿池收取相对较少的费用，用于矿池的运营和维护。 这种方式下矿工的收益和矿池的出块相关，矿工收益不稳定，但长期平均收益更高。</p>
</li>
<li><p><strong>PPS+（Pay Per Share Plus）</strong></p>
<p>对传统 PPS 结算方式的一种改进，在传统的 PPS 结算方式基础上，增加了矿工费的分配。 在这种方式下，矿池对矿工提交的每一个工作量证明 (share) 按照理论收益付费，相当于矿工给矿池打工，根据提供的算力稳定获取收益。 由于矿工不承担风险，矿池承担了运气风险和孤块风险，所以收取相对较高的费用。 矿工费另外通过下述的 PPLNS 方式分配给矿工。</p>
</li>
<li><p><strong>SOLO</strong></p>
<p>全部收益分配给挖出该块的矿工，其他矿工不参与分配，矿池收取极少手续费，用于矿池运营和维护。</p>
</li>
</ul>
<p>ViaBTC矿池支持三种结算方式：PPS+、PPLNS和SOLO。默认为PPS+结算方式。</p>
<p><strong>PPS+模式：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>挖矿收益</th>
<th>块奖励</th>
<th>交易费（不固定）</th>
</tr>
</thead>
<tbody>
<tr>
<td>结算方式</td>
<td>PPS</td>
<td>PPLNS</td>
</tr>
<tr>
<td>费率</td>
<td>4%</td>
<td>2%</td>
</tr>
<tr>
<td>计算公式</td>
<td>工作量 / 挖矿难度 <em> 块奖励 </em> (1 - 费率)</td>
<td>用户算力 / 矿池算力 <em> 块收益 </em> (1 - 费率)</td>
</tr>
<tr>
<td>分配规则</td>
<td>每个小时根据当前难度结算一次</td>
<td>区块得到6次确认后，根据过去5个难度周期内用户算力占矿池算力的比例进行分配</td>
</tr>
</tbody>
</table>
</div>
<p><strong>PPLNS 模式：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>挖矿收益</th>
<th>块奖励 + 交易费（不固定）</th>
</tr>
</thead>
<tbody>
<tr>
<td>费率</td>
<td>2%</td>
</tr>
<tr>
<td>计算方式</td>
<td>用户算力／矿池算力 <em> 挖矿收益 </em>（1 - 费率）</td>
</tr>
<tr>
<td>分配规则</td>
<td>区块得到6次确认后，根据过去5个难度周期内用户算力占矿池算力的比例进行分配</td>
</tr>
</tbody>
</table>
</div>
<p><strong>SOLO 模式：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>挖矿收益</th>
<th>块奖励 + 交易费（不固定）</th>
</tr>
</thead>
<tbody>
<tr>
<td>费率</td>
<td>1%</td>
</tr>
</tbody>
</table>
</div>
<p><strong>联合挖矿：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>币</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>BTC</td>
<td>每挖 1 个 BTC 赠送 1 个 NMC</td>
</tr>
<tr>
<td>BTC</td>
<td>每挖 1 个 BTC 赠送 5 个 SYS</td>
</tr>
<tr>
<td>BTC</td>
<td>每挖 1 个 BTC 赠送 0.1 个 EMC</td>
</tr>
<tr>
<td>BTC</td>
<td>每挖 1 个 BTC 赠送 1 个 ELA</td>
</tr>
<tr>
<td>BCH</td>
<td>每挖 1 个 BCH 赠送 1 个 SYS</td>
</tr>
<tr>
<td>LTC</td>
<td>挖 LTC 送 DOGE，按 PPLNS 模式结算</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用 - epoll</title>
    <url>/net/net-io-multiplexing-epoll/</url>
    <content><![CDATA[<p>前面讲了 select 和 poll 的原理，接下来我们学习它们改进后的增强版本：epoll。<br><a id="more"></a></p>
<h2 id="epoll介绍"><a href="#epoll介绍" class="headerlink" title="epoll介绍"></a>epoll介绍</h2><h3 id="epoll相关函数"><a href="#epoll相关函数" class="headerlink" title="epoll相关函数"></a>epoll相关函数</h3><p>在 <code>man</code> 手册中，可以查到 epoll 的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>具体参数详解：</p>
<ul>
<li>epoll_create : 创建 epoll 句柄。<ul>
<li>size : 并没有什么用，但是必须要大于 0，否则创建 epoll 句柄失败。</li>
</ul>
</li>
<li>epoll_ctl : epoll 事件注册函数。<ul>
<li>epfd : 由 epoll_create 创建的 epoll 句柄。</li>
<li>op : fd 的操作类型：<ul>
<li>EPOLL_CTL_ADD : 注册新的 fd 到 epfd 中。</li>
<li>EPOLL_CTL_MOD : 修改已注册的 fd 的监听事件。</li>
<li>EPOLL_CTL_DEL : 从 epfd 中删除一个 fd。</li>
</ul>
</li>
<li>fd : 监听的文件描述符。</li>
<li>event : 要监听的事件，事件属性可以查看下表。</li>
</ul>
</li>
<li>epoll_wait : 等待 epoll 事件的产生。<ul>
<li>epfd : 由 epoll_create 创建的 epoll 句柄。</li>
<li>events : 内核得到的就绪事件集合。</li>
<li>maxevents : 内核events的大小。</li>
<li>timeout : 设定超时时间：<ul>
<li>0 : 立即返回。</li>
<li>-1 : 阻塞。</li>
<li>正数 : 设定超时时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>epoll_event 结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span>   u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span>   u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span>   events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>event 中指定的位掩码的值如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
<th style="text-align:center">是否可作为 epoll_ctl() 的输入</th>
<th style="text-align:center">是否可作为 epoll_wait() 的输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>EPOLLIN</td>
<td>表示对应的文件描述符可读</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>EPOLLOUT</td>
<td>表示对应的文件描述符可写</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>EPOLLRDHUP</td>
<td>Linux 2.6.17 版本后添加的事件，表示对端断开连接</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>EPOLLPRI</td>
<td>表示对应的文件描述符有紧急数据可读（外带数据）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>EPOLLERR</td>
<td>表示对应的文件描述符发生错误</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>EPOLLHUP</td>
<td>表示对应的文件描述符被挂断</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>EPOLLET</td>
<td>采用边缘触发事件通知</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td>EPOLLONESHOT</td>
<td>在完成事件通知之后禁用检查</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
</div>
<p><strong>工作模式：</strong><br>epoll 除了提供 select/poll 那种 IO 事件的水平触发（level-triggered）外，还提供了边缘触发模式（edge-triggered），这就是的用户空间程序有可能缓存 IO 状态，减少 <code>epoll_wait/epoll_pwait</code> 的调用，提高应用程序效率。</p>
<ul>
<li>水平触发（LT） : 默认工作模式，即当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次通知此事件。</li>
<li>边缘触发（ET） : 当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。</li>
</ul>
<p><strong>epoll 工作在 ET 模式的时候，必须使用非阻塞套接字，以避免由于一个文件句柄的阻塞读/写操作把处理多个文件描述符的任务饿死。</strong></p>
<h2 id="epoll使用"><a href="#epoll使用" class="headerlink" title="epoll使用"></a>epoll使用</h2><p>使用流程图如下：<br><img src="https://i.loli.net/2020/10/29/7wIhkVXonSJ6j3g.png" alt="epoll.png"></p>
<p>实现简单的服务代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 10240</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opts = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (opts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl(F_GETFL)\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    opts |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, opts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl(F_SETFL)\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = event;</span><br><span class="line">    ev.data.fd = epollfd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = event;</span><br><span class="line">    ev.data.fd = epollfd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = event;</span><br><span class="line">    ev.data.fd = epollfd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_sockfd, client_sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> client_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立服务器端socket</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_address.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    bind(server_sockfd, (struct sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>); <span class="comment">//监听队列最多容纳5个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epollfd = epoll_create(<span class="number">1</span>);     <span class="comment">//这个参数已经被忽略，但是仍然要大于0</span></span><br><span class="line">    <span class="keyword">if</span> (epollfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create epoll error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_event(epollfd, server_sockfd, EPOLLIN|EPOLLET); <span class="comment">// 设置为边缘触发模式</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取已经准备好的描述符事件</span></span><br><span class="line">        <span class="keyword">int</span> count = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            fd = events[i].data.fd;</span><br><span class="line">            <span class="comment">// 新的客户端连接</span></span><br><span class="line">            <span class="keyword">if</span> ((fd == server_sockfd) &amp;&amp;(events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                client_len = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                <span class="comment">// 接受新的客户端连接</span></span><br><span class="line">                client_sockfd = accept(server_sockfd, (struct sockaddr *)&amp;client_address, (<span class="keyword">socklen_t</span> *)&amp;client_len);</span><br><span class="line">                <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 边缘模式必须要设置为非阻塞模式fd</span></span><br><span class="line">                set_nonblocking(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有可读事件</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> nread;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 边缘触发模式需要讲数据读取完，否则下次不会再通知</span></span><br><span class="line">                <span class="keyword">while</span> ((nread = read(fd, buf + len, BUFSIZ - <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    len += nread;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client %d exit\n&quot;</span>, fd);</span><br><span class="line">                    close(fd);</span><br><span class="line">                    delete_event(epollfd, fd, EPOLLIN);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;recv: %d\n&quot;</span>, errno);</span><br><span class="line">                    close(fd);</span><br><span class="line">                    delete_event(epollfd, fd, EPOLLIN);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="epoll实现原理"><a href="#epoll实现原理" class="headerlink" title="epoll实现原理"></a>epoll实现原理</h3><p>epoll 的源码也在 <code>fs/eventpoll.c</code> 文件中。</p>
<h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create()"></a>epoll_create()</h4><p>系统调用宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) <span class="comment">// 此处已经遗弃 size 参数，只要 size 大于 0 即可</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要调用函数</span></span><br><span class="line">    <span class="keyword">return</span> sys_epoll_create1(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户调用 epoll_create 时，检查完 size 参数后，直接调用了 sys_epoll_create1() 函数来完成主要的工作。<br>sys_epoll_create1() 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the EPOLL_* constant for consistency.  */</span></span><br><span class="line">    <span class="comment">// 检查 EPOLL_* 常量的一致性</span></span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 为 ep 分配内存并初始化，存储在file结构的private_data成员中。</span></span><br><span class="line"><span class="comment">     * private_data成员用来存储文件描述符真正对应的对象。例如</span></span><br><span class="line"><span class="comment">     * 如果文件描述符是一个套接字的话，其对应的file实例的private_data</span></span><br><span class="line"><span class="comment">     * 成员存储的就是一个socket实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = ep_alloc(&amp;ep);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 创建eventpoll文件，这个文件的file_operations为eventpoll_fops，</span></span><br><span class="line"><span class="comment">     * 私有的数据为eventpoll实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = anon_inode_getfd(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                 flags &amp; O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        ep_free(ep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，有一个很重要的结构体 <code>eventpoll</code>，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock; <span class="comment">// 自旋锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq; <span class="comment">// sys_epoll_wait()使用的等待队列</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll_wait; <span class="comment">// file-&gt;poll()使用的等待队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 文件描述符就绪列表，用户调用 epoll_wait 的时候，将 rdllist 中的 epitem 出列，</span></span><br><span class="line"><span class="comment">     * 将触发的事件拷贝到用户空间，之后判断 epitem 是否需要重新添加回 rdllist。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 红黑树根节点，用于存储监听的文件描述符。一个 fd 被添加（EPOLL_CTL_ADD）到 epoll 中之后，</span></span><br><span class="line"><span class="comment">     * 内核会为它生成对应的 epitem 结构对象，epitem 被添加到 rbr 中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span> <span class="comment">// 红黑树，用于存储监听的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 单链表，就绪事件拷贝到用户空间时，将所有 epitem 链接起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 epoll 的用户 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的结构体中可以看出，epoll 底层两个重要的数据结构是 <code>红黑树</code> 和 <code>单链表的就绪队列</code>，其中红黑树用于管理所有监听的 fd，就绪队列用于将产生了事件的 fd 传回给用户。</p>
<p>那么，创建 epoll 完成后，就需要对文件描述符进行监听、删除、修改等操作，这将会使用到 <code>epoll_ctr()</code> 函数。</p>
<h4 id="epoll-ctr"><a href="#epoll-ctr" class="headerlink" title="epoll_ctr()"></a>epoll_ctr()</h4><p>系统调用宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">        struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要从用户空间拷贝 event 参数，如果需要拷贝则调用 copy_from_user 来拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 epoll_create1 创建了 file 实例来存储 eventpoll 并生成了 epfd，此时通过 epfd 来获取</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要操作的文件描述符对应的 file 实例</span></span><br><span class="line">    tfile = fget(fd);</span><br><span class="line">    <span class="keyword">if</span> (!tfile)</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查对应的文件是否支持 poll</span></span><br><span class="line">    error = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 fd 对应的文件是否是一个 eventpoll 文件</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (file == tfile || !is_file_epoll(file))</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面说过，eventpoll 是存储在 private_data 当中的，所以此时取出</span></span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 eventpoll 中存储文件描述符的红黑树中查找 fd 对应的 epitem 实例</span></span><br><span class="line">    epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">        <span class="comment">// 如果要添加的 fd 不存在，则调用 ep_insert 插入到红黑树中</span></span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// 如果存在则返回 EEXIST 错误</span></span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">        <span class="comment">// 如果要删除的 fd 存在，则调用 ep_remove 从红黑树中删除</span></span><br><span class="line">        <span class="keyword">if</span> (epi)</span><br><span class="line">            error = ep_remove(ep, epi);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 如果不存在则返回 ENOENT 错误</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">        <span class="comment">// 如果要修改的 fd 存在，则调用 ep_modify 修改红黑树中对应 fd 的感兴趣的事件</span></span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">    fput(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">error_return:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>epoll_ctl() 函数支持三种操作：添加、删除和修改，这些操作是基于存储文件描述符的红黑树上的，都是对红黑树进行相应的操作。<br>接下来我们看看最重要的函数 <code>epoll_wait()</code>。</p>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait()"></a>epoll_wait()</h4><p>系统调用宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_wait, <span class="keyword">int</span>, epfd, struct epoll_event __user *, events,</span><br><span class="line">        <span class="keyword">int</span>, maxevents, <span class="keyword">int</span>, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 maxevents 参数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证用户空间传入的 events 指向的内存是否可写</span></span><br><span class="line">    <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, events, maxevents * <span class="keyword">sizeof</span>(struct epoll_event))) &#123;</span><br><span class="line">        error = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 epoll_create 中创建的文件</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 fd 对应的文件是否是一个 eventpoll 文件</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(file))</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 private_data 中获取 eventpoll</span></span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要函数</span></span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">error_return:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>epoll_wait 的主要工作在 ep_poll() 函数中完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res, eavail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">long</span> jtimeout;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timeout 是以毫秒为单位</span></span><br><span class="line">    jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We don&#x27;t have any available event to return to the caller.</span></span><br><span class="line"><span class="comment">         * We need to sleep here, and we will be wake up by</span></span><br><span class="line"><span class="comment">         * ep_poll_callback() when events will become available.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">        wait.flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">        <span class="comment">// 将当前进程加入到 eventpoll 的等待队列中，等待文件状态就绪或者超时或者被信号中断</span></span><br><span class="line">        __add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * We don&#x27;t want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment">             * a wakeup in between. That&#x27;s why we set the task state</span></span><br><span class="line"><span class="comment">             * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">            <span class="comment">// 如果就绪队列不为空，也就是说已经有文件的状态就绪或者超时，则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果当前进程收到信号，则退出循环，返回 EINTR</span></span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 等待 ep_poll_callback() 将当前进程唤醒或者超时，返回值是剩余的时间。</span></span><br><span class="line"><span class="comment">             * 从这里开始进程会进入睡眠状态，让出处理器，直到某些文件的状态就绪或者超时。</span></span><br><span class="line"><span class="comment">             * 当文件状态就绪时，eventpoll 的回调函数 ep_poll_callback() 会唤醒</span></span><br><span class="line"><span class="comment">             * 在 ep-&gt;wq 指向的等待队列中的进程。</span></span><br><span class="line"><span class="comment">             * （ep_poll_callback() 回调函数在 ep_insert() 时注册）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ep-&gt;ovflist 链表存储的向用户传递事件时暂存就绪的文件。</span></span><br><span class="line"><span class="comment">     * 所以不管是就绪队列 ep-&gt;rdllist 不为空，或者 ep-&gt;ovflist 不等于</span></span><br><span class="line"><span class="comment">     * EP_UNACTIVE_PTR，都有可能现在已经有文件的状态就绪。</span></span><br><span class="line"><span class="comment">     * ep-&gt;ovflist 不等于 EP_UNACTIVE_PTR 有两种情况，一种是 NULL，此时</span></span><br><span class="line"><span class="comment">     * 可能正在向用户传递事件，不一定就有文件状态就绪，</span></span><br><span class="line"><span class="comment">     * 一种情况时不为 NULL，此时可以肯定有文件状态就绪，</span></span><br><span class="line"><span class="comment">     * 参见 ep_send_events()。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    eavail = !list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果没有被信号中断，并且有事件就绪，</span></span><br><span class="line"><span class="comment">     * 但是没有获取到事件(有可能被其他进程获取到了)，</span></span><br><span class="line"><span class="comment">     * 并且没有超时，则跳转到retry标签处，重新等待</span></span><br><span class="line"><span class="comment">     * 文件状态就绪。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回获取到的事件的个数或者错误码</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ep_poll() 如果有事件发生，则调用 <code>ep_send_events()/ep_scan_ready_list()</code> 将发生的事件拷贝到用户空间中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">              struct epoll_event __user *events, <span class="keyword">int</span> maxevents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> <span class="title">esed</span>;</span></span><br><span class="line"></span><br><span class="line">    esed.maxevents = maxevents;</span><br><span class="line">    esed.events = events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*sproc)(struct eventpoll *,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">    LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="comment">     * eventpoll_release_file() and epoll_ctl().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// 将就绪队列中就绪的文件链表暂存在临时表头 txlist 中，并且初始化就绪队列。</span></span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * 将 ovflist 置为 NULL，表示此时正在向用户空间传递</span></span><br><span class="line"><span class="comment">     * 事件。如果此时有文件状态就绪，不会放在</span></span><br><span class="line"><span class="comment">     * 就绪队列中，而是放在 ovflist 链表中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ep-&gt;ovflist = <span class="literal">NULL</span>;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 sproc 指向的函数 ep_send_events_proc() 将就绪队列中的事件存入用户传入的内存中。</span></span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在调用 ep_send_events_proc() 的过程中，可能有文件状态就绪，这些事件</span></span><br><span class="line"><span class="comment">     * 会暂存在 ovflist 链表中，所以这里要将 ovflist 中的事件移到就绪队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (nepi = ep-&gt;ovflist; (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">        nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新初始化 ovflist，表示传递事件已完成</span></span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 ep_send_events_proc() 中处理出错或者某些文件的触发方式设置为 LT，</span></span><br><span class="line"><span class="comment">     * txlist 中可能还有事件，需要将这些就绪的事件重新添加到 eventpoll 的就绪度列中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对轮询等待队列执行安全唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> *<span class="title">esed</span> = <span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> eventcnt;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> revents;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">uevent</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (eventcnt = <span class="number">0</span>, uevent = esed-&gt;events;</span><br><span class="line">         !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) &#123;</span><br><span class="line">        epi = list_first_entry(head, struct epitem, rdllink);</span><br><span class="line"></span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 调用文件的poll函数有两个作用，一是在文件的唤醒</span></span><br><span class="line"><span class="comment">         * 队列上注册回调函数，二是返回文件当前的事件状</span></span><br><span class="line"><span class="comment">         * 态，如果第二个参数为NULL，则只是查看文件当前</span></span><br><span class="line"><span class="comment">         * 状态。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="literal">NULL</span>) &amp;</span><br><span class="line">            epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (revents) &#123;</span><br><span class="line">            <span class="comment">// 向用户空间内存传值，如果失败，将当前的 epitem 实例重新放回到链表中。</span></span><br><span class="line">            <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">                __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">                list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">                <span class="comment">// 如果此时已经获取了部分事件，则返回已经获取的事件个数，否则返回 EFAULT</span></span><br><span class="line">                <span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">            eventcnt++;</span><br><span class="line">            uevent++;</span><br><span class="line">            <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果是水平触发模式，需要将当前的 epitem 实例添加回链表中，</span></span><br><span class="line"><span class="comment">             * 下次读取事件时会再次上报</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line"></span><br><span class="line">                list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eventcnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>I/O多路复用</tag>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title>select/poll/epoll之间的区别</title>
    <url>/net/net-io-multiplexing/</url>
    <content><![CDATA[<p>前面介绍了 <a href="../net-io-multiplexing-select">《IO多路复用 - select》</a>、<a href="../net-io-multiplexing-poll">《IO多路复用 - poll》</a>和<a href="../net-io-multiplexing-epoll">《IO多路复用 - epoll》</a>，那么这三者之间有什么优缺点呢？下面我们来看看</p>
<a id="more"></a>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>优点：</p>
<ul>
<li>select 遵循 POSIX 的规范，支持跨平台，具有良好的兼容性，可以在不同操作系统上使用 select 实现高性能服务器。</li>
</ul>
<p>缺点：</p>
<ul>
<li>单个进程能打开的最大连接数有限制，只能打开最大为 FD_SETSIZE 宏定义大小的连接数。</li>
<li>当有新的连接时，每次都需要将所有的 fd 集合从用户空间拷贝到内核空间，开销大。</li>
<li>当有新的 IO 事件发生时，每次都需要将所有的 fd 集合从内核空间拷贝到用户空间，开销大。</li>
<li>需要轮询遍历所有 fd 集合，才能知道哪些 fd 就绪，时间复杂度为 O(N)。</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>优点：</p>
<ul>
<li>相较于 select，poll 是基于链表来存储 fd 集合的，所以并不会像 select 那样存在最大的连接数限制（受服务器资源限制）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>非跨平台，只能在 Unix/Linux 操作系统上开发。</li>
<li>同 select 一样，都会有大量的 fd 集合被整体复制于用户空间和内核空间之间，开销大。</li>
<li>IO 效率与 select 一样，都需要轮询遍历所有 fd 集合，才能知道哪些 fd 就绪，时间复杂度为 O(N)。</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>优点：</p>
<ul>
<li>理论上同样不存在最大连接数限制（受服务器资源限制）。</li>
<li>效率提升，只有活跃的 fd 才会主动调用 callback 回调函数，时间复杂度为 O(1)。</li>
<li>底层由红黑树来管理 fd 集合，通过就绪队列链表将就绪的 fds 拷贝到用户空间，而不需要将所有 fd 集合全部拷贝，省去了不必要的内存拷贝。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>epoll 对 select/poll 的缺点进行了改进。在 select/poll 中，进程只有在调用一定的方法后，内核才对所有监视的 fd 集合进行扫描，而 epoll 事先通过 epoll_ctl 来注册一个 fd，一旦某个 fd 就绪时，内核会采用 callback 的回调机制，迅速激活这个 fd，当进程调用 epoll_wait 时便能得到通知。<br>在高并发的场景下 epoll 一切都很好，是 Linux 目前大规模网络并发程序开发的首选模型。但是因为 epoll 底层的回调机制，在低并发、高活跃 fd 的场景下，select/poll 并不会比 epoll 差，可能性能会更高。</p>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>I/O多路复用</tag>
        <tag>epoll</tag>
        <tag>select</tag>
        <tag>poll</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用 - select</title>
    <url>/net/net-io-multiplexing-select/</url>
    <content><![CDATA[<p>在服务器的编程中经常会需要构造高性能的 I/O 模型，最常用的就是多路复用 I/O 模型。<br>多路复用的本质是同步非阻塞 I/O，多路复用的优势并不是单个连接处理的更快，而是在于能处理更多的链接。<br><a id="more"></a><br>在服务端的网络 I/O 编程过程中，需要同时处理多个客户端的数据时，可以利用多线程或者 I/O 多路复用技术进行处理。<br>在<a href="../net-io-model">《I/O模型浅析》</a>中已经简单介绍过多路复用I/O，接下来介绍 select、poll 和 epoll。<br>这三者的源码在 Linux kernel 源码中，想要查看源码需要下载，两种下载方式：</p>
<ol>
<li>官方链接： <a href="https://www.kernel.org/">https://www.kernel.org/</a></li>
<li>如果不能科学上网，下载速度将会很慢，可以使用上海交大的源下载：<br><a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/">http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/</a></li>
</ol>
<p><img src="https://i.loli.net/2020/10/29/PFJYs8yI6VMlaBv.png" alt="kernel.png"><br>因为我使用的系统是 <code>CentOS release 6.8 (Final)</code>，其中 linux 内核版本为 <code>2.6.32</code>，所以我下载了 <code>linux-2.6.32.9.tar.gz</code>。<br>其它版本可自行选择下载。</p>
<hr>
<h2 id="select介绍"><a href="#select介绍" class="headerlink" title="select介绍"></a>select介绍</h2><h3 id="select相关函数"><a href="#select相关函数" class="headerlink" title="select相关函数"></a>select相关函数</h3><p>通过 <code>man select</code> 命令可以查看 select 的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要包含的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>具体参数详解：</p>
<ul>
<li>nfds: 整数值，指集合中所有文件描述符的范围，即所有文件描述符的最大值加1。</li>
<li>readfds: 指向 fd_set 结构的指针，文件描述符集合，检查该组文件描述符的可读性。</li>
<li>writefds: 指向 fd_set 结构的指针，文件描述符集合，检查该组文件描述符的可写性。</li>
<li>exceptfds: 指向 fd_set 结构的指针，文件描述符集合，检查该组文件描述符的异常条件。</li>
<li>timeout: 设定 select 的超时时间，其中：<ul>
<li>值为NULL，则将 select() 设置为阻塞状态，当监视的文件描述符集合中的某一个描述符发生变化才会返回结果并向下执行。</li>
<li>值等于0，则将 select() 置为非阻塞状态，执行 select() 后立即返回，无论文件描述符是否发生变化。</li>
<li>值大于0，则将select()函数的超时时间设为这个值，在超时时间内阻塞，超时后返回结果。</li>
</ul>
</li>
</ul>
<p>函数返回：</p>
<ul>
<li>正数：表示发生变化的文件描述符数量。</li>
<li>0：select 超时。</li>
<li>-1：发生错误，将所有文件描述符集合清0，并通过 errno 输出错误详情。</li>
</ul>
<p>以下是与 select() 函数相关的几个宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//一个 fd_set类型变量的所有位都设为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">//清除某个位时可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//设置变量的某个位置位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">//测试某个位是否被置位</span></span><br></pre></td></tr></table></figure>
<h3 id="select使用"><a href="#select使用" class="headerlink" title="select使用"></a>select使用</h3><p>使用流程图如下：<br><img src="https://i.loli.net/2020/10/29/7RFfJjZzT3sKSWh.png" alt="select.png"></p>
<p>实现简单的服务代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_sockfd, client_sockfd;</span><br><span class="line">    <span class="keyword">int</span> server_len, client_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    fd_set readfds, testfds;</span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立服务器端socket</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_address.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    server_len = <span class="keyword">sizeof</span>(server_address);</span><br><span class="line">    bind(server_sockfd, (struct sockaddr *)&amp;server_address, server_len);</span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>); <span class="comment">//监听队列最多容纳5个</span></span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_SET(server_sockfd, &amp;readfds);<span class="comment">//将服务器端socket加入到集合中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">int</span> nread;</span><br><span class="line">        testfds = readfds;<span class="comment">//将需要监视的描述符集copy到select查询队列中，select会对其修改，所以一定要分开使用变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server waiting\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*无限期阻塞，并测试文件描述符变动 */</span></span><br><span class="line">        result = select(FD_SETSIZE, &amp;testfds, (fd_set *)<span class="number">0</span>,(fd_set *)<span class="number">0</span>, (struct timeval *) <span class="number">0</span>); <span class="comment">//FD_SETSIZE：系统默认的最大文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(result &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;server5&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*扫描所有的文件描述符*/</span></span><br><span class="line">        <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; FD_SETSIZE; fd++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*找到相关文件描述符*/</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(fd,&amp;testfds))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*判断是否为服务器套接字，是则表示为客户请求连接。*/</span></span><br><span class="line">                <span class="keyword">if</span>(fd == server_sockfd)</span><br><span class="line">                &#123;</span><br><span class="line">                    client_len = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                    client_sockfd = accept(server_sockfd, (struct sockaddr *)&amp;client_address, (<span class="keyword">socklen_t</span> *)&amp;client_len);</span><br><span class="line">                    FD_SET(client_sockfd, &amp;readfds);<span class="comment">//将客户端socket加入到集合中</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;adding client on fd %d\n&quot;</span>, client_sockfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*客户端socket中有数据请求时*/</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ioctl(fd, FIONREAD, &amp;nread);<span class="comment">//取得数据量交给nread</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*客户数据请求完毕，关闭套接字，从集合中清除相应描述符 */</span></span><br><span class="line">                    <span class="keyword">if</span>(nread == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        close(fd);</span><br><span class="line">                        FD_CLR(fd, &amp;readfds); <span class="comment">//去掉关闭的fd</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;removing client on fd %d\n&quot;</span>, fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*处理客户数据请求*/</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        read(fd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">                        sleep(<span class="number">5</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;serving client on fd %d\n&quot;</span>, fd);</span><br><span class="line">                        ch++;</span><br><span class="line">                        write(fd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="select实现原理"><a href="#select实现原理" class="headerlink" title="select实现原理"></a>select实现原理</h3><p>select 的源码在 <code>fs/select.c</code> 文件中。<br>Linux 中的系统函数调用入口都是由宏 <code>SYSCALL_DEFINEx</code> 定义的，其中 <code>x</code> 为函数参数个数。在 <code>select.c</code> 中可以找到 select() 的系统调用宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">        fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否设置超时时间</span></span><br><span class="line">    <span class="keyword">if</span> (tvp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv))) <span class="comment">// 从用户空间拷贝数据到内核空间</span></span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        <span class="keyword">if</span> (poll_select_set_timeout(to,</span><br><span class="line">                tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</span><br><span class="line">                (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to); <span class="comment">// 主要函数</span></span><br><span class="line">    ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret); <span class="comment">// 如果有超时值, 并拷贝离超时时刻还剩的时间到用户空间的timeval中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要处理函数在 core_sys_select() 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">               fd_set __user *<span class="built_in">exp</span>, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set_bits fds; <span class="comment">// fd_set_bits结构体中定义的全是指针，这些指针是用来指向描述符集合的</span></span><br><span class="line">    <span class="keyword">void</span> *bits;</span><br><span class="line">    <span class="keyword">int</span> ret, max_fds;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="comment">/* Allocate small arguments on the stack to save memory and be faster */</span></span><br><span class="line">    <span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    fdt = files_fdtable(current-&gt;files); <span class="comment">// 获取当前进程的文件描述符表</span></span><br><span class="line">    max_fds = fdt-&gt;max_fds;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; max_fds) <span class="comment">// 如果传入的n大于当前进程最大的文件描述符，给予修正</span></span><br><span class="line">        n = max_fds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span></span><br><span class="line"><span class="comment">     * since we used fdset we need to allocate memory in units of</span></span><br><span class="line"><span class="comment">     * long-words.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size = FDS_BYTES(n);</span><br><span class="line">    <span class="comment">// 以一个文件描述符占一bit来计算，传递进来的这些fd_set需要用掉多少个字</span></span><br><span class="line">    bits = stack_fds;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="comment">// 除6，为什么？因为每个文件描述符需要6个bitmaps</span></span><br><span class="line">        <span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL); <span class="comment">// stack中分配的太小，直接kmalloc</span></span><br><span class="line">        <span class="keyword">if</span> (!bits)</span><br><span class="line">            <span class="keyword">goto</span> out_nofds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里就可以明显看出struct fd_set_bits结构体的用处了。</span></span><br><span class="line">    fds.in      = bits;</span><br><span class="line">    fds.out     = bits +   size;</span><br><span class="line">    fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">    fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">    fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">    fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get_fd_set仅仅调用copy_from_user从用户空间拷贝了fd_se</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">        (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">        (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    zero_fd_set(n, fds.res_in); <span class="comment">// 对这些存放返回状态的字段清0</span></span><br><span class="line">    zero_fd_set(n, fds.res_out);</span><br><span class="line">    zero_fd_set(n, fds.res_ex);</span><br><span class="line"></span><br><span class="line">    ret = do_select(n, &amp;fds, end_time); <span class="comment">// 关键函数，完成主要的工作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="comment">// 有错误</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123; <span class="comment">// 超时返回，无设备就绪</span></span><br><span class="line">        ret = -ERESTARTNOHAND;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把结果集,拷贝回用户空间</span></span><br><span class="line">    <span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">        set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">        set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">        kfree(bits); <span class="comment">// 如果有申请空间，那么释放fds对应的空间</span></span><br><span class="line">out_nofds:</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是主角 <code>do_select()</code> 登场：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    poll_table *wait;</span><br><span class="line">    <span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">// 根据已经设置好的fd bitmap检查用户打开的fd, 要求对应fd必须打开, 并且返回最大的fd</span></span><br><span class="line">    retval = max_select_fd(n, fds);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    n = retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些重要的初始化:</span></span><br><span class="line">    <span class="comment">// poll_wqueues.poll_table.qproc函数指针初始化，该函数是驱动程序中poll函数实现中必须要调用的poll_wait()中使用的函数</span></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    wait = &amp;table.pt;</span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        wait = <span class="literal">NULL</span>;</span><br><span class="line">        timed_out = <span class="number">1</span>;  <span class="comment">// 如果系统调用带进来的超时时间为0，那么设置timed_out = 1，表示不阻塞，直接返回。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">        slack = estimate_accuracy(end_time); <span class="comment">// 超时时间转换</span></span><br><span class="line"></span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">        inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有n个fd的循环</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先取出当前循环周期中的32个文件描述符对应的bitmaps</span></span><br><span class="line">            in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">            all_bits = in | out | ex;  <span class="comment">// 组合一下，有的fd可能只监测读，或者写，或者err，或者同时都监测</span></span><br><span class="line">            <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123; <span class="comment">// 这32个描述符没有任何状态被监测，就跳入下一个32个fd的循环中</span></span><br><span class="line">                i += __NFDBITS; <span class="comment">//每32个文件描述符一个循环，正好一个long型数</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本次32个fd的循环中有需要监测的状态存在</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123; <span class="comment">// 初始bit = 1</span></span><br><span class="line">                <span class="keyword">int</span> fput_needed;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n) <span class="comment">// i用来检测是否超出了最大待监测的fd</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// bit每次循环后左移一位的作用在这里，用来跳过没有状态监测的fd</span></span><br><span class="line">                file = fget_light(i, &amp;fput_needed); <span class="comment">// 得到file结构指针，并增加引用计数字段f_count</span></span><br><span class="line">                <span class="keyword">if</span> (file) &#123; <span class="comment">// 如果file存在</span></span><br><span class="line">                    f_op = file-&gt;f_op;</span><br><span class="line">                    mask = DEFAULT_POLLMASK;</span><br><span class="line">                    <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;</span><br><span class="line">                        wait_key_set(wait, in, out, bit); <span class="comment">// 设置当前fd待监测的事件掩码</span></span><br><span class="line">                        mask = (*f_op-&gt;poll)(file, wait);</span><br><span class="line">                         <span class="comment">/* 调用驱动程序中的poll函数，以evdev驱动中的evdev_poll()为例该函数会调用函数poll_wait(file, &amp;evdev-&gt;wait, wait)，</span></span><br><span class="line"><span class="comment">                         继续调用__pollwait()回调来分配一个poll_table_entry结构体，该结构体有一个内嵌的等待队列项，</span></span><br><span class="line"><span class="comment">                         设置好wake时调用的回调函数后将其添加到驱动程序中的等待队列头中。*/</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    fput_light(file, fput_needed);</span><br><span class="line">                    <span class="comment">// 释放file结构指针，实际就是减小他的一个引用计数字段f_count。</span></span><br><span class="line">                    <span class="comment">// mask是每一个fop-&gt;poll()程序返回的设备状态掩码。</span></span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">                        res_in |= bit; <span class="comment">// fd对应的设备可读</span></span><br><span class="line">                        retval++;</span><br><span class="line">                        wait = <span class="literal">NULL</span>; <span class="comment">// 后续有用，避免重复执行__pollwait()</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">                        res_out |= bit; <span class="comment">// fd对应的设备可写</span></span><br><span class="line">                        retval++;</span><br><span class="line">                        wait = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">                        res_ex |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据poll的结果写回到输出位图里,返回给上级函数</span></span><br><span class="line">            <span class="keyword">if</span> (res_in)</span><br><span class="line">                *rinp = res_in;</span><br><span class="line">            <span class="keyword">if</span> (res_out)</span><br><span class="line">                *routp = res_out;</span><br><span class="line">            <span class="keyword">if</span> (res_ex)</span><br><span class="line">                *rexp = res_ex;</span><br><span class="line">             <span class="comment">// 这里的目的纯粹是为了增加一个抢占点。在支持抢占式调度的内核中（定义了CONFIG_PREEMPT），cond_resched是空操作。</span></span><br><span class="line">            cond_resched();</span><br><span class="line">        &#125;</span><br><span class="line">        wait = <span class="literal">NULL</span>; <span class="comment">// 后续有用，避免重复执行__pollwait()</span></span><br><span class="line">        <span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (table.error) &#123;</span><br><span class="line">            retval = table.error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳出这个大循环的条件有: 有设备就绪或有异常(retval!=0), 超时(timed_out = 1), 或者有中止信号出现</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">         * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">         * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次循环中，当前用户进程从这里进入休眠，上面传下来的超时时间只是为了用在睡眠超时这里而已超时，poll_schedule_timeout()返回0；被唤醒时返回-EINTR</span></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">                       to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>; <span class="comment">/* 超时后，将其设置成1，方便后面退出循环返回到上层 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理各个驱动程序的等待队列头，同时释放掉所有空出来的page页(poll_table_entry)</span></span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval; <span class="comment">// 返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select 使用 bitmap 的方式来传递文件描述符集合，所以就会有最大长度限制，在 Linux 平台下 select 限制文件描述符只能有 <code>1024</code> 个，如果需要超过 1024，就需要修改内核代码并重新编译。<br>select 使用 bitmap 的方式来回传就绪的文件描述符集合，调用者需要循环遍历每一个位判断是否就绪。当文件描述符很多，但是空闲的文件描述符大大多于就绪的文件描述符的时候，效率就很低了，所以一般不建议修改文件描述符的限制数量。<br>在 <code>include/linux/posix_types.h</code> 中可以看到宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __FD_SETSIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE    1024</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>I/O多路复用</tag>
        <tag>select</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用 - poll</title>
    <url>/net/net-io-multiplexing-poll/</url>
    <content><![CDATA[<p>上一篇<a href="../net-io-multiplexing-select">《IO多路复用 - select》</a>介绍了 select。接下来我们来解析一下 poll。<br><a id="more"></a></p>
<h2 id="poll介绍"><a href="#poll介绍" class="headerlink" title="poll介绍"></a>poll介绍</h2><h3 id="poll相关函数"><a href="#poll相关函数" class="headerlink" title="poll相关函数"></a>poll相关函数</h3><p>通过 <code>man poll</code> 命令可以查看 poll 的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>具体参数详解：</p>
<ul>
<li>fds: 指向 pollfd 结构体数组的指针。</li>
<li>nfds: 表示 fds 结构体数组的长度。</li>
<li>timeout: 设定 poll 的超时时间，单位为毫秒，其中：<ul>
<li>值为 -1 ：poll 永远阻塞。</li>
<li>值为 0 ：poll 立即返回。</li>
<li>值为正数： 设定超时时间。</li>
</ul>
</li>
</ul>
<p>函数返回：</p>
<ul>
<li>返回值大于 0 ：表示poll由于监听的文件描述符就绪返回，并且返回结果就是就绪的文件描述符的个数。</li>
<li>返回值等于 0 ：poll 超时。</li>
<li>返回值小于 0 ：发生错误。</li>
</ul>
<p>pollfd 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;        <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;  <span class="comment">// 等待的事件（POLLIN/POLLOUT/POLLERR）</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">// 实际发生的事件，不需赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>events &amp; revents 取值如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
<th style="text-align:center">是否可作为输入(events)</th>
<th style="text-align:center">是否可作为输出(revents)</th>
</tr>
</thead>
<tbody>
<tr>
<td>POLLIN</td>
<td>数据可读（包括普通数据&amp;优先数据）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>数据可写（普通数据&amp;优先数据）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td>普通数据可读</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td>优先级带数据可读（linux不支持）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>高优先级数据可读，比如TCP带外数据</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POLLWRNORM</td>
<td>普通数据可写</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td>优先级带数据可写</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POLLRDHUP</td>
<td>TCP连接被对端关闭，或者关闭了写操作，由GNU引入</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POPPHUP</td>
<td>挂起</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POLLERR</td>
<td>错误</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td>文件描述符没有打开</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意：</strong><br>pollfd 结构体中的 events 由用户来设置，告诉内核我们关注的事件，而 revents 是返回时内核设置的，以说明文件描述符发生了什么事件。</p>
<h3 id="poll使用"><a href="#poll使用" class="headerlink" title="poll使用"></a>poll使用</h3><p>使用流程图如下：<br><img src="https://i.loli.net/2020/10/29/kMKpA9uj2yLmcvi.png" alt="poll.png"></p>
<p>实现简单的服务代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 10240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> server_sockfd, client_sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> client_len = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">clients</span>[<span class="title">CLIENT_SIZE</span>];</span></span><br><span class="line">    <span class="keyword">int</span> conn_count = <span class="number">0</span>; <span class="comment">// 当前客户端连接数</span></span><br><span class="line"></span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立服务器端socket</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_address.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    bind(server_sockfd, (struct sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>); <span class="comment">//监听队列最多容纳5个</span></span><br><span class="line"></span><br><span class="line">    clients[<span class="number">0</span>].fd = server_sockfd;</span><br><span class="line">    clients[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有客户端</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; CLIENT_SIZE; ++i) &#123;</span><br><span class="line">        clients[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server start\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = poll(clients, conn_count + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; conn_count + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 客户端关闭或者其他错误</span></span><br><span class="line">            <span class="keyword">if</span> ((clients[i].revents &amp; POLLRDHUP) || (clients[i].revents &amp; POLLERR)) &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = clients[i].fd;</span><br><span class="line">                clients[i] = clients[conn_count];</span><br><span class="line">                --i;</span><br><span class="line">                --conn_count;</span><br><span class="line">                close(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新的客户端连接</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((clients[i].fd == server_sockfd) &amp;&amp; (clients[i].revents &amp; POLLIN)) &#123;</span><br><span class="line">                client_len = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                <span class="comment">// 接受新的客户端连接</span></span><br><span class="line">                client_sockfd = accept(server_sockfd, (struct sockaddr *)&amp;client_address, (<span class="keyword">socklen_t</span> *)&amp;client_len);</span><br><span class="line">                <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++conn_count;</span><br><span class="line">                clients[conn_count].fd = client_sockfd;</span><br><span class="line">                clients[conn_count].events = POLLIN | POLLERR;</span><br><span class="line">                clients[conn_count].revents = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有可读数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (clients[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> len = recv(clients[i].fd, buf, BUF_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client %d exit\n&quot;</span>, clients[i].fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;recv: %d\n&quot;</span>, errno);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="poll实现原理"><a href="#poll实现原理" class="headerlink" title="poll实现原理"></a>poll实现原理</h3><p>poll 的源码也在 <code>fs/select.c</code> 文件中。<br>poll() 的系统调用宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds,</span><br><span class="line">        <span class="keyword">long</span>, timeout_msecs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        <span class="comment">// 设定超时时间</span></span><br><span class="line">        poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,</span><br><span class="line">            NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要函数</span></span><br><span class="line">    ret = do_sys_poll(ufds, nfds, to);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == -EINTR) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart_block</span>;</span></span><br><span class="line"></span><br><span class="line">        restart_block = &amp;current_thread_info()-&gt;restart_block;</span><br><span class="line">        restart_block-&gt;fn = do_restart_poll;</span><br><span class="line">        restart_block-&gt;poll.ufds = ufds;</span><br><span class="line">        restart_block-&gt;poll.nfds = nfds;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            restart_block-&gt;poll.tv_sec = end_time.tv_sec;</span><br><span class="line">            restart_block-&gt;poll.tv_nsec = end_time.tv_nsec;</span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ret = -ERESTART_RESTARTBLOCK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要处理函数在 do_sys_poll() 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sys_poll</span><span class="params">(struct pollfd __user *ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err = -EFAULT, fdcount, len, size;</span><br><span class="line">    <span class="comment">/* Allocate small arguments on the stack to save memory and be</span></span><br><span class="line"><span class="comment">       faster - use long to make sure the buffer is aligned properly</span></span><br><span class="line"><span class="comment">       on 64 bit archs to avoid unaligned access */</span></span><br><span class="line">    <span class="comment">/* 为了加快处理速度和提高系统性能，这里优先定义好一个大小为POLL_STACK_ALLOC的栈空间，</span></span><br><span class="line"><span class="comment">       该栈空间转换为poll_list结构体，以存储需要被检测的socket描述符 */</span></span><br><span class="line">    <span class="keyword">long</span> stack_pps[POLL_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">const</span> <span class="title">head</span> = (<span class="title">struct</span> <span class="title">poll_list</span> *)<span class="title">stack_pps</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> todo = nfds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nfds &gt; current-&gt;signal-&gt;rlim[RLIMIT_NOFILE].rlim_cur)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过计算得到前面分配的栈空间能存储多少个pollfd结构</span></span><br><span class="line">    len = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds, N_STACK_PPS);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        walk-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        walk-&gt;len = len;</span><br><span class="line">        <span class="keyword">if</span> (!len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从用户态空间复制len个pollfd拷贝到内核空间中</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct pollfd) * walk-&gt;len))</span><br><span class="line">            <span class="keyword">goto</span> out_fds;</span><br><span class="line"></span><br><span class="line">        todo -= walk-&gt;len;</span><br><span class="line">        <span class="keyword">if</span> (!todo)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* POLLFD_PER_PAGE表示一页能存储多少个pollfd，可以计算出来，一页是4K，</span></span><br><span class="line"><span class="comment">           而pollfd的大小为8个字节，也就是一页能存储512个pollfd。</span></span><br><span class="line"><span class="comment">           如果在分配一页内存之后，还不够nfds使用，则继续下一个循环进行分配 */</span></span><br><span class="line">        len = min(todo, POLLFD_PER_PAGE);</span><br><span class="line">        size = <span class="keyword">sizeof</span>(struct poll_list) + <span class="keyword">sizeof</span>(struct pollfd) * len;</span><br><span class="line">        walk = walk-&gt;next = kmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!walk) &#123;</span><br><span class="line">            err = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> out_fds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    <span class="comment">// 最重要的处理部分</span></span><br><span class="line">    fdcount = do_poll(nfds, head, &amp;table, end_time);</span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表上的所有pollfd中revents状态写入到用户空间</span></span><br><span class="line">    <span class="keyword">for</span> (walk = head; walk; walk = walk-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">fds</span> = <span class="title">walk</span>-&gt;<span class="title">entries</span>;</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; walk-&gt;len; j++, ufds++)</span><br><span class="line">            <span class="keyword">if</span> (__put_user(fds[j].revents, &amp;ufds-&gt;revents))</span><br><span class="line">                <span class="keyword">goto</span> out_fds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = fdcount;</span><br><span class="line">out_fds:</span><br><span class="line">    <span class="comment">// 之前调用kmalloc分配的内存现在进行释放</span></span><br><span class="line">    walk = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (walk) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">pos</span> = <span class="title">walk</span>;</span></span><br><span class="line">        walk = walk-&gt;next;</span><br><span class="line">        kfree(pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是重中之重的 do_poll() 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_poll</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,  struct poll_list *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">           struct poll_wqueues *wait, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poll_table* pt = &amp;wait-&gt;pt;</span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> timed_out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimise the no-wait case */</span></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        pt = <span class="literal">NULL</span>;</span><br><span class="line">        timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">        slack = estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对所有的struct pollfd循环，以调用do_pollfd函数。</span></span><br><span class="line">        <span class="keyword">for</span> (walk = <span class="built_in">list</span>; walk != <span class="literal">NULL</span>; walk = walk-&gt;next) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> * <span class="title">pfd</span>, * <span class="title">pfd_end</span>;</span></span><br><span class="line"></span><br><span class="line">            pfd = walk-&gt;entries;</span><br><span class="line">            pfd_end = pfd + walk-&gt;len;</span><br><span class="line">            <span class="keyword">for</span> (; pfd != pfd_end; pfd++) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Fish for events. If we found one, record it</span></span><br><span class="line"><span class="comment">                 * and kill the poll_table, so we don&#x27;t</span></span><br><span class="line"><span class="comment">                 * needlessly register any other waiters after</span></span><br><span class="line"><span class="comment">                 * this. They&#x27;ll get immediately deregistered</span></span><br><span class="line"><span class="comment">                 * when we break out and return.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 调用 do_pollfd() 以检查socket文件描述符的状态变化，如果有变化，则count加1</span></span><br><span class="line">                <span class="keyword">if</span> (do_pollfd(pfd, pt)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    pt = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * All waiters have already been registered, so don&#x27;t provide</span></span><br><span class="line"><span class="comment">         * a poll_table to them on the next loop iteration.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pt = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">            count = wait-&gt;error;</span><br><span class="line">            <span class="comment">/* 检查是否有需要处理的信号，这里的意思是就算是poll调用进入到sys_poll系统调用之后，</span></span><br><span class="line"><span class="comment">             * 也可以接收外部信号，从而退出当前系统调用（因为我们知道一般的系统调用都不会被中断的，</span></span><br><span class="line"><span class="comment">             * 所以系统调用一般都尽量很快的返回）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">                count = -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for循环退出的条件：如果有文件描述符发生变化，则退出，或者超时退出</span></span><br><span class="line">        <span class="keyword">if</span> (count || timed_out)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">         * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">         * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>I/O多路复用</tag>
        <tag>poll</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-双端链表adlist</title>
    <url>/Redis/1-data-structure/redis-parse-adlist/</url>
    <content><![CDATA[<p>源码位置：adlist.c/adlist.h  </p>
<p>很好理解的双端链表，结构如下，不多做解释了。<br><a id="more"></a><br><img src="https://i.loli.net/2020/10/29/EwAUNjpFr6Px59Q.png" alt="adlist.png"></p>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前置结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后置结点</span></span><br><span class="line">    <span class="keyword">void</span> *value; <span class="comment">// 数据</span></span><br><span class="line">&#125; listNode;</span><br><span class="line"><span class="comment">// 链表迭代器定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction; <span class="comment">// 方向参数，正序和逆序</span></span><br><span class="line">&#125; listIter;</span><br><span class="line"><span class="comment">// 链表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head; <span class="comment">// 链表的头部结点</span></span><br><span class="line">    listNode *tail; <span class="comment">// 链表的尾部结点</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr); <span class="comment">// 拷贝函数的函数指针，由使用者来实现其功能</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr); <span class="comment">// 释放函数的函数指针，由使用者来实现其功能</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 匹配函数的函数指针，由使用者来实现其功能</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">// 链表大小（结点个数）</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len) <span class="comment">// 获取链表长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head) <span class="comment">// 获取链表头结点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail) <span class="comment">// 获取链表尾结点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev) <span class="comment">// 获取当前结点的前置结点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next) <span class="comment">// 获取当前结点的后置结点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value) <span class="comment">// 获取当前结点的value</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m)) <span class="comment">// 设定链表的复制函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m)) <span class="comment">// 设定链表的释放函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m)) <span class="comment">// 设定链表的匹配函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup) <span class="comment">// 获取链表的复制函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFreeMethod(l) ((l)-&gt;free) <span class="comment">// 获取链表的释放函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match) <span class="comment">// 获取链表的匹配函数</span></span></span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;</span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个链表</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listEmpty(<span class="built_in">list</span>);</span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在头部新增一个结点</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在尾部新增一个结点</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表的old_node结点前或者后（由after变量指定）插入一个新的结点</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除链表中的node结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取列表迭代器，direction为方向参数，AL_START_HEAD正序和AL_START_TAIL逆序</span></span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过迭代器访问下一个结点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表复制</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    listRewind(orig, &amp;iter);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找key，如果链表有定义match函数，则通过match函数来查找，否则判断结点的value来和key是否相等</span></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    listRewind(<span class="built_in">list</span>, &amp;iter);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取链表中第index的结点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取链表首结点的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取链表尾结点的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将链表的尾节点移动插入到链表头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将链表o插入到链表l的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;head)</span><br><span class="line">        o-&gt;head-&gt;prev = l-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;tail)</span><br><span class="line">        l-&gt;tail-&gt;next = o-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l-&gt;head = o-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;tail) l-&gt;tail = o-&gt;tail;</span><br><span class="line">    l-&gt;len += o-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup other as an empty list. */</span></span><br><span class="line">    o-&gt;head = o-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    o-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11新特性</title>
    <url>/c/cpp11-features/</url>
    <content><![CDATA[<p>在看《C++ Primer Plus》的时候，了解到了很多 C++11 的新特性，将其记录下来，一是能加深印象，二是日后随时随地都能方便查看。</p>
<h2 id="1-新功能"><a href="#1-新功能" class="headerlink" title="1. 新功能"></a>1. 新功能</h2><h3 id="1-1-新类型"><a href="#1-1-新类型" class="headerlink" title="1.1 新类型"></a>1.1 新类型</h3><p>新增类型 long long 和 unsigned long long，以支持64位（或更宽）的整型；新增类型 char16_t 和 char32_t，以支持16位和32位的字符表示。</p>
<h3 id="1-2-统一的初始化"><a href="#1-2-统一的初始化" class="headerlink" title="1.2 统一的初始化"></a>1.2 统一的初始化</h3><a id="more"></a>
<p>C++11扩大了用大括号括起的列表（初始化列表）的适用范围，使其可用于所有内置类型和用户定义的类型（即类对象）。使用初始化列表时，可添加等号（=），也可不添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有内置类型</span></span><br><span class="line"><span class="keyword">int</span> x = &#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> y &#123;<span class="number">2.42</span>&#125;;</span><br><span class="line"><span class="keyword">short</span> quar[<span class="number">5</span>] &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 可用于new表达式</span></span><br><span class="line"><span class="keyword">int</span> * arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>] &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">// 可用于自定义对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stump</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> roots;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stump(<span class="keyword">int</span> r, <span class="keyword">double</span> w) : roots(r), weight(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stump <span class="title">s1</span><span class="params">(<span class="number">3</span>, <span class="number">15.6</span>)</span></span>;    <span class="comment">// old style</span></span><br><span class="line">Stump s2&#123;<span class="number">5</span>, <span class="number">43</span>,<span class="number">4</span>&#125;;    <span class="comment">// C++11</span></span><br><span class="line">Stump s3 = &#123;<span class="number">4</span>, <span class="number">32.1</span>&#125;; <span class="comment">// c++11</span></span><br></pre></td></tr></table></figure>
<p>新增模板类 <strong>initializer_list</strong>，可将其用作构造函数的参数、常规函数的参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; il)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = sum(&#123;<span class="number">2.5</span>, <span class="number">3.1</span>, <span class="number">4</span>&#125;); <span class="comment">// 4 将转为4.0</span></span><br><span class="line">    <span class="comment">// todo: ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; il)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = il.begin(); p != il.end(); p++)</span><br><span class="line">        tot += *p;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-声明"><a href="#1-3-声明" class="headerlink" title="1.3 声明"></a>1.3 声明</h3><h4 id="1-3-1-auto"><a href="#1-3-1-auto" class="headerlink" title="1.3.1 auto"></a>1.3.1 auto</h4><p>以前，关键字 <strong>auto</strong> 是一个存储类型说明符，C++11 将其用于实现自动类型推断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">112</span>; <span class="comment">// a is type int</span></span><br><span class="line"><span class="keyword">auto</span> pt = &amp;a; <span class="comment">// pt is type int *</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fm</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">auto</span> pf = fm; <span class="comment">// pf is type double (*)(double, int)</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-decltype"><a href="#1-3-2-decltype" class="headerlink" title="1.3.2 decltype"></a>1.3.2 decltype</h4><p>关键字 <strong>decltype</strong> 将变量的类型声明为表达式指定的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">decltype</span>(x*n) q; <span class="comment">// q same type as x*n, i.e., double</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x) pd; <span class="comment">// pd same as &amp;x, i.e., double *</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-3-返回类型后置"><a href="#1-3-3-返回类型后置" class="headerlink" title="1.3.3 返回类型后置"></a>1.3.3 返回类型后置</h4><p>C++11 新增了一种函数声明语法：在函数名和参数列表后面指定返回类型：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">// old style</span></span><br><span class="line">auto f2(double, int) -&gt; double; // new syntax, return type is double</span><br></pre></td></tr></table></figure>
<p>在模板函数中使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto eff(T t, U u) -&gt; decltype(T*U) &#123;</span><br><span class="line">    <span class="comment">// todo: ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-4-模板别名：using"><a href="#1-3-4-模板别名：using" class="headerlink" title="1.3.4 模板别名：using ="></a>1.3.4 模板别名：using =</h4><p>对于冗长或复杂的标识符，如果能够创建其别名将很方便。以前，C++为此提供了 typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator itType;</span><br></pre></td></tr></table></figure>
<p>C++11 提供了另一种创建别名的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> itType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator;</span><br></pre></td></tr></table></figure>
<p>差别在于，新语法也可用于模板部分具体化，但 typedef 不能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> arr12 = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, <span class="number">12</span>&gt;;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-5-nullptr"><a href="#1-3-5-nullptr" class="headerlink" title="1.3.5 nullptr"></a>1.3.5 nullptr</h4><p>空指针是不会指向有效数据的指针。以前，C++ 在源代码中使用 0 表示这种指针，但这带来了一些问题，因为这使得 0 即可表示指针常量，又可表示整型常量。<br>新增了关键字 nullptr，用于表示空指针，它是指针类型，不能转换为整型类型。为向后兼容，C++11 仍允许使用 0 表示空指针，因此表达式 nullptr == 0 为 true。</p>
<h3 id="1-4-智能指针"><a href="#1-4-智能指针" class="headerlink" title="1.4 智能指针"></a>1.4 智能指针</h3><p>C++11 摒弃了 auto_ptr，并新增了三种智能指针：<strong>unique_ptr</strong>、<strong>shared_ptr</strong> 和 <strong>weak_ptr</strong>，定义在 <code>&lt;memory&gt;</code> 中。<br>三者皆可对动态资源进行管理，保证任何情况下，已构造的对象最终会被销毁，也就是它的析构函数最终会被调用。</p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>unique_ptr 持有对象的独有权，同一时刻只能有一个 unique_ptr 指向给定对象（通过禁止拷贝语义，只有移动语义来实现）。<br>unique_ptr 指针本身的生命周期：从 unique_ptr 指针创建时开始，直到离开作用域。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>))</span></span>;  <span class="comment">// 无法拷贝</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; up2 = up1;      // err, 编译时错误</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *up1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;         <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up3 = <span class="built_in">std</span>::move(up1); <span class="comment">// 可以移动，up3独占该指针</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; *up1 &lt;&lt; std::endl;         // err, 运行时错误</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *up3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;         <span class="comment">// 11</span></span><br><span class="line">    up1.reset();    <span class="comment">// 不会导致运行时错误</span></span><br><span class="line">    up3.reset();    <span class="comment">// 显示释放内存</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; *up3 &lt;&lt; std::endl;         // err, 运行时错误</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up4</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>))</span></span>;  <span class="comment">// 无法拷贝</span></span><br><span class="line">    up4.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">44</span>)); <span class="comment">// &quot;绑定&quot;动态对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *up4 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;         <span class="comment">// 44</span></span><br><span class="line">    up4 = <span class="literal">nullptr</span>; <span class="comment">// 显示销毁所指向对象，同时智能指针变为空指针，与reset()等价</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up5</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">55</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> *p = up5.release(); <span class="comment">//只是释放控制权，不会释放内存</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 55</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *up5 &lt;&lt; endl; // err, 运行时错误</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">//释放堆区资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>shared_ptr 允许多个该智能指针共享一段内存，通过引用计数（reference counting）实现，会记录有多少个 shared_ptr 共同指向一个对象，一旦最后一个 shared_ptr 被销毁，也就是某个对象的引用计数变为 0，这个对象会被自动删除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>))</span></span>; <span class="comment">// 引用计数 = 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1; <span class="comment">// 允许拷贝，引用计数加一</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp1 count: &quot;</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// sp1 count: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp2 count: &quot;</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// sp2 count: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">    sp1.reset(); <span class="comment">// 显示释放对象控制权，引用计数减一</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sp2 count: &quot;</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// sp2 count: 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>weak_ptr 是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用计数的增加或减少。没有重载 <code>*</code> 和 <code>-&gt;</code>，但可以使用 lock 获得一个可用的 shared_ptr 对象。</p>
<p>weak_ptr 的使用更为复杂一点，它可以指向 shared_ptr 指针指向的对象内存，却并不拥有该内存，而使用 weak_ptr 成员 lock，则可返回其指向内存的一个 share_ptr 对象，且在所指对象内存已经无效时，返回指针空值 nullptr。</p>
<p>注意：weak_ptr 并不拥有资源的所有权，所以不能直接使用资源。<br>可以从一个 weak_ptr 构造一个 shared_ptr 以取得共享资源的所有权。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt;&amp; wp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp = wp.lock();</span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer is invalid&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>))</span></span>; <span class="comment">// 引用计数 = 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1; <span class="comment">// 允许拷贝，引用计数加一</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp1 = sp1; <span class="comment">// wp1的构造不会引起引用计数加一</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;wp1 count: &quot;</span> &lt;&lt; wp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// wp1 count: 2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    check(wp1); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">    sp1.reset(); <span class="comment">// 显示释放对象控制权，引用计数减一</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;wp1 count: &quot;</span> &lt;&lt; wp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// wp1 count: 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    check(wp1); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">    sp2.reset(); <span class="comment">// 显示释放对象控制权，引用计数减一</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;wp1 count: &quot;</span> &lt;&lt; wp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// wp1 count: 0</span></span><br><span class="line">    check(wp1); <span class="comment">// pointer is invalid</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-异常规范方面的修改"><a href="#1-5-异常规范方面的修改" class="headerlink" title="1.5 异常规范方面的修改"></a>1.5 异常规范方面的修改</h3><p>C++11 提供了关键字 noexcept，该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。</p>
<h3 id="1-6-作用域内枚举"><a href="#1-6-作用域内枚举" class="headerlink" title="1.6 作用域内枚举"></a>1.6 作用域内枚举</h3><p>传统的C++枚举提供了一种创建名称常量的方式，但其类型检查相当低级。另外，枚举名的作用域为枚举定义所属的作用域，这意味着如果在同一个作用域内定义两个枚举，他们的枚举成员不能同名。最后，枚举可能不是可完全移植的，因为不同的实现可能选择不同的底层类型。为解决这些问题，C++11 新增了一种枚举。这种枚举使用 class 或 struct 定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Old &#123;yes, no, maybe&#125;;    <span class="comment">// old form</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">New1</span> &#123;</span>never, sometimes, often, always&#125;; <span class="comment">// new form</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span> <span class="title">New2</span> &#123;</span>never, lever, sever&#125;; <span class="comment">// new form</span></span><br></pre></td></tr></table></figure>
<p>新枚举要求进行显示限定，以免发生名称冲突。因此，引用特定枚举时，需要使用 New1::never 和 New2::never 等。</p>
<h3 id="1-7-对类的修改"><a href="#1-7-对类的修改" class="headerlink" title="1.7 对类的修改"></a>1.7 对类的修改</h3><h4 id="1-7-1-显示转换运算符"><a href="#1-7-1-显示转换运算符" class="headerlink" title="1.7.1 显示转换运算符"></a>1.7.1 显示转换运算符</h4><p>传统C++的关键字 <strong>explicit</strong> 禁止单参数构造函数导致的自动转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plebe</span> &#123;</span></span><br><span class="line">    Plebe(<span class="keyword">int</span>); <span class="comment">// automatic int-to-plebe conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Plebe</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// requires explicit use</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Plebe a, b;</span><br><span class="line">a = <span class="number">5</span>;    <span class="comment">// implicit conversion, call Plebe(5)</span></span><br><span class="line">b = <span class="number">0.5</span>;  <span class="comment">// not allowed</span></span><br><span class="line">b = Plebe(<span class="number">0.5</span>); <span class="comment">// explicit conversion</span></span><br></pre></td></tr></table></figure>
<p>C++11扩展了 <strong>explicit</strong> 的这种用法，使得可对转换函数做类似的处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plebe</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// conversion functions</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Plebe a, b;</span><br><span class="line"><span class="keyword">int</span> n = a;    <span class="comment">// int-to-Plebe automatic conversion</span></span><br><span class="line"><span class="keyword">double</span> x = b;  <span class="comment">// not allowed</span></span><br><span class="line">x = <span class="keyword">double</span>(<span class="number">0.5</span>); <span class="comment">// explicit conversion, allowed</span></span><br></pre></td></tr></table></figure>
<h4 id="1-7-2-类内成员初始化"><a href="#1-7-2-类内成员初始化" class="headerlink" title="1.7.2 类内成员初始化"></a>1.7.2 类内成员初始化</h4><p>传统C++不支持在类定义中初始化成员，C++11可以这么做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> mem2 &#123;<span class="number">1966.54</span>&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-模板和STL方面的修改"><a href="#1-8-模板和STL方面的修改" class="headerlink" title="1.8 模板和STL方面的修改"></a>1.8 模板和STL方面的修改</h3><h4 id="1-8-1-基于范围的for循环"><a href="#1-8-1-基于范围的for循环" class="headerlink" title="1.8.1 基于范围的for循环"></a>1.8.1 基于范围的for循环</h4><p>对于内置数组以及包含方法 begin() 和 end() 的类和 STL 容器，可以使用如下的方式进行循环工作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : arr)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 可使用auto进行类型推断</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : arr)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 可使用引用类型进行修改元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : arr)</span><br><span class="line">x = <span class="built_in">std</span>::rand();</span><br></pre></td></tr></table></figure>
<h4 id="1-8-2-新的STL容器"><a href="#1-8-2-新的STL容器" class="headerlink" title="1.8.2 新的STL容器"></a>1.8.2 新的STL容器</h4><p>C++11新增了STL容器： <strong>forward_list、unordered_map、unordered_multimap、unordered_set</strong> 和 <strong>unordered_multiset</strong>。<br>C++11还新增了模板 <strong>array</strong>，该模板相对于数组，新增了begin() 和 end() 方法等。</p>
<h4 id="1-8-3-新的STL方法"><a href="#1-8-3-新的STL方法" class="headerlink" title="1.8.3 新的STL方法"></a>1.8.3 新的STL方法</h4><p>C++11 新增了STL方法 cbegin()、cend()、crbegin() 和 crend()。是begin()、 end()、rbegin() 和 rend() 方法的const版本。</p>
<h4 id="1-8-4-valarray升级"><a href="#1-8-4-valarray升级" class="headerlink" title="1.8.4 valarray升级"></a>1.8.4 valarray升级</h4><p>C++11添加了两个函数（begin() 和 end()），它们都接受valarray作为参数，并返回迭代器。这使得能够将基于范围的STL算法用于 valarray。</p>
<h4 id="1-8-5-摒弃export"><a href="#1-8-5-摒弃export" class="headerlink" title="1.8.5 摒弃export"></a>1.8.5 摒弃export</h4><h4 id="1-8-6-尖括号"><a href="#1-8-6-尖括号" class="headerlink" title="1.8.6 尖括号"></a>1.8.6 尖括号</h4><p>为避免与运算符 &gt;&gt; 混淆，C++要求在声明嵌套模板时使用空格将尖括号分开：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt; vl;</span><br></pre></td></tr></table></figure>
<p>C++11 不再这样要求：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; vl;</span><br></pre></td></tr></table></figure>
<h3 id="1-9-右值引用"><a href="#1-9-右值引用" class="headerlink" title="1.9 右值引用"></a>1.9 右值引用</h3><p>传统的 C++ 引用（现在称为左值引用）使得标识符关联到左值。左值是一个表示数据的表达式（如变量名或解除引用的指针），程序可获取其地址。最初，左值可出现在赋值语句的左边，但修饰符 const 的出现使得可以声明这样的标识符，即不能给它赋值，但可获取其地址：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">101</span>;   <span class="comment">// can&#x27;t assign to b, but &amp;b is valid</span></span><br><span class="line"><span class="keyword">int</span> &amp; rn = n;        <span class="comment">// n identifies datum at address &amp;n</span></span><br><span class="line"><span class="keyword">int</span> &amp; rt = *pt;      <span class="comment">// *pt identifies datum at address pt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; rb = b;  <span class="comment">// b identifies const datum at address &amp;b</span></span><br></pre></td></tr></table></figure>
<p>C++11 新增了右值引用，这是使用&amp;&amp;表示的。右值引用可关联到右值，即可出现在赋值表达式右边，但不能对其应用地址运算符的值。右值包括字面常量、诸如x+y等表达式以及返回值的函数（条件是该函数返回的不是引用）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; r1 = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; r2 = x + y;</span><br><span class="line"><span class="keyword">double</span> &amp;&amp; r3 = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<p>注意，r2关联到的是当时计算 x + y 得到的结果。也就是说，r2关联到的是33，即使以后修改了x 或 y，也不影响到r2。<br>有趣的是，将右值关联到右值引用导致该右值被存储到特定的位置，且可以获取该位置的地址。也就是说，虽然不能将运算符&amp;用于13，但可将其用于r1。通过将数据与特定的地址关联，使得可以通过右值引用来访问该数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> tf)</span> </span>&#123; <span class="keyword">return</span> <span class="number">5.0</span>*(tf<span class="number">-32.0</span>)/<span class="number">9.0</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> tc = <span class="number">21.5</span>;</span><br><span class="line">    <span class="keyword">double</span> &amp;&amp; rd1 = <span class="number">7.07</span>;</span><br><span class="line">    <span class="keyword">double</span> &amp;&amp; rd2 = <span class="number">1.8</span> * tc + <span class="number">32.0</span>;</span><br><span class="line">    <span class="keyword">double</span> &amp;&amp; rd3 = f(rd2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; tc value and address: &quot;</span> &lt;&lt; tc &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;tc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rd1 value and address: &quot;</span> &lt;&lt; rd1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;rd1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rd2 value and address: &quot;</span> &lt;&lt; rd2 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;rd2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rd3 value and address: &quot;</span> &lt;&lt; rd3 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;rd3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序输出如下：</span></span><br><span class="line">tc value <span class="keyword">and</span> address: <span class="number">21.5</span>, <span class="number">0x7ffeb988e850</span></span><br><span class="line">rd1 value <span class="keyword">and</span> address: <span class="number">7.07</span>, <span class="number">0x7ffeb988e858</span></span><br><span class="line">rd2 value <span class="keyword">and</span> address: <span class="number">70.7</span>, <span class="number">0x7ffeb988e860</span></span><br><span class="line">rd3 value <span class="keyword">and</span> address: <span class="number">21.5</span>, <span class="number">0x7ffeb988e868</span></span><br></pre></td></tr></table></figure>
<p>引入右值引用的主要目的之一是实现移动语义。</p>
<h2 id="2-移动语义和右值引用"><a href="#2-移动语义和右值引用" class="headerlink" title="2. 移动语义和右值引用"></a>2. 移动语义和右值引用</h2><h3 id="2-1-为何需要移动语义"><a href="#2-1-为何需要移动语义" class="headerlink" title="2.1 为何需要移动语义"></a>2.1 为何需要移动语义</h3><p>定义并实现了一个 MyString 字符串类，该类内部管理一个 char * 数组。这个时候一般都需要实现拷贝构造函数和拷贝赋值函数，因为默认的拷贝是浅拷贝，而指针这种资源不能共享，不然一个析构了，另一个也就完蛋了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">        CCtor ++;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyString() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间，不这么做，调用的次数可能远大于1000</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.push_back(MyString(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// output: CCtor = 1000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码调用了1000次拷贝构造函数，如果 MyString(“hello”) 构造出来的字符串本来就很长，构造一遍就很耗时了，最后却还要拷贝一遍，而 MyString(“hello”) 只是临时对象，拷贝完就没什么用了，这就造成了没有意义的资源申请和释放操作，如果能够直接使用临时对象已经申请的资源，既能节省资源，又能节省资源申请和释放的时间。而 C++11 新增加的移动语义就能够做到这一点。移动语义实际上避免了移动原始数据，而只是修改了记录。</p>
<h3 id="2-2-一个移动示例"><a href="#2-2-一个移动示例" class="headerlink" title="2.2 一个移动示例"></a>2.2 一个移动示例</h3><p>下面通过一个示例演示移动语义和右值引用的工作原理。要实现移动语义就必须增加两个函数：移动构造函数和移动赋值构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MCtor; <span class="comment">//统计调用移动构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CAsgn; <span class="comment">//统计调用拷贝赋值函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MAsgn; <span class="comment">//统计调用移动赋值函数的次数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">        CCtor ++;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">        :m_data(str.m_data) &#123;</span><br><span class="line">        MCtor ++;</span><br><span class="line">        str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str)&#123;</span><br><span class="line">        CAsgn ++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">        MAsgn ++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = str.m_data;</span><br><span class="line">        str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyString() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.push_back(MyString(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output：</span></span><br><span class="line"><span class="comment">* CCtor = 0</span></span><br><span class="line"><span class="comment">* MCtor = 1000</span></span><br><span class="line"><span class="comment">* CAsgn = 0</span></span><br><span class="line"><span class="comment">* MAsgn = 0 */</span></span><br></pre></td></tr></table></figure>
<p>可以看到，移动构造函数与拷贝构造函数的区别是，拷贝构造的参数是 const MyString&amp; str，是常量左值引用，而移动构造的参数是 MyString&amp;&amp; str，是右值引用，而 MyString(“hello”) 是个临时对象，是个右值，优先进入移动构造函数而不是拷贝构造函数。而移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是”偷”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为 nullptr，这一步很重要，如果不将别人的指针修改为空，那么临时对象析构的时候就会释放掉这个资源，”偷”也白偷了。</p>
<h3 id="2-3-强制移动"><a href="#2-3-强制移动" class="headerlink" title="2.3 强制移动"></a>2.3 强制移动</h3><p>对于一个左值，肯定是调用拷贝构造函数了，但是有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？ C++11 为了解决这个问题，在头文件 utility.h 中提供了 std::move() 方法来将左值转换为右值，从而方便应用移动语义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="function">MyString <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">        vecStr.push_back(tmp); <span class="comment">//调用的是拷贝构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    MyString::CCtor = <span class="number">0</span>;</span><br><span class="line">    MyString::MCtor = <span class="number">0</span>;</span><br><span class="line">    MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line">    MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr2;</span><br><span class="line">    vecStr2.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="function">MyString <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">        vecStr2.push_back(<span class="built_in">std</span>::move(tmp)); <span class="comment">//调用的是移动构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">CCtor = 1000</span></span><br><span class="line"><span class="comment">MCtor = 0</span></span><br><span class="line"><span class="comment">CAsgn = 0</span></span><br><span class="line"><span class="comment">MAsgn = 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CCtor = 0</span></span><br><span class="line"><span class="comment">MCtor = 1000</span></span><br><span class="line"><span class="comment">CAsgn = 0</span></span><br><span class="line"><span class="comment">MAsgn = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>对于大多数程序员来说，右值引用带来的主要好处并非是让他们能够编写使用右值引用的代码，而是能够使用利用右值引用实现移动语义的库代码。例如，STL 类现在都有复制构造函数、移动构造函数、复制赋值运算符和移动复制运算符。</p>
<h2 id="3-新的类功能"><a href="#3-新的类功能" class="headerlink" title="3. 新的类功能"></a>3. 新的类功能</h2><h3 id="3-1-特殊的成员函数"><a href="#3-1-特殊的成员函数" class="headerlink" title="3.1 特殊的成员函数"></a>3.1 特殊的成员函数</h3><p>在原有的4个特殊成员函数（默认构造函数、复制构造函数、复制赋值运算符和析构函数）的基础上，C++11 新增了两个：移动构造函数和移动赋值运算符。这些成员函数是编译器在各种情况下自动提供的。</p>
<h3 id="3-2-默认的方法和禁用的方法"><a href="#3-2-默认的方法和禁用的方法" class="headerlink" title="3.2 默认的方法和禁用的方法"></a>3.2 默认的方法和禁用的方法</h3><p>C++11 提供了更好地控制要使用的方法：可使用关键字 default 显示地声明这些方法的默认版本；关键字 delete 可用于禁止编译器使用特定方法。</p>
<h3 id="3-3-委托构造函数"><a href="#3-3-委托构造函数" class="headerlink" title="3.3 委托构造函数"></a>3.3 委托构造函数</h3><p>如果给类提供了多个构造函数，您可能重复编写相同的代码。也就是说，有些构造函数可能需要包含其他构造函数中已有的代码。为了让编码工作更简单、更可靠，C++11 允许您在一个构造函数的定义中使用另一个构造函数。这被称为委托。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notes</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> st;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Notes();</span><br><span class="line">    Notes(<span class="keyword">int</span>);</span><br><span class="line">    Notes(<span class="keyword">int</span>, <span class="keyword">double</span>);</span><br><span class="line">    Notes(<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">string</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Notes::Notes(<span class="keyword">int</span> kk, <span class="keyword">double</span> xx, <span class="built_in">std</span>::<span class="built_in">string</span> stt) : k(kk), x(xx), st(stt) &#123; <span class="comment">/*do stuff*/</span> &#125;</span><br><span class="line">Notes::Notes() : Notes(<span class="number">0</span>, <span class="number">0.01</span>, <span class="string">&quot;oh&quot;</span>) &#123; <span class="comment">/* do other stuff*/</span> &#125;</span><br><span class="line">Notes::Notes(<span class="keyword">int</span> kk) : Notes(kk, <span class="number">0.01</span>, <span class="string">&quot;oh&quot;</span>) &#123; <span class="comment">/* do other stuff*/</span> &#125;</span><br><span class="line">Notes::Notes(<span class="keyword">int</span> kk, <span class="keyword">double</span> xx) : Notes(kk, xx, <span class="string">&quot;oh&quot;</span>) &#123; <span class="comment">/* do other stuff*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>使用委托构造函数，会多发生一次构造函数的调用，这将会影响运行效率，好处在于能提高开发效率。</p>
<h2 id="4-Lambda函数"><a href="#4-Lambda函数" class="headerlink" title="4. Lambda函数"></a>4. Lambda函数</h2><p>C++11 新增Lambda函数，其格式如下：</p>
<blockquote>
<p>[捕捉列表] (参数) mutable -&gt; 返回值类型 {函数体}</p>
</blockquote>
<p>说明：</p>
<ul>
<li><p>[]是lambda的引出符，捕捉列表能够捕捉上下文中的变量，来供lambda函数使用：</p>
<ul>
<li>[var] 表示以值传递方式捕捉变量var</li>
<li>[=] 表示值传递捕捉所有父作用域变量</li>
<li>[&amp;var] 表示以引用传递方式捕捉变量var</li>
<li>[&amp;] 表示引用传递捕捉所有父作用域变量</li>
<li>[this] 表示值传递方式捕捉当前的this指针</li>
<li>还有一些组合：</li>
<li>[=,&amp;a] 表示以引用传递方式捕捉a,值传递方式捕捉其他变量</li>
<li>注意：</li>
<li>捕捉列表不允许变量重复传递，如：[=,a]、[&amp;,&amp;this]，会引起编译时期的错误</li>
</ul>
</li>
<li><p>参数列表与普通函数的参数列表一致。如果不需要传递参数，可以联连同()一同【省略】。</p>
</li>
<li>mutable 可以取消Lambda的常量属性，因为Lambda默认是const属性；multable仅仅是让Lamdba函数体修改值传递的变量，但是修改后并不会影响外部的变量。</li>
<li>-&gt;返回类型如果是void时，可以连-&gt;一起【省略】，如果返回类型很明确，可以省略，让编译器自动推倒类型。</li>
<li>函数体和普通函数一样，除了可以使用参数之外，还可以使用捕获的变量。</li>
</ul>
<p>从C++11开始，Lambda被广泛用在STL中，比如foreach。与函数指针比起来，函数指针有巨大的缺陷：1.函数定义在别处，阅读起来很困难；2.使用函数指针，很可能导致编译器不对其进行inline优化，循环次数太多时，函数指针和Lambda比起来性能差距太大。函数2指针不能应用在一些运行时才能决定的状态，在没有C++11时，只能用仿函数。使得学习STL算法的代价大大降低。</p>
<h2 id="5-包装器"><a href="#5-包装器" class="headerlink" title="5. 包装器"></a>5. 包装器</h2><p>C++ 提供了多个包装器（wrapper，也叫适配器[adapter]）。这些对象用于给其他编程接口提供更一致或更适合的接口。C++11 提供了模板 bind、men_fn 和 reference_wrapper 以及包装器 function。</p>
<h3 id="5-1-包装器-function-及模板的低效性"><a href="#5-1-包装器-function-及模板的低效性" class="headerlink" title="5.1 包装器 function 及模板的低效性"></a>5.1 包装器 function 及模板的低效性</h3><p>请看以下代码行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">answer = ef(q);</span><br></pre></td></tr></table></figure>
<p>ef 是什么呢？它可以是函数名、函数指针、函数对象或有名称的 Lambda 表达式。所有这些都是可调用的类型（callable type）。鉴于可调用的类型如此丰富，这可能导致模板的效率极低。为明白这一点，来看一个简单的案例。<br>首先，在头文件中定义一些模板，如下：<br><strong>somedef.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function">T <span class="title">use_f</span><span class="params">(T v, F f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  use_f count = &quot;</span> &lt;&lt; count</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, &amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> f(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> z_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fp(<span class="keyword">double</span> z = <span class="number">1.0</span>) : z_(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">double</span> p)</span> </span>&#123; <span class="keyword">return</span> z_ * p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> z_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fq(<span class="keyword">double</span> z = <span class="number">1.0</span>) : z_(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">double</span> p)</span> </span>&#123; <span class="keyword">return</span> z_ + p; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模板 use_f 使用参数 f 表示调用类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> f(v);</span><br></pre></td></tr></table></figure>
<p>接下来如下调用模板函数 use_f() 6次。<br><strong>callable.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;somedef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dub</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2.0</span> * x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">1.21</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer dub:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, dub) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer square:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, square) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer Fp:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, Fp(<span class="number">5.0</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer Fq:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, Fq(<span class="number">5.0</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda expression 1:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, [](<span class="keyword">double</span> u) &#123; <span class="keyword">return</span> u*u; &#125;) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda expression 2:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, [](<span class="keyword">double</span> u) &#123; <span class="keyword">return</span> u+u/<span class="number">2.0</span>; &#125;) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每次调用中，模板参数 T 都被设置为类型 double。模板参数 F 呢？每次调用时，F 都接受一个 double 值并返回一个 double 值，因此在6次 use_f() 调用中，好像 F 的类型都相同，因此只会实例化模板一次。<br>但正如下面的输出表明的，这种想法太天真了：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Function pointer dub:</span><br><span class="line">  use_f count = 1, &amp;count = 0x6018cc</span><br><span class="line">  2.42</span><br><span class="line">Function pointer square:</span><br><span class="line">  use_f count = 2, &amp;count = 0x6018cc</span><br><span class="line">  1.4641</span><br><span class="line">Function pointer Fp:</span><br><span class="line">  use_f count = 1, &amp;count = 0x6018d0</span><br><span class="line">  6.05</span><br><span class="line">Function pointer Fq:</span><br><span class="line">  use_f count = 1, &amp;count = 0x6018d4</span><br><span class="line">  6.21</span><br><span class="line">Lambda expression 1:</span><br><span class="line">  use_f count = 1, &amp;count = 0x6018c4</span><br><span class="line">  1.4641</span><br><span class="line">Lambda expression 2:</span><br><span class="line">  use_f count = 1, &amp;count = 0x6018c8</span><br><span class="line">  1.815</span><br></pre></td></tr></table></figure>
<p>模板函数 use_f() 有一个静态成员 count，可根据它的地址确定模板实例化了多少次。<strong>有5个不同的地址，这表明模板 use_f() 有5个不同的实例化</strong>。<br>为了解其中的原因，请考虑编译器如何判断模板参数 F 的类型。首先，来看下面的调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">use_f(y, dub);</span><br></pre></td></tr></table></figure>
<p>其中 dub 是一个函数的名称，该函数接受一个 double 参数并返回一个 double 值。函数名是指针，因此参数 F 的类型为 <code>double(*)(double)</code>：一个指向这样的函数的指针。<br>下一个调用如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">use_f(y, square);</span><br></pre></td></tr></table></figure>
<p>第二个参数的类型也是 <code>double(*)(double)</code>，因此该调用使用的 use_f() 实例化与第一个调用相同。<br>在接下来的 use_f() 调用中，第二个参数为对象，F 的类型分别为 Fp 和 Fq，因为将为这些 F 值实例化 use_f() 模板两次。最后，最后两个调用将 F 的类型设置为编译器为 Lambda 表达式使用的类型。</p>
<h3 id="5-2-修复问题"><a href="#5-2-修复问题" class="headerlink" title="5.2 修复问题"></a>5.2 修复问题</h3><p>注意在 <code>callable.cpp</code> 中的函数指针、函数对象和 Lambda 表达式有一个相同的地方，它们都接受一个 double 参数并返回一个 double 值。可以说它们的调用特征标（call signature）相同，因此这6个实例的调用特征标都是 <code>double(double)</code>。<br>模板 function 它从调用特征标的角度定义了一个对象，可用于包装调用特征标相同的函数指针、函数对象和 Lambda 表达式。例如，下面的声明创建了一个名为 fdci 的 function 对象，它接受一个 char 参数和一个 int 参数，并返回一个 double 值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">char</span>, <span class="keyword">int</span>)&gt; fdci;</span><br></pre></td></tr></table></figure>
<p>然后，可以将接受一个 char 参数和一个 int 参数，并返回 double 值的任何函数指针、函数对象或 Lambda 表达式赋给它。<br>如 <code>callable.cpp</code> 中，所有可调用参数的调用特征标都相同：<code>double(double)</code>。因此，可以使用 <code>std::function&lt;double(double)&gt;</code> 创建包装器，以达到 use_f() 只被实例化一次的目的，修改的程序清单如下：<br>在 somedef.h 中，将模板 use_f() 第二个参数声明为 function 包装器对象，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // 包装器 function 是在头文件 functional 中声明的</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">use_f</span><span class="params">(T v, <span class="built_in">std</span>::function&lt;T(T)&gt; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  use_f count = &quot;</span> &lt;&lt; count</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, &amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> f(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>修改 callable.cpp 中的调用方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;somedef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // 包装器 function 是在头文件 functional 中声明的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dub</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2.0</span> * x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::function;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">1.21</span>;</span><br><span class="line">    <span class="comment">// 调用方式一：</span></span><br><span class="line">    <span class="keyword">typedef</span> function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>)&gt; fdd;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer dub:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, fdd(dub)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer square:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, fdd(square)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer Fp:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, fdd(Fp(<span class="number">5.0</span>))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer Fq:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, fdd(Fq(<span class="number">5.0</span>))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda expression 1:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, fdd([](<span class="keyword">double</span> u) &#123; <span class="keyword">return</span> u*u; &#125;)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda expression 2:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f(y, fdd([](<span class="keyword">double</span> u) &#123; <span class="keyword">return</span> u+u/<span class="number">2.0</span>; &#125;)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用方式二：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数 dub、Fp(5.0) 等本身的类型并不是 function&lt;double(double)&gt;，因此在 use_f 后面使用了 &lt;double&gt;</span></span><br><span class="line"><span class="comment">     * 来指出所需的具体化。这样，T 被设置为 double，而 std::function&lt;T(T)&gt; 变成了 std::function&lt;double(double)&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer dub:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f&lt;<span class="keyword">double</span>&gt;(y, dub) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer square:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f&lt;<span class="keyword">double</span>&gt;(y, square) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer Fp:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f&lt;<span class="keyword">double</span>&gt;(y, Fp(<span class="number">5.0</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Function pointer Fq:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f&lt;<span class="keyword">double</span>&gt;(y, Fq(<span class="number">5.0</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda expression 1:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f&lt;<span class="keyword">double</span>&gt;(y, [](<span class="keyword">double</span> u) &#123; <span class="keyword">return</span> u*u; &#125;) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lambda expression 2:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; use_f&lt;<span class="keyword">double</span>&gt;(y, [](<span class="keyword">double</span> u) &#123; <span class="keyword">return</span> u+u/<span class="number">2.0</span>; &#125;) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是该程序的输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Function pointer dub:</span><br><span class="line">  use_f count = 1, &amp;count = 0x6054c0</span><br><span class="line">  2.42</span><br><span class="line">Function pointer square:</span><br><span class="line">  use_f count = 2, &amp;count = 0x6054c0</span><br><span class="line">  1.4641</span><br><span class="line">Function pointer Fp:</span><br><span class="line">  use_f count = 3, &amp;count = 0x6054c0</span><br><span class="line">  6.05</span><br><span class="line">Function pointer Fq:</span><br><span class="line">  use_f count = 4, &amp;count = 0x6054c0</span><br><span class="line">  6.21</span><br><span class="line">Lambda expression 1:</span><br><span class="line">  use_f count = 5, &amp;count = 0x6054c0</span><br><span class="line">  1.4641</span><br><span class="line">Lambda expression 2:</span><br><span class="line">  use_f count = 6, &amp;count = 0x6054c0</span><br><span class="line">  1.815</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function pointer dub:</span><br><span class="line">  use_f count = 7, &amp;count = 0x6054c0</span><br><span class="line">  2.42</span><br><span class="line">Function pointer square:</span><br><span class="line">  use_f count = 8, &amp;count = 0x6054c0</span><br><span class="line">  1.4641</span><br><span class="line">Function pointer Fp:</span><br><span class="line">  use_f count = 9, &amp;count = 0x6054c0</span><br><span class="line">  6.05</span><br><span class="line">Function pointer Fq:</span><br><span class="line">  use_f count = 10, &amp;count = 0x6054c0</span><br><span class="line">  6.21</span><br><span class="line">Lambda expression 1:</span><br><span class="line">  use_f count = 11, &amp;count = 0x6054c0</span><br><span class="line">  1.4641</span><br><span class="line">Lambda expression 2:</span><br><span class="line">  use_f count = 12, &amp;count = 0x6054c0</span><br><span class="line">  1.815</span><br></pre></td></tr></table></figure>
<p>从上述输出可知，count 的地址都相同，而 count 的值表明，use_f() 被调用了12次，这表明只有一个实例，并调用了该实例12次，这缩小了可执行代码的规模。</p>
<h3 id="5-3-bind"><a href="#5-3-bind" class="headerlink" title="5.3 bind"></a>5.3 bind</h3><p>很多 STL 算法都使用函数对象 一一 也叫函数符（functor）。函数符是可以以函数方式与（）结合使用的任意对象。这包括函数名、指向函数的指针和重载了()运算符的类对象（即定义了函数 operator()() 的类）。<br>例如，可以像这样定义一个对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linear</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> slope;</span><br><span class="line">    <span class="keyword">double</span> y0;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Linear(<span class="keyword">double</span> sl_ = <span class="number">1</span>, <span class="keyword">double</span> y_ = <span class="number">0</span>)</span><br><span class="line">        : slope(sl_), y0(y_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> y0 + slope * x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，重载的()运算符将使得能够像函数那样使用 Linear 对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Linear f1;</span><br><span class="line"><span class="function">Linear <span class="title">f2</span><span class="params">(<span class="number">2.5</span>, <span class="number">10.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> y1 = f1(<span class="number">12.5</span>);</span><br><span class="line"><span class="keyword">double</span> y2 = f2(<span class="number">0.4</span>);</span><br></pre></td></tr></table></figure>
<p>函数符的概念如下：</p>
<ul>
<li>生成器（generator）是不用参数就可以调用的函数符。</li>
<li>一元函数（unary function）是用一个参数就可以调用的函数符。</li>
<li>二元函数（binary function）使用两个参数可以调用的函数符。</li>
</ul>
<p>在 C++98 中有两个函数 bind1st 和 bind2nd，它们将二元函数转换为一元函数，区别就是 bind1st 用于绑定第一个参数，bind2nd 用于绑定第二个参数，都只能绑定一个参数。<br>C++98 提供的这些特性已经由于 C++11 的到来而过时，由于各种限制，我们经常使用 bind 而非 bind1st 和 bind2nd。<br><strong>过时的 bind1st 和 bind2nd 的用法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">5</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">// 查找元素值大于10的个数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="built_in">std</span>::count_if(coll.begin(), coll.end(),              <span class="comment">// 范围</span></span><br><span class="line">                          <span class="built_in">std</span>::bind1st(<span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;(), <span class="number">10</span>));   <span class="comment">// 将10绑定到 std::less 的第一个参数，也就是10小于......</span></span><br><span class="line"><span class="comment">// 查找第一个元素值大于10的元素</span></span><br><span class="line"><span class="built_in">std</span>::find_if(coll.begin(), coll.end(),              <span class="comment">// 范围</span></span><br><span class="line">             <span class="built_in">std</span>::bind2nd(<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">10</span>); <span class="comment">// 将10绑定到 std::greater 的第二个参数，也就是......大于10</span></span><br></pre></td></tr></table></figure>
<p><strong>C++11 中的 bind 的用法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 x + 10 的结果：</span></span><br><span class="line"><span class="comment">// function object 内部调用 plus&lt;&gt;（也就是 operator+），以占位符 placeholders_1 为第一个参数，</span></span><br><span class="line"><span class="comment">// 以10位第二个参数，占位符_1表示实际传入此表达式的第一实参，返回“实参+10”的结果值</span></span><br><span class="line"><span class="keyword">auto</span> plus10 = <span class="built_in">std</span>::bind(<span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;(), <span class="built_in">std</span>::placeholders::_1, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; plus10(<span class="number">7</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 (x + 10) * 2 的结果：</span></span><br><span class="line"><span class="keyword">auto</span> mul2 = <span class="built_in">std</span>::bind(<span class="built_in">std</span>::multiplies&lt;<span class="keyword">int</span>&gt;(),</span><br><span class="line">                     <span class="built_in">std</span>::bind(<span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;(), <span class="built_in">std</span>::placeholders::_1, <span class="number">10</span>),</span><br><span class="line">                     <span class="number">2</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mul2(<span class="number">7</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 289</span></span><br></pre></td></tr></table></figure>
<p>注意，上面使用的 less&lt;int&gt;(), gearter&lt;int&gt;(), plus&lt;int&gt;() 以及 multiplies&lt;int&gt;() 等都是 C++ 预定义的 functor。因此我们可以知道，bind 可以把参数绑定到函数对象上。<br>C++98 的 bind1st 和 bind2nd 局限在于只能绑定一个参数，而 std::bind 可以绑定任意多个参数，使用起来更加方便，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fn2 has called.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line">    <span class="keyword">auto</span> bind_test1 = <span class="built_in">std</span>::bind(fn, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">auto</span> bind_test2 = <span class="built_in">std</span>::bind(fn, _1, _2, _3);</span><br><span class="line">    <span class="keyword">auto</span> bind_test3 = <span class="built_in">std</span>::bind(fn, <span class="number">0</span>, _1, _2);</span><br><span class="line">    <span class="keyword">auto</span> bind_test4 = <span class="built_in">std</span>::bind(fn, _2, <span class="number">0</span>, _1);</span><br><span class="line"></span><br><span class="line">    bind_test1();<span class="comment">//输出1 2 3</span></span><br><span class="line">    bind_test2(<span class="number">3</span>, <span class="number">8</span>, <span class="number">24</span>);<span class="comment">//输出3 8 24</span></span><br><span class="line">    bind_test2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//输出1 2 3，4和5会被丢弃</span></span><br><span class="line">    bind_test3(<span class="number">10</span>, <span class="number">24</span>);<span class="comment">//输出0 10 24</span></span><br><span class="line">    bind_test3(<span class="number">10</span>, fn2());<span class="comment">//输出0 10 -1</span></span><br><span class="line">    bind_test3(<span class="number">10</span>, <span class="number">24</span>, fn2());<span class="comment">//输出0 10 24，fn2会被调用，但其返回值会被丢弃</span></span><br><span class="line">    bind_test4(<span class="number">10</span>, <span class="number">24</span>);<span class="comment">//输出24 0 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，bind 还可以把参数绑定到普通函数、类成员函数、甚至数据成员等。</p>
<p><strong>std::bind 绑定普通函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Divide</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x/y; &#125;</span><br><span class="line"><span class="keyword">auto</span> fn = <span class="built_in">std</span>::bind(&amp;Divide, <span class="built_in">std</span>::placeholders::_1, <span class="number">2</span>); <span class="comment">// 绑定第二个参数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出5</span></span><br></pre></td></tr></table></figure>
<p><strong>std::bind 绑定一个成员函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 + n2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(&amp;Foo::print_sum, &amp;foo, <span class="number">95</span>, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">    f(<span class="number">5</span>); <span class="comment">// 输出100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>std::bind 绑定一个引用参数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words&#123;<span class="string">&quot;helo&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;C++11&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">ostringstream</span> os;</span><br><span class="line">    <span class="comment">// ostream不能拷贝，若希望传递给bind一个对象，</span></span><br><span class="line">    <span class="comment">// 而不拷贝它，就必须使用标准库提供的ref函数</span></span><br><span class="line">    for_each(words.begin(), words.end(),</span><br><span class="line">             bind(print, <span class="built_in">std</span>::ref(os), <span class="built_in">std</span>::placeholders::_1, c)); <span class="comment">// 此处可以不用显示的指定&amp;print，普通函数做实参时，会隐式转换为函数指针</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; os.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 bind 要注意的地方：</strong></p>
<ul>
<li>bind 预先绑定的参数需要传具体的变量或值进去，对于预先绑定的参数，是 <code>pass-by-value</code> 的。除非该参数被 std::ref 或者 std::cref 包装，才 <code>pass-by-reference</code>。</li>
<li>对于不事先绑定的参数，需要传 std::placeholders 进去，从_1开始，依次递增。placeholder 是 <code>pass-by-reference</code> 的。</li>
<li>bind 的返回值是可调用实体，可以直接赋给 std::function 对象。</li>
<li>对于绑定的指针、引用类型的参数，使用者需要保证在可调用实体调用之前，这些参数是可用的。</li>
<li>类的this可以通过对象或者指针来绑定。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-数据库的实现</title>
    <url>/Redis/3-database/redis-parse-db/</url>
    <content><![CDATA[<p>源码位置：db.c/server.h</p>
<p><strong>1. Redis数据库介绍：</strong><br>在前两个阶段中，我们学习了redis数据结构的实现，而这些数据结构都是为了实现数据库功能做的铺垫，下面，让我们一起来看看redis数据库是如何实现的吧。  </p>
<p>Redis服务器在运行的时候会创建大量的redisObject对象，这些对象都是存在redisDb中的，为了快速索引到某个对象，redisDb采用了dict字典结构设计。<br>启动Redis后，Redis服务器将所有数据库都保存在redisServer结构的db数组中，db数组的每一项都是一个redisDb结构，代表一个数据库。根据配置参数，redis服务器在初始化的时候，默认情况下会创建16个数据库，由dbnum决定(可通过<code>databases</code>配置修改)，每个数据库都是独立的。<br>客户端可以通过<code>select</code>命令来切换数据库，如<code>select 1</code>会切换到数据库号为 1 的数据库，select是通过修改客户端的db指针，指针指向不同的数据库来实现数据库的切换操作的。  </p>
<a id="more"></a>
<p>操作如下图：<br><img src="https://i.loli.net/2020/10/29/IJD7hLAU81kFSNz.png" alt="db0.png"></p>
<p>redis服务结构体如下：<br><img src="https://i.loli.net/2020/10/29/DeiQsrYdVA4Cn9M.png" alt="db1.png"></p>
<p>redis通过字典保存数据库中的所有键值对，我们称之为键空间(key space)。键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种redis对象。</li>
</ul>
<p><strong>2. redis数据库支持增删改查(curd)操作：</strong></p>
<p><strong>①.添加新键</strong><br>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间的字典里，其中键为字符串对象，值为任意一种类型的redis对象。<br><strong>②.删除键</strong><br>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。<br><strong>③.更新键</strong><br>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象类型的不同，更新的方法也不同。<br><strong>④.查询键</strong><br>对一个数据库键进行查询，实际上就是在键空间中取出键所对应的值对象，根据值对象类型的不同，取值的方法也不同。  </p>
<p>除了以上操作外，redis还有很多针对数据库本身的命令，也是通过对键空间进行处理来完成的。  </p>
<p><strong>3. 读写键空间时的维护操作：</strong><br>当使用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的操作，其中包括：</p>
<ul>
<li>在读取一个键之后（读写操作都需要先对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中(hit)次数或不命中(miss)次数，这两个值可以在<code>INFO stat</code>命令的<code>keyspace_hits</code>和<code>keyspace_misses</code>属性中查看。</li>
<li>在读取一个键之后，服务器会更新键的LRU或LFU时间，这个值用于计算键的闲置时间，可以使用<code>OBJECT idletime [key]</code>命令查看key的闲置时间。</li>
<li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期的键，然后才执行余下操作。</li>
<li>如果有客户端使用<code>WATCH</code>命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏(dirty)，从而让事务程序注意到这个键已经被修改过。</li>
<li>服务器每次修改一个键后，都会对脏(dirty)键计数器的值增 1，这个计数器会触发服务器的持久化以及复制操作。</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器会按配置发送相应的数据库通知。</li>
</ul>
<p><strong>4. 设置键的生存时间或过期时间：</strong><br>Redis有四个命令可以设置键的过期时间，包括expire,pexpire,expireat,pexpireat，不过这四个命令最后都会转化成pexpireat命令来实现。<br>RedisDb中，使用一个字典expires来存储带有过期时间的键，称之为过期字典。</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象。</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间（精度为毫秒的unix时间戳）。</li>
</ul>
<p><strong>5. 过期键的删除策略：</strong><br>如果一个键过期了，那么它什么时候被删除呢？redis有三种删除策略：</p>
<ol>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行删除操作。</li>
<li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，执行删除操作，如果没过期，则返回该键。</li>
<li>定期删除：每隔一段时间，程序对数据库进行检查，删除过期的键。至于要删除多少过期键，以及要检查多少个数据库，则由算法实现。</li>
</ol>
<p>这几种方式各有利弊。</p>
<ol>
<li>定时删除对内存最为友好，当键过期时，会立即删除该键，释放内存。不过对CPU最不友好，因为每一个键都需要创建一个定时器，这种行为可能会占用相当一部分的CPU时间。此外，创建定时器需要用到Redis服务器中的时间时间，而当前时间时间的实现方式-无序链表查找一个事件的时间复杂度为O(N)，不能高效地处理大量时间事件。</li>
<li>惰性删除策略对CPU是最友好的，但是对内存最不友好。如果一个键已经过期，这个键又保留在数据库中，那么内存就会一直占用不释放，由db.c/expireIfNeeded()函数实现惰性删除。</li>
<li>定期删除算是前两种策略的一种整合和折中，定期策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率减少删除操作对CPU时间的影响。定期删除过期键可以有效地减少因为过期键带来的内存浪费。</li>
</ol>
<p>下面我们通过代码来看看redis数据库的实现吧。</p>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redisServer</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;    <span class="comment">/* 数据库数组*/</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;      <span class="comment">/* 数据库的总个数 */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redisDb</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库的键空间 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期字典 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* 存放所有造成阻塞的键及其客户端 */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* 存放push操作添加的造成阻塞的键，便于解阻塞 */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* 被watch命令监控的键和相应的客户端，用于multi/exec */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* 数据库编号 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 平均生存时间 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* 要尝试逐项进行碎片整理的密钥名称列表 */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeExpire</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 移除key的过期时间，当只有在db-&gt;dict中存在key时，才会移除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> lazy)</span></span>; <span class="comment">// 将过期key的del操作通知给slaves和AOF文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 被动的删除过期key。当用户对key进行操作时，首先判断key是否过期，过期则删除返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 返回key的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(client *c, redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span></span>; <span class="comment">// 设置key的过期时间</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// db中查找元素的底层实现</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 调用lookupKeyReadWithFlags，需要修改键的访问时间</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 调用lookupKeyWriteWithFlags，需要修改键的访问时间</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyReadOrReply</span><span class="params">(client *c, robj *key, robj *reply)</span></span>; <span class="comment">// 调用lookupKeyRead，未找到则将描述信息加入到缓冲区输出到客户端</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteOrReply</span><span class="params">(client *c, robj *key, robj *reply)</span></span>; <span class="comment">// 调用lookupKeyWrite，未找到则将描述信息加入到缓冲区输出到客户端</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 首先从过期字典中查找键是否过期，未过期调用lookupKey来查找元素，并更新键的命中或不命中的属性</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 首先从过期字典中查找键是否过期并调用lookupKey来查找元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 键空间增加键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 重写键的值，继承源键的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genericSetKey</span><span class="params">(redisDb *db, robj *key, robj *val, <span class="keyword">int</span> keepttl)</span></span>; <span class="comment">// 高阶函数，如果key不存在则增加，key存在则修改值，可选择是否删除过期字典中的key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 调用genericSetKey，并从过期字典中删除该key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbExists</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// key是否存在</span></span><br><span class="line"><span class="function">robj *<span class="title">dbRandomKey</span><span class="params">(redisDb *db)</span></span>; <span class="comment">// 随机获取key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 同步删除键空间和过期字典中的key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 通过redis延迟删除配置，选择dbSyncDelete或者dbAsyncDelete</span></span><br><span class="line"><span class="function">robj *<span class="title">dbUnshareStringValue</span><span class="params">(redisDb *db, robj *key, robj *o)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">emptyDb</span><span class="params">(<span class="keyword">int</span> dbnum, <span class="keyword">int</span> flags, <span class="keyword">void</span>(callback)(<span class="keyword">void</span>*))</span></span>; <span class="comment">// 调用emptyDbGeneric清空数据库</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">emptyDbGeneric</span><span class="params">(redisDb *dbarray, <span class="keyword">int</span> dbnum, <span class="keyword">int</span> flags, <span class="keyword">void</span>(callback)(<span class="keyword">void</span>*))</span></span>; <span class="comment">// 清空数据库</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAllDataAndResetRDB</span><span class="params">(<span class="keyword">int</span> flags)</span></span>; <span class="comment">// 清空所有的数据库并重置</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dbTotalServerKeyCount</span><span class="params">()</span></span>; <span class="comment">// 统计所有数据库的键数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(client *c, <span class="keyword">int</span> id)</span></span>; <span class="comment">// 选择数据库</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 每次修改键空间的键时，都会调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalFlushedDb</span><span class="params">(<span class="keyword">int</span> dbid)</span></span>; <span class="comment">// 清空数据库时调用此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// redis-cluster集群 slot槽点相关函数，将在cluster中解释</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot, robj **keys, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">countKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">delKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verifyClusterConfigWithData</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> cursor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseScanCursorOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> *cursor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slotToKeyAdd</span><span class="params">(robj *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slotToKeyDel</span><span class="params">(robj *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slotToKeyFlush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 异步删除过期key，放入惰性删除列表中，将在另一个bio.c线程中回收</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emptyDbAsync</span><span class="params">(redisDb *db)</span></span>; <span class="comment">// 异步清空数据库，创建新库，将旧库放入惰性删除列表中，将在另一个bio.c线程中回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* API to get key arguments from commands */</span></span><br><span class="line"><span class="comment">// 一些命令的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getKeysFromCommand</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>; <span class="comment">// 获取所有的 keyIndex</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getKeysFreeResult</span><span class="params">(<span class="keyword">int</span> *result)</span></span>; <span class="comment">// 释放keyindex</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">zunionInterGetKeys</span><span class="params">(struct redisCommand *cmd,robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">evalGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">sortGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">migrateGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">georadiusGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">xreadGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">memoryGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>3-database</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-AOF持久化</title>
    <url>/Redis/3-database/redis-parse-aof/</url>
    <content><![CDATA[<p>源码位置：aof.c/rio.c/rio.h</p>
<p><strong>1. 前言</strong><br>除了RDB持久化功能以外，Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis所执行的写命令来记录数据库状态的。</p>
<a id="more"></a>
<p><strong>2. RDB和AOF的区别</strong><br>antirez 在《Redis 持久化解密》一文中讲述了 RDB 和 AOF 各自的优缺点：</p>
<ul>
<li>RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据备份。非常适合备份，全量复制等场景。比如每6小时执行 bgsave 备份，并把 RDB 文件拷贝到远程机器或者文件系统中，用于灾难恢复。</li>
<li>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</li>
<li>RDB 方式数据没办法做到实时持久化，而 AOF 方式可以做到。</li>
</ul>
<p><strong>3. AOF持久化的实现</strong><br><img src="https://i.loli.net/2020/10/29/92WBXYbOpDcl7aJ.png" alt="aof1.png"><br>如上图所示，AOF 持久化功能的实现可以分为命令追加( append )、文件写入( write )、文件同步( sync )、文件重写(rewrite)和重启加载(load)。其流程如下：</p>
<ul>
<li>所有的写命令会追加到 AOF 缓冲中。</li>
<li>AOF 缓冲区根据对应的策略向硬盘进行同步操作。</li>
<li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li>当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ul>
<p><strong>命令追加</strong><br>当 AOF 持久化功能处于打开状态（配置文件中：<code>appendonly yes</code>）时，Redis 在执行完一个写命令之后，调用<code>feedAppendOnlyFile</code>函数，以协议格式(也就是RESP，即 Redis 客户端和服务器交互的通信协议 )将被执行的写命令追加到 Redis 服务端维护的 AOF 缓冲区末尾（sds类型变量：<code>aof_buf</code>）。</p>
<p>比如说 SET mykey myvalue 这条命令就以如下格式记录到 AOF 缓冲中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>文件写入与同步</strong><br>Redis的服务器进程是一个事件循环，文件事件负责处理客户端的命令请求，而时间事件负责执行<code>serverCron</code>函数这样的定时运行的函数。在处理文件事件执行写命令，使得命令被追加到<code>aof_buf</code>中，然后在处理时间事件执行<code>serverCron</code>函数会调用<code>flushAppendOnlyFile</code>函数进行文件的写入和同步。<br>flushAppendOnlyFile函数的行为由服务器配置的<code>appendfsync</code>选项的值决定，该选项有三个可选值，分别是<code>always</code>、<code>everysec</code> 和 <code>no</code>：</p>
<ul>
<li><strong>always： 每执行一个命令保存一次。</strong> Redis 在每个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件，并且同步 AOF 文件，所以 always 的效率是 appendfsync 选项三个值当中最差的一个，但从安全性来说，也是最安全的。当发生故障停机时，AOF 持久化也只会丢失一个事件循环中所产生的命令数据。</li>
<li><strong>everysec： 每一秒钟保存一次。</strong> Redis 在每个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件中，并且每隔一秒就要在子线程中对 AOF 文件进行一次同步。从效率上看，该模式足够快。当发生故障停机时，只会丢失一秒钟的命令数据。</li>
<li><strong>no：不保存。</strong> 将aof_buf中的所有内容写入到aof文件，但不对aof文件同步，<code>fsync</code> 由操作系统执行。</li>
</ul>
<p>Redis的 <code>write</code> 操作会触发延迟写（delayed write）机制，在同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</p>
<blockquote>
<p><strong>延迟写机制：</strong> 传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。 当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则 并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时， 再将该缓冲排入到输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式就被称为延迟写。</p>
</blockquote>
<p>而 <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</p>
<p>三种AOF模式在安全性和性能方面的区别如下：</p>
<ul>
<li><strong>no：</strong> <code>write</code> 和 <code>fsync</code> 都由主进程执行，两个操作都会阻塞主进程。因为 <code>fsync</code> 操作只会在AOF 关闭或 Redis 关闭时执行，或者由操作系统触发。所以当系统故障宕机，那么丢失数据的数量由操作系统的缓存冲洗策略决定。</li>
<li><strong>always：</strong> 该模式的安全性最高，但性能也是最差的，因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后，才能继续处理请求。</li>
<li><strong>everysec：</strong> <code>write</code> 操作由主进程执行，阻塞主进程。<code>fsync</code> 操作由子线程执行，不直接阻塞主进程，但<code>fsync</code> 操作完成的快慢会影响 <code>write</code> 操作的阻塞时长。因为是一秒执行一次，所以它的安全性高于<code>no</code>模式，系统故障宕机将会丢失一秒钟的命令数据。</li>
</ul>
<p><code>appendfsync</code> 的三个值代表着三种不同的调用 <code>fsync</code> 的策略。调用 <code>fsync</code> 周期越频繁，读写效率就越差，但是相应的安全性越高，发生宕机时丢失的数据越少。</p>
<p><strong>4. AOF数据恢复</strong><br>AOF文件中包含了重建Redis数据所需的所有命令，所以Redis只要读入并重新执行一遍 AOF 文件里边保存的写命令，就可以还原 Redis 关闭之前的状态。<br><img src="https://i.loli.net/2020/10/29/RvlhedCqP6ywjNb.png" alt="aof2.png"></p>
<p><strong>5. AOF重写</strong><br>因为AOF持久化是通过保存被执行的写命令来记录Redis状态的，所以随着Redis长时间运行，AOF文件中的内容越来越多，文件的体积也会越来越大，如果不加以控制，Redis通过AOF文件还原数据库需要的时间将会变得很久，同时AOF文件很可能会对Redis甚至宿主主机造成影响。<br>为了解决上诉问题，Redis提供了AOF文件重写（rewrite）功能。通过该功能，Redis 可以创建一个新的 AOF 文件来替代现有的 AOF 文件。新旧两个 AOF 文件所保存的 Redis 状态相同，但是新的 AOF 文件不会包含任何浪费空间的冗余命令，所以新 AOF 文件的体积通常比旧 AOF 文件的体积要小得很多。</p>
<blockquote>
<p>例如：<br>重写前AOF文件命令记录:<br>RPUSH list “A”,”B”<br>RPUSH list “C”,”D”<br>LPOP list<br>LPOP list<br>RPUSH list “E”,”F”</p>
<p>重写后AOF文件命令记录：<br>RPUSH list “C”,”D”,”E”,”F”</p>
</blockquote>
<p>如上所示，重写前，AOF文件要保存5条命令，重写后只需要保存一条，所以重写后的文件要小很多。</p>
<p><strong>AOF重写实现</strong><br>AOF文件重写通过 <code>rewriteAppendOnlyFileBackground()</code> 实现，重写不需要对现有的AOF文件进行任何读取、分析或者写入操作，而是读取服务器当前的数据库状态来实现的（<code>rewriteAppendOnlyFileRio()</code>）。首先从数据库中读取键对应的值，然后用一条命令去记录键值对，代替之前的多条命令，这就是AOF重写功能实现。</p>
<p>在实际过程中，为了避免在执行命令时造成客户端输入缓冲区溢出，AOF 重写在处理列表、哈希表、集合和有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果数量超<code>REDIS_AOF_REWRITE_ITEMS_PER_CMD</code> ( 一般为64 )常量，则使用多条命令记录该键的值，而不是一条命令。</p>
<p>AOF重写函数会进行大量的写入操作，调用该函数的线程将被长时间阻塞，所以Redis在子进程中执行AOF重写操作。</p>
<ul>
<li>子进程重写期间，主线程可以继续处理客户端命令请求。</li>
<li>子进程带有主线程的内存数据拷贝副本，这样就可以避免与主进程竞争db-&gt;dict，在不用锁的情况下，也能保证数据的安全性。</li>
</ul>
<p>AOF重写期间，主进程依然能接收处理命令，会对现有的Redis数据库进行修改，从而导致AOF重写后的数据与现有的数据库数据不一致。因此，Redis设置了AOF重写缓冲区，在创建子进程后，主进程每执行一个写命令都会写到缓冲区中。在子进程完成重写后，主进程会将AOF重写缓冲区的数据写入到重写后的AOF文件中，以此保证数据的一致性。</p>
<h2 id="函数主要功能"><a href="#函数主要功能" class="headerlink" title="函数主要功能"></a>函数主要功能</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span></span>; <span class="comment">// 将缓冲区的数据刷入到磁盘文件中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span></span>; <span class="comment">// 将写操作的数据添加到AOF缓冲区末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// AOF文件重写</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span></span>; <span class="comment">// 加载AOF文件恢复数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopAppendOnly</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 停止</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startAppendOnly</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundRewriteDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span></span>; <span class="comment">// 子进程重写完成信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofRewriteBufferReset</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 清空AOF重写缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">aofRewriteBufferSize</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取AOF重写缓冲区的大小</span></span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<p><strong>写操作命令追加到AOF缓冲区：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">    sds buf = sdsempty();</span><br><span class="line">    robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换dbid，追加select命令</span></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">&quot;%d&quot;</span>,dictid);</span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">&quot;*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        server.aof_selected_db = dictid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        <span class="comment">/* 将EXPIRE/PEXPIRE/EXPIREAT转化成PEXPIREAT生成命令协议格式的字符串 */</span></span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</span><br><span class="line">        <span class="comment">/* 将SETEX/PSETEX转换成SET和PEXPIREAT生成命令协议格式的字符串 */</span></span><br><span class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">&quot;SET&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv);</span><br><span class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        robj *exarg = <span class="literal">NULL</span>, *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,argv);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">&quot;ex&quot;</span>)) exarg = argv[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">&quot;px&quot;</span>)) pxarg = argv[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        serverAssert(!(exarg &amp;&amp; pxarg));</span><br><span class="line">        <span class="keyword">if</span> (exarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               exarg);</span><br><span class="line">        <span class="keyword">if</span> (pxarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               pxarg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 将写命令生成命令协议格式的字符串 */</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将命令的协议格式的字符串追加到aof_buf */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前正在做AOF重写，则将命令的协议格式的字符串追加到AOF重写缓存区 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AOF缓冲区的数据刷入到AOF文件中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">            server.aof_fsync_offset != server.aof_current_size &amp;&amp;</span><br><span class="line">            server.unixtime &gt; server.aof_last_fsync &amp;&amp;</span><br><span class="line">            !(sync_in_progress = aofFsyncInProgress())) &#123;</span><br><span class="line">            <span class="keyword">goto</span> try_fsync;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">        <span class="comment">// 如果AOF fsync当前已在BIO线程中进行返回true</span></span><br><span class="line">        sync_in_progress = aofFsyncInProgress();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">        <span class="comment">/* 使用这个append fsync策略，我们进行后台fsync。如果fsync仍在进行中，我们可以尝试将写入延迟几秒钟。 */</span></span><br><span class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_delayed_fsync++;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_flush_sleep &amp;&amp; sdslen(server.aof_buf)) &#123;</span><br><span class="line">        usleep(server.aof_flush_sleep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将aof_buf中的内容写入到AOF文件中</span></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-pending-fsync&quot;</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasActiveChildProcess()) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-active-child&quot;</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-alone&quot;</span>,latency);</span><br><span class="line">    &#125;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;aof-write&quot;</span>,latency);</span><br><span class="line"></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">ssize_t</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">            can_log = <span class="number">1</span>;</span><br><span class="line">            last_write_error_log = server.unixtime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error writing to the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">                server.aof_last_write_errno = errno;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Short write while writing to &quot;</span></span><br><span class="line">                                       <span class="string">&quot;the AOF file: (nwritten=%lld, &quot;</span></span><br><span class="line">                                       <span class="string">&quot;expected=%lld)&quot;</span>,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                    serverLog(LL_WARNING, <span class="string">&quot;Could not remove short write &quot;</span></span><br><span class="line">                             <span class="string">&quot;from the append-only file.  Redis may refuse &quot;</span></span><br><span class="line">                             <span class="string">&quot;to load the AOF the next time it starts.  &quot;</span></span><br><span class="line">                             <span class="string">&quot;ftruncate: %s&quot;</span>, strerror(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nwritten = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_last_write_errno = ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t recover from AOF write error when the AOF fsync policy is &#x27;always&#x27;. Exiting...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            server.aof_last_write_status = C_ERR;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_current_size += nwritten;</span><br><span class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;AOF write error looks solved, Redis can write again.&quot;</span>);</span><br><span class="line">            server.aof_last_write_status = C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server.aof_current_size += nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">        sdsclear(server.aof_buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sdsfree(server.aof_buf);</span><br><span class="line">        server.aof_buf = sdsempty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">try_fsync:</span><br><span class="line">    <span class="comment">// appendfsync为no或者有后台进程在进行aof或rdb，不进行文件同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp; hasActiveChildProcess())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        redis_fsync(server.aof_fd); <span class="comment">/* Let&#x27;s try to get this data on the disk */</span></span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-fsync-always&quot;</span>,latency);</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) &#123;</span><br><span class="line">            aof_background_fsync(server.aof_fd);</span><br><span class="line">            server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        &#125;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AOF重写：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR; <span class="comment">//创建父进程与子进程的管道</span></span><br><span class="line">    openChildInfoPipe();</span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">        <span class="comment">// 通过子进程来重写AOF文件</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            sendChildCOWInfo(CHILD_INFO_TYPE_AOF, <span class="string">&quot;AOF rewrite&quot;</span>);</span><br><span class="line">            exitFromChild(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exitFromChild(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t rewrite append only file in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            aofClosePipes();</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Background append only file rewriting started by pid %d&quot;</span>,childpid);</span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        server.aof_rewrite_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AOF重写实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    rio aof;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> byte;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-%d.aof&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">&quot;Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.aof_child_diff = sdsempty();</span><br><span class="line">    rioInitWithFile(&amp;aof,fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_rewrite_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;aof,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    startSaving(RDBFLAGS_AOF_PREAMBLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_use_rdb_preamble) &#123;</span><br><span class="line">        <span class="keyword">int</span> error;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveRio(&amp;aof,&amp;error,RDBFLAGS_AOF_PREAMBLE,<span class="literal">NULL</span>) == C_ERR) &#123;</span><br><span class="line">            errno = error;</span><br><span class="line">            <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取Redis数据库状态进行重写操作</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据刷入到新的AOF文件中</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从父进程的重写缓冲区获取更多数据，如果20ms内没有新数据，则退出循环 */</span></span><br><span class="line">    <span class="keyword">int</span> nodata = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> start = mstime();</span><br><span class="line">    <span class="keyword">while</span>(mstime()-start &lt; <span class="number">1000</span> &amp;&amp; nodata &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodata++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodata = <span class="number">0</span>;</span><br><span class="line">        aofReadDiffFromParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 请求主进程停止发送差异. */</span></span><br><span class="line">    <span class="keyword">if</span> (write(server.aof_pipe_write_ack_to_parent,<span class="string">&quot;!&quot;</span>,<span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,server.aof_pipe_read_ack_from_parent) != ANET_OK)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">/* 设定10秒超时时间来接受主进程的相应 */</span></span><br><span class="line">    <span class="keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,<span class="number">1</span>,<span class="number">5000</span>) != <span class="number">1</span> ||</span><br><span class="line">        byte != <span class="string">&#x27;!&#x27;</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Parent agreed to stop sending diffs. Finalizing AOF...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取最终差异. */</span></span><br><span class="line">    aofReadDiffFromParent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将接收到的差异写入文件中 */</span></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">&quot;Concatenating %.2f MB of AOF diff received from parent.&quot;</span>,</span><br><span class="line">        (<span class="keyword">double</span>) sdslen(server.aof_child_diff) / (<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保数据不会保留在操作系统的输出缓冲区中 */</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重命名. */</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error moving temp append only file on the final destination: %s&quot;</span>, strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        stopSaving(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;SYNC append only file rewrite performed&quot;</span>);</span><br><span class="line">    stopSaving(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error writing append only file on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    stopSaving(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从AOF文件中恢复数据：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span> *<span class="title">fakeClient</span>;</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redis_stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">int</span> old_aof_state = server.aof_state;</span><br><span class="line">    <span class="keyword">long</span> loops = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> valid_up_to = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> valid_before_multi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal error: can&#x27;t open the append log file for reading: %s&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理长度为0的AOF文件，服务启动后，如果没有写操作，则AOF文件的长度为0，是特殊情况 */</span></span><br><span class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_current_size = <span class="number">0</span>;</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 暂时禁用AOF，以防止读取同一文件的同时，有客户端进行写操作命令 */</span></span><br><span class="line">    server.aof_state = AOF_OFF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建伪客户端</span></span><br><span class="line">    fakeClient = createAOFClient();</span><br><span class="line">    <span class="comment">// 开始加载文件的初始化工作</span></span><br><span class="line">    startLoadingFile(fp, filename, RDBFLAGS_AOF_PREAMBLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查这个AOF文件是否有RDB前导码。在这种情况下，我们需要加载RDB文件，然后继续加载AOF tail. */</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">5</span>]; <span class="comment">/* &quot;REDIS&quot; */</span></span><br><span class="line">    <span class="keyword">if</span> (fread(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rio rdb;</span><br><span class="line"></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Reading RDB preamble from AOF file...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">        <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,RDBFLAGS_AOF_PREAMBLE,<span class="literal">NULL</span>) != C_OK) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Reading the remaining AOF tail...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析AOF文件内容. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> argc, j;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">        robj **argv;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        sds argsds;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Serve the clients from time to time */</span></span><br><span class="line">        <span class="keyword">if</span> (!(loops++ % <span class="number">1000</span>)) &#123;</span><br><span class="line">            loadingProgress(ftello(fp));</span><br><span class="line">            processEventsWhileBlocked();</span><br><span class="line">            processModuleLoadingProgressEvent(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (feof(fp))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        argc = atoi(buf+<span class="number">1</span>); <span class="comment">// 命令的参数个数</span></span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line"></span><br><span class="line">        argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*argc);</span><br><span class="line">        fakeClient-&gt;argc = argc;</span><br><span class="line">        fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">            <span class="comment">/* 解析参数长度. */</span></span><br><span class="line">            <span class="keyword">char</span> *readres = fgets(buf,<span class="keyword">sizeof</span>(buf),fp);</span><br><span class="line">            <span class="keyword">if</span> (readres == <span class="literal">NULL</span> || buf[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">if</span> (readres == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">goto</span> readerr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">goto</span> fmterr;</span><br><span class="line">            &#125;</span><br><span class="line">            len = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            argsds = sdsnewlen(SDS_NOINIT,len);</span><br><span class="line">            <span class="keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                sdsfree(argsds);</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            argv[j] = createObject(OBJ_STRING,argsds);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fread(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j+<span class="number">1</span>; <span class="comment">/* Free up to j. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 执行命令 */</span></span><br><span class="line">        cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Unknown command &#x27;%s&#x27; reading the append only file&quot;</span>,</span><br><span class="line">                (<span class="keyword">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == server.multiCommand) valid_before_multi = valid_up_to;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在伪客户端中执行该命令 */</span></span><br><span class="line">        fakeClient-&gt;cmd = cmd;</span><br><span class="line">        <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">            fakeClient-&gt;cmd-&gt;proc != execCommand)</span><br><span class="line">        &#123;</span><br><span class="line">            queueMultiCommand(fakeClient);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmd-&gt;proc(fakeClient);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverAssert(fakeClient-&gt;bufpos == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     listLength(fakeClient-&gt;reply) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 清理伪客户端中的命令. */</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        fakeClient-&gt;cmd = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_load_truncated) valid_up_to = ftello(fp);</span><br><span class="line">        <span class="keyword">if</span> (server.key_load_delay)</span><br><span class="line">            usleep(server.key_load_delay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Revert incomplete MULTI/EXEC transaction in AOF file&quot;</span>);</span><br><span class="line">        valid_up_to = valid_before_multi;</span><br><span class="line">        <span class="keyword">goto</span> uxeof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">loaded_ok: <span class="comment">/* DB loaded, cleanup and return C_OK to the caller. */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    freeFakeClient(fakeClient);</span><br><span class="line">    server.aof_state = old_aof_state;</span><br><span class="line">    stopLoading(<span class="number">1</span>);</span><br><span class="line">    aofUpdateCurrentSize();</span><br><span class="line">    server.aof_rewrite_base_size = server.aof_current_size;</span><br><span class="line">    server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">readerr: <span class="comment">/* Read error. If feof(fp) is true, fall through to unexpected EOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Unrecoverable error reading the append only file: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">uxeof: <span class="comment">/* Unexpected AOF end of file. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_load_truncated) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Warning: short read while loading the AOF file !!!&quot;</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Truncating the AOF at offset %llu !!!&quot;</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) valid_up_to);</span><br><span class="line">        <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span> || truncate(filename,valid_up_to) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Last valid command offset is invalid&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error truncating the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Make sure the AOF file descriptor points to the end of the</span></span><br><span class="line"><span class="comment">             * file after the truncate call. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_fd != <span class="number">-1</span> &amp;&amp; lseek(server.aof_fd,<span class="number">0</span>,SEEK_END) == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t seek the end of the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;AOF loaded anyway because aof-load-truncated is enabled&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> loaded_ok;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &#x27;aof-load-truncated&#x27; configuration option to yes and restart the server.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fmterr: <span class="comment">/* Format error. */</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>3-database</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-字典dict</title>
    <url>/Redis/1-data-structure/redis-parse-dict/</url>
    <content><![CDATA[<p>源码位置：dict.c/dict.h  </p>
<p>Redis的字典是由两个HashTable（后面简称ht[0]、ht[1]）构成，与其他字典不同的是，当当前的hashtable负载过高时，redis的字典会进行rehash（重新计算hash），rehash的过程是渐进式的，并不会一下子把所有的数据转移到另一张hashtable中，否则那样会造成服务短暂时间内无法使用。<br><a id="more"></a><br><strong>rehash的条件</strong>：当哈希表的结点个数（used）是哈希表中节点链表数（size）的5倍时，将进行rehash。  </p>
<p><strong>rehash的过程</strong>：当满足rehash的条件时，redis将进行expend扩展，扩展的size是ht[0]-&gt;size的2倍。因为是渐进式的rehash，所以redis会初始化ht[1]，给ht[1]分配足够的内存大小（ht[0]-&gt;size* 2 *sizeof(dictEntry*)），将字典的rehashidx的值置为0，并且当前不会进行rehash操作。<br>当用户进行查询、插入、删除时，将进行一个节点的rehash操作。直到ht[0]的节点全部rehash完毕后，删除ht[0]并且把ht[1]指针赋予给ht[0]，rehashidx值将回到-1，直到下次满足rehash的条件。  </p>
<p><strong>确定key的位置（查找、删除、插入操作）</strong>：如果当前正在rehash，则插入到ht[1]中，根据key计算hash值，&amp; sizemask后得到的index（index=hash_value &amp; dict-&gt;ht[table].sizemask）就是该key所在的链表的索引。</p>
<p>Redis中字典的结构：<br><img src="https://i.loli.net/2020/10/29/MYBu7GDHWhObX5T.png" alt="dict.png"></p>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Unused arguments generate annoying warnings... */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_NOTUSED(V) ((void) V)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存了用于操作特定类型键值对的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">// 哈希函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">// 键复制函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj); <span class="comment">// 值复制函数指针</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2); <span class="comment">// 键比较函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key); <span class="comment">// 键析构函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj); <span class="comment">// 值析构函数指针</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"> <span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table; <span class="comment">// 哈希表(字典数组)，俗称桶bucket</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 哈希表大小（字典数组的长度，桶的层数）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 哈希表掩码（值为size-1），通过（hash &amp; sizemask）计算得到哈希表的索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 当前的节点数（键值对数）</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">// 完整的字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// 特定类型的处理函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 2个哈希表</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span> <span class="comment">// 当前未进行rehash时，值为-1，否则为当前rehash的索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span> <span class="comment">// 当前字典的迭代器个数</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d; <span class="comment">// 字典指针</span></span><br><span class="line">    <span class="keyword">long</span> index; <span class="comment">// 索引</span></span><br><span class="line">    <span class="keyword">int</span> table, safe; <span class="comment">// safe为1，则表示是安全的迭代器，迭代期间，可以进行增删改查操作。 table为当前为第几个哈希表</span></span><br><span class="line">    dictEntry *entry, *nextEntry; <span class="comment">// 当前结点指针和下一个结点的指针</span></span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint; <span class="comment">// 不安全迭代器的指纹</span></span><br><span class="line">&#125; dictIterator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(dictScanFunction)</span><span class="params">(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> dictEntry *de)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(dictScanBucketFunction)</span><span class="params">(<span class="keyword">void</span> *privdata, dictEntry **bucketref)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the initial size of every hash table */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HT_INITIAL_SIZE     4  <span class="comment">// 哈希表的链表个数初始化为4</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------- Macros ------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeVal(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;v.val)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetVal(d, entry, _val_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span><br><span class="line">        (entry)-&gt;v.val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        (entry)-&gt;v.val = (_val_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetSignedIntegerVal(entry, _val_) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; (entry)-&gt;v.s64 = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetUnsignedIntegerVal(entry, _val_) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; (entry)-&gt;v.u64 = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetDoubleVal(entry, _val_) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; (entry)-&gt;v.d = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetKey(d, entry, _key_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span><br><span class="line">        (entry)-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        (entry)-&gt;key = (_key_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictCompareKeys(d, key1, key2) \</span></span><br><span class="line">    (((d)-&gt;type-&gt;keyCompare) ? \</span><br><span class="line">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span><br><span class="line">        (key1) == (key2))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetVal(he) ((he)-&gt;v.val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetUnsignedIntegerVal(he) ((he)-&gt;v.u64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetDoubleVal(he) ((he)-&gt;v.d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type, <span class="keyword">void</span> *privDataPtr)</span></span>; <span class="comment">// 创建dict字典</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>; <span class="comment">// 哈希表扩展，当哈希表的冲突率过高时，链表会很长，查询效率降低，所以需要扩展哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>; <span class="comment">// 新增键值对</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span>; <span class="comment">// 新增dictEntity结点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddOrFind</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 查找key的dictEntity结点，如果不存在，则新增</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>; <span class="comment">// 更改val，如果不存在，则增加key-value</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 删除key</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictUnlink</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 删除key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictFreeUnlinkedEntry</span><span class="params">(dict *d, dictEntry *he)</span></span>; <span class="comment">// 释放结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span>; <span class="comment">// 清空字典（释放内存）</span></span><br><span class="line"><span class="function">dictEntry * <span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dictFetchValue</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span>; <span class="comment">// 重新计算size</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span>; <span class="comment">// 获取字典迭代器</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span></span>; <span class="comment">// 获取安全的迭代器</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span>; <span class="comment">// 获取下一个哈希结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span>; <span class="comment">// 释放迭代器</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictGetRandomKey</span><span class="params">(dict *d)</span></span>; <span class="comment">// 获取随机key</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictGetFairRandomKey</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>; <span class="comment">// 获取count个key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictGetStats</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsize, dict *d)</span></span>; <span class="comment">// 获取当前字典的状态</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span><span class="params">(dict *d, <span class="keyword">void</span>(callback)(<span class="keyword">void</span>*))</span></span>; <span class="comment">// 清空字典（不释放内存）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 允许resize，将静态变量dict_can_resize设为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 不允许resize，dict_can_resize为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 进行rehash操作，n为rehash的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span></span>; <span class="comment">// ms时间内进行rehash操作，每次rehash100个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSetHashFunctionSeed</span><span class="params">(<span class="keyword">uint8_t</span> *seed)</span></span>; <span class="comment">// 设置哈希种子，调用默认哈希函数时使用</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">dictGetHashFunctionSeed</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取哈希种子</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> v, dictScanFunction *fn, dictScanBucketFunction *bucketfn, <span class="keyword">void</span> *privdata)</span></span>; <span class="comment">// 扫描字典</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">dictGetHash</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 获取哈希值</span></span><br><span class="line"><span class="function">dictEntry **<span class="title">dictFindEntryRefByPtrAndHash</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *oldptr, <span class="keyword">uint64_t</span> hash)</span></span>; <span class="comment">// 通过hash值和结点指针查找字典中的结点</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-散列对象hash</title>
    <url>/Redis/2-object/redis-parse-hash/</url>
    <content><![CDATA[<p>源码位置：t_hash.c/server.h</p>
<p>hash 对象底层编码方式有两种，<code>ziplist</code>或<code>hashtable</code>。<br>使用 ziplist 编码需要同时满足以下条件：</p>
<ul>
<li>hash 对象保存的键值对的键和值的字符串长度小于 64 字节（可通过 redis.conf 配置：hash_max_ziplist_value）</li>
<li>hash 对象保存的键值对数小于 512 个（可通过 redis.conf 配置：hash_max_ziplist_entries）</li>
</ul>
<a id="more"></a>
<p>让我们来测试一下：<br><img src="https://i.loli.net/2020/10/29/vlXmwHb7Dn2WO8k.png" alt="t_hash_convert1.png"><br>可以看到，当 k2 的 value 长度大于 64 字节时，不满足第一个条件，redis 会将 ziplist 转为 hashtable。<br>第二个条件可以自行测试。</p>
<p>下面介绍一下 hash 对象是如何使用 ziplist 进行存储的：<br>当有新的键值对需要加入 hash 对象中时，程序会先将保存了键的节点推入到压缩列表的表尾，然后再将存有值的节点推入到压缩列表表尾。所以，同一个键值对的两个节点总是紧挨在一起的，键在前，值在后。<br><img src="https://i.loli.net/2020/10/29/lATicx3Z78Degdj.png" alt="t_hash_ziplist.png"></p>
<p>ziplist 的实现方式可查看<a href="../../1-data-structure/redis-parse-ziplist">Redis 源码-压缩列表 ziplist</a>。<br>hashtable 的实现方式可查看<a href="../../1-data-structure/redis-parse-dict">Redis 源码-字典 dict</a>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td>设置 key 指定的哈希集中指定字段的值</td>
<td>O(1)</td>
</tr>
<tr>
<td>HSETNX</td>
<td>只在 key 指定的哈希集中不存在指定的字段时，设置字段的值</td>
<td>O(1)</td>
</tr>
<tr>
<td>HMSET</td>
<td>设置 key 指定的哈希集中指定多个字段的值</td>
<td>O(N)，N 为字段数</td>
</tr>
<tr>
<td>HGET</td>
<td>返回 key 指定的哈希集中该字段所关联的值</td>
<td>O(1)</td>
</tr>
<tr>
<td>HMGET</td>
<td>返回 key 指定的哈希集中指定多个字段的值</td>
<td>O(N)，N 为字段数</td>
</tr>
<tr>
<td>HGETALL</td>
<td>返回 key 指定的哈希集中所有的字段和值</td>
<td>O(N)，N 为 hash 的 size</td>
</tr>
<tr>
<td>HVALS</td>
<td>返回 key 指定的哈希集中所有字段的值</td>
<td>O(N)，N 为 hash 的 size</td>
</tr>
<tr>
<td>HDEL</td>
<td>从 key 指定的哈希集中移除指定的域</td>
<td>O(N)，N 是被删除的字段数量</td>
</tr>
<tr>
<td>HEXISTS</td>
<td>返回 hash 里面 field 是否存在</td>
<td>O(1)</td>
</tr>
<tr>
<td>HKEYS</td>
<td>返回 key 指定的哈希集中所有字段的名字</td>
<td>O(N)，N 为 hash 的 size</td>
</tr>
<tr>
<td>HLEN</td>
<td>返回 key 指定的哈希集包含的字段的数量</td>
<td>O(1)</td>
</tr>
<tr>
<td>HSCAN</td>
<td>用于迭代 Hash 类型中的键值对</td>
<td>O(1)</td>
</tr>
<tr>
<td>HSTRLEN</td>
<td>返回 hash 指定 field 的 value 的字符串长度，如果 hash 或者 field 不存在，返回 0</td>
<td>O(1)</td>
</tr>
<tr>
<td>HINCRBY</td>
<td>增加 key 指定的哈希集中指定字段的数值</td>
<td>O(1)</td>
</tr>
<tr>
<td>HINCRBYFLOAT</td>
<td>为指定 key 的 hash 的 field 字段值执行 float 类型的 increment 加</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hset命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetnxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hsetnx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmsetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hmset命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hget命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmgetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hmget命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetallCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hgetall命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hvalsCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hvals命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdelCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hdel命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexistsCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hexists命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hkeysCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hkeys命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hlenCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hlen命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hscanCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hscan命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hstrlenCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hstrlen命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hincrbyCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hincrby命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hincrbyfloatCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hincrbyfloat命令</span></span><br></pre></td></tr></table></figure>
<h2 id="Redis-命令实现"><a href="#Redis-命令实现" class="headerlink" title="Redis 命令实现"></a>Redis 命令实现</h2><hr>
<p>插入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HSET key field value</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, created = <span class="number">0</span>;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;wrong number of arguments for HMSET&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从db中查找hash对象，如果不存在则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,c-&gt;argc<span class="number">-1</span>); <span class="comment">// 判断是否需要转成hashtable编码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; c-&gt;argc; i += <span class="number">2</span>)</span><br><span class="line">        created += !hashTypeSet(o,c-&gt;argv[i]-&gt;ptr,c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,HASH_SET_COPY); <span class="comment">// 插入键值对</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HMSET (deprecated) and HSET return value is different. */</span></span><br><span class="line">    <span class="keyword">char</span> *cmdname = c-&gt;argv[<span class="number">0</span>]-&gt;ptr;</span><br><span class="line">    <span class="keyword">if</span> (cmdname[<span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span> || cmdname[<span class="number">1</span>] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">/* HSET */</span></span><br><span class="line">        addReplyLongLong(c, created);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* HMSET */</span></span><br><span class="line">        addReply(c, shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_HASH,<span class="string">&quot;hset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeTryConversion</span><span class="params">(robj *o, robj **argv, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != OBJ_ENCODING_ZIPLIST) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sdsEncodedObject(argv[i]) &amp;&amp;</span><br><span class="line">            sdslen(argv[i]-&gt;ptr) &gt; server.hash_max_ziplist_value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果插入的键值对单个字符大于hash_max_ziplist_value（默认64字节），则需要转成hashtable编码</span></span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeConvert</span><span class="params">(robj *o, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        hashTypeConvertZiplist(o, enc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Not implemented&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeConvertZiplist</span><span class="params">(robj *o, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    serverAssert(o-&gt;encoding == OBJ_ENCODING_ZIPLIST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="comment">/* Nothing to do... */</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enc == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        hashTypeIterator *hi;</span><br><span class="line">        dict *dict;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        hi = hashTypeInitIterator(o); <span class="comment">// 获取hash对象（不同编码的）迭代器</span></span><br><span class="line">        dict = dictCreate(&amp;hashDictType, <span class="literal">NULL</span>); <span class="comment">// 创建字典</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历ziplist取出键值对并存入dict中</span></span><br><span class="line">        <span class="keyword">while</span> (hashTypeNext(hi) != C_ERR) &#123;</span><br><span class="line">            sds key, value;</span><br><span class="line"></span><br><span class="line">            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);</span><br><span class="line">            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);</span><br><span class="line">            ret = dictAdd(dict, key, value);</span><br><span class="line">            <span class="keyword">if</span> (ret != DICT_OK) &#123;</span><br><span class="line">                serverLogHexDump(LL_WARNING,<span class="string">&quot;ziplist with dup elements dump&quot;</span>,</span><br><span class="line">                    o-&gt;ptr,ziplistBlobLen(o-&gt;ptr));</span><br><span class="line">                serverPanic(<span class="string">&quot;Ziplist corruption detected&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTypeReleaseIterator(hi);</span><br><span class="line">        zfree(o-&gt;ptr);</span><br><span class="line">        o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">        o-&gt;ptr = dict;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeSet</span><span class="params">(robj *o, sds field, sds value, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123; <span class="comment">// ziplist操作</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 查找是否存在field，如果存在，则更新value，不存在则将键值对推入ziplist尾部</span></span><br><span class="line">            fptr = ziplistFind(fptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Grab pointer to the value (fptr points to the field) */</span></span><br><span class="line">                vptr = ziplistNext(zl, fptr);</span><br><span class="line">                serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">                update = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Delete value */</span></span><br><span class="line">                zl = ziplistDelete(zl, &amp;vptr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Insert new value */</span></span><br><span class="line">                zl = ziplistInsert(zl, vptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value,</span><br><span class="line">                        sdslen(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!update) &#123; <span class="comment">// 不存在则将键值对推入ziplist尾部</span></span><br><span class="line">            <span class="comment">/* Push new field/value pair onto the tail of the ziplist */</span></span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value, sdslen(value),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;ptr = zl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the ziplist needs to be converted to a hash table */</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries) <span class="comment">// 插入键值对后，判断是否需要转换为hashtable编码</span></span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// hashtable操作</span></span><br><span class="line">        dictEntry *de = dictFind(o-&gt;ptr,field); <span class="comment">// 查找dict中是否存在field</span></span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            sdsfree(dictGetVal(de));</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                dictGetVal(de) = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 存在则更新value</span></span><br><span class="line">                dictGetVal(de) = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            update = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sds f,v;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD) &#123;</span><br><span class="line">                f = field;</span><br><span class="line">                field = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = sdsdup(field);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                v = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            dictAdd(o-&gt;ptr,f,v); <span class="comment">// 不存在则插入一条键值对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free SDS strings we did not referenced elsewhere if the flags</span></span><br><span class="line"><span class="comment">     * want this function to be responsible. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD &amp;&amp; field) sdsfree(field);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE &amp;&amp; value) sdsfree(value);</span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他与 hset 相关的命令不做代码解析了，可以自行查看源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HSETNX key field value</span><br><span class="line">HMSET key field value [field value ...]</span><br></pre></td></tr></table></figure>
<hr>
<p>获取命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 很简单，基本上就是调用ziplist或dict的find接口获取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.null[c-&gt;resp])) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_HASH)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    addHashFieldToReply(c, o, c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addHashFieldToReply</span><span class="params">(client *c, robj *o, sds field)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReplyNull(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen = UINT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vll = LLONG_MAX;</span><br><span class="line"></span><br><span class="line">        ret = hashTypeGetFromZiplist(o, field, &amp;vstr, &amp;vlen, &amp;vll);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                addReplyBulkCBuffer(c, vstr, vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkLongLong(c, vll);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        sds value = hashTypeGetFromHashTable(o, field);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyBulkCBuffer(c, value, sdslen(value));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他与 hset 相关的命令不做代码解析了，可以自行查看源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure>
<hr>
<p>其他命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HVALS key</span><br><span class="line">HGETALL key</span><br><span class="line">HKEYS key</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hkeysCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    genericHgetallCommand(c,OBJ_HASH_KEY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hvalsCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    genericHgetallCommand(c,OBJ_HASH_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetallCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genericHgetallCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    hashTypeIterator *hi;</span><br><span class="line">    <span class="keyword">int</span> length, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymap[c-&gt;resp]))</span><br><span class="line">        == <span class="literal">NULL</span> || checkType(c,o,OBJ_HASH)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We return a map if the user requested keys and values, like in the</span></span><br><span class="line"><span class="comment">     * HGETALL case. Otherwise to use a flat array makes more sense. */</span></span><br><span class="line">    length = hashTypeLength(o);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; OBJ_HASH_KEY &amp;&amp; flags &amp; OBJ_HASH_VALUE) &#123;</span><br><span class="line">        addReplyMapLen(c, length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyArrayLen(c, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hi = hashTypeInitIterator(o);</span><br><span class="line">    <span class="keyword">while</span> (hashTypeNext(hi) != C_ERR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; OBJ_HASH_KEY) &#123;</span><br><span class="line">            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; OBJ_HASH_VALUE) &#123;</span><br><span class="line">            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashTypeReleaseIterator(hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we returned the right number of elements. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; OBJ_HASH_KEY &amp;&amp; flags &amp; OBJ_HASH_VALUE) count /= <span class="number">2</span>;</span><br><span class="line">    serverAssert(count == length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩余的命令不做代码解析了，可自行查看源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HEXISTS key field</span><br><span class="line">HINCRBY key field increment</span><br><span class="line">HINCRBYFLOAT key field increment</span><br><span class="line">HLEN key</span><br><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">HSTRLEN key field</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>2-object</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-事件驱动</title>
    <url>/Redis/4-net/redis-parse-event/</url>
    <content><![CDATA[<p>源码位置：ae.c/ae.h/ae_evport.c/ae_epoll.c/ae_kqueue.c/ae_select.c</p>
<p><strong>1. 简介</strong><br>Redis 是一个事件驱动的内存数据库，服务器需要处理两种类型的事件：</p>
<ul>
<li>文本（IO）事件<code>AE_FILE_EVENTS</code></li>
<li>时间事件<code>AE_TIME_EVENTS</code></li>
</ul>
<a id="more"></a>
<p><strong>2. 文本（IO）事件</strong><br>Redis是基于 Reactor 模式开发了自己的网络事件处理器，这个处理器被称为文件事件处理器。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）模型来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用模型来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。<br>优势：</p>
<ul>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</li>
<li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作。</li>
<li>使用多路I/O复用模型，非阻塞IO。</li>
</ul>
<p>Redis提供了4中 I/O 多路复用的方式，其性能由高到低依次是：<code>evport</code> -&gt; <code>epoll</code> -&gt; <code>kqueue</code> -&gt; <code>select</code>。<br>不同的平台使用了不同的实现方式，比如 epoll 和 select 可以用于Linux平台，kqueue 用于MacOS平台，select 用于Windows平台，evport 用于Solaris平台。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_select.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>一般情况下，Redis服务端都是部署在Linux系统上的，所以本文内容就只解析Redis是怎么利用epoll实现 I/O 多路复用的吧。</p>
<p><strong>epoll：</strong><br>epoll相关的接口实现都封装在了ae_epoll.c中，主要提供了以下几个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 调用epoll_create创建epoll实例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span></span>; <span class="comment">// 重新设置epoll_event的大小</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 释放实例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>; <span class="comment">// 当有新的客户端连接时，将新的fd注册到epoll实例中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> delmask)</span></span>; <span class="comment">// 当有客户端断开连接时，将epoll实例中该客户端的fd删除</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span></span>; <span class="comment">// 调用epoll_wait获取客户端产生的io事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">aeApiName</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;epoll&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>在redis.h/redisServer 结构中，保存着基于事件驱动的程序状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    aeEventLoop *el;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* 当前注册的最大fd */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* 最大fd数 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* 用于检测系统时钟偏差 */</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* 注册事件 */</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* 触发事件 */</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line">    <span class="keyword">int</span> stop;</span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* 用于轮询特定于API的数据 */</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line">    aeBeforeSleepProc *aftersleep;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>
<p>Redis服务器在启动时，首先会创建事件轮询器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据不同平台调用不同的 I/O 多路复用模型</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完成后，开始事件轮询主循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件的调度和执行函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果不处理时间事件或文本时间，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意，只要我们想处理时间事件，即使没有要处理的文件事件，我们也要调用select（），以便在下一个时间事件准备好触发之前休眠 */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            <span class="comment">// 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算剩余时间 */</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms =</span><br><span class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">                shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果我们必须检查事件，但由于AE_DONT_WAIT而需要尽快返回，我们需要将超时设置为0 */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 等待事件触发或者超时 */</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 阻塞后处理函数 */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果设置了AE_BARRIER标志，我们优先处理写事件 */</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理写事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果需要反转读写处理顺序，处理完写事件后，可以处理读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理时间事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* 返回处理的文本/时间事件数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 时间事件</strong><br>Redis有很多操作需要在给定的时间点进行处理，时间事件就是对这类定时任务的抽象。<br>先看看时间事件的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* 时间事件唯一标识符 */</span></span><br><span class="line">    <span class="comment">/* 事件的到达时间 */</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    <span class="comment">/* 事件处理函数 */</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    <span class="comment">/* 事件释放函数 */</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="comment">/* 多路复用库的私有数据 */</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line">    <span class="comment">/* 指向前、后两个时间事件结构，形成双向链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure>
<p>处理时间事件的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</span><br><span class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 记录最新一次执行这个函数的时间，用于处理系统时间被修改产生的问题 */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span>(te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 2. 遍历链表找出所有 when_sec 和 when_ms 小于现在时间的事件。 */</span></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果当前的事件被设置为删除，则删除该事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</span><br><span class="line">            aeTimeEvent *next = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;prev)</span><br><span class="line">                te-&gt;prev-&gt;next = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;next)</span><br><span class="line">                te-&gt;next-&gt;prev = te-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line">            zfree(te);</span><br><span class="line">            te = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            <span class="comment">/* 3. 执行事件对应的处理函数 */</span></span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">/* 4. 检查事件类型，如果是周期事件则刷新该事件下一次的执行事件，否则从列表中删除事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 总结</strong><br>为什么单线程的Redis会这么快？</p>
<ul>
<li>Redis是完全基于内存的数据库，绝大部分请求是纯粹的内存操作，非常快速。</li>
<li>Redis由C语言编写，数据结构简单，对数据的操作也简单，Redis中的数据结构是专门设计的。</li>
<li>Redis采用单线程，保证了数据操作的原子性，不存在多进程或者多线程导致切换而消耗CPU，避免了不必要的上下文切换和竞争条件，不存在加/解锁的操作，不用考虑可能出现的死锁导致性能消耗。</li>
<li>使用 I/O 多路复用模型，非阻塞IO，可以处理并发的连接。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
        <category>4-net</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-整数集合intset</title>
    <url>/Redis/1-data-structure/redis-parse-intset/</url>
    <content><![CDATA[<p>源码位置：intset.c/intset.h  </p>
<p>intset用来实现redis的set对象的数据结构之一（当元素较少且为数字类型时）。<br>为了节省内存的使用，创建intset的时候，使用最小的int类型（int16_t），当插入的整数大于int16_t时，将会进行对应的字节提升（int32_t或者int64_t），这种提升是不可逆的。<br><a id="more"></a><br><strong>特点：</strong>  </p>
<ol>
<li>元素类型只有数字。</li>
<li>元素有三种类型，int16_t, int32_t, int64_t</li>
<li>元素有序且不可重复</li>
<li>内存连续，类似数组。</li>
</ol>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 编码类型 int16_t、int32_t、int64_t</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 长度 最大长度:2^32</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">// 柔性数组</span></span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建空的整数集合</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span></span>;</span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetFind</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">intsetRandom</span><span class="params">(intset *is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetGet</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">intsetLen</span><span class="params">(<span class="keyword">const</span> intset *is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">intsetBlobLen</span><span class="params">(intset *is)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<p><strong>私有函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断数值类型</span></span><br><span class="line"><span class="comment">/* Return the required encoding for the provided value. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取intset指定位置的值</span></span><br><span class="line"><span class="comment">/* Return the value at pos, given an encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGetEncoded(intset *is, <span class="keyword">int</span> pos, <span class="keyword">uint8_t</span> enc) &#123;</span><br><span class="line">    <span class="keyword">int64_t</span> v64;</span><br><span class="line">    <span class="keyword">int32_t</span> v32;</span><br><span class="line">    <span class="keyword">int16_t</span> v16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == INTSET_ENC_INT64) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v64,((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v64));</span><br><span class="line">        memrev64ifbe(&amp;v64);</span><br><span class="line">        <span class="keyword">return</span> v64;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enc == INTSET_ENC_INT32) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v32,((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v32));</span><br><span class="line">        memrev32ifbe(&amp;v32);</span><br><span class="line">        <span class="keyword">return</span> v32;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v16,((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v16));</span><br><span class="line">        memrev16ifbe(&amp;v16);</span><br><span class="line">        <span class="keyword">return</span> v16;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGet(intset *is, <span class="keyword">int</span> pos) &#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGetEncoded(is,pos,intrev32ifbe(is-&gt;encoding));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev64ifbe(((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create an empty intset. */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset)); <span class="comment">// 分配空间</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16); <span class="comment">// 默认元素大小为2字节 intrev32ifbe:如果cpu是大端模式，则转为小端模式</span></span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内存重新分配(删除、新增时)</span></span><br><span class="line"><span class="comment">/* Resize the intset */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>增加：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据value的长度获取其编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="comment">// 如果value的编码大于目前的encoding，需要整体提高encoding的大小</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span></span><br><span class="line">        <span class="comment">// 执行扩大已经插入操作</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate &quot;pos&quot; with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="comment">// 查找元素的位置，如果该元素存在，则插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果元素不存在，则给intset扩容一个元素大小的空间</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素到intset中</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    <span class="comment">// 更新intset的length</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提高intset的encoding大小，并插入元素</span></span><br><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding); <span class="comment">// 当前的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value); <span class="comment">// 新的编码</span></span><br><span class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="comment">// prepend用来确定新value的插入位置：第一个还是最后一个，因为它的encoding比is-&gt;encoding要大，所以它要么比目前所有元素都大，要么比所有元素都小，即插入位置要么第一个，要么最后一个。</span></span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>); <span class="comment">// 扩充一个元素大小的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="comment">// 整体提高encoding大小</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在指定位置插入value</span></span><br><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev64ifbe(((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当插入，或者删除时，需要进行元素挪动，比如，在pos位置插入一个元素时，pos后的所有元素都需要往后移（整体移动）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = intrev32ifbe(is-&gt;length)-from;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="keyword">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="keyword">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据位置查找元素</span></span><br><span class="line"><span class="comment">/* Get the value at the given position. When this position is</span></span><br><span class="line"><span class="comment"> * out of range the function returns 0, when in range it returns 1. */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetGet</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) &#123;</span><br><span class="line">        *value = _intsetGet(is,pos);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断intset中是否有此元素</span></span><br><span class="line"><span class="comment">/* Determine whether a value belongs to this set */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetFind</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search for the position of &quot;value&quot;. Return 1 when the value was found and</span></span><br><span class="line"><span class="comment"> * sets &quot;pos&quot; to the position of the value within the intset. Return 0 when</span></span><br><span class="line"><span class="comment"> * the value is not present in the intset and sets &quot;pos&quot; to the position</span></span><br><span class="line"><span class="comment"> * where &quot;value&quot; can be inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="comment">// 如果intset为空，未查找到value，则pos=0</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="comment">// 如果intset末尾的元素小于value，则pos=length，如果value小于intset首位的元素，则pos=0</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二分法查找元素</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果查找到，返回元素的位置，没找到，就返回具体位置</span></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete integer from intset */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查找到元素的位置pos</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> len = intrev32ifbe(is-&gt;length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We know we can delete */</span></span><br><span class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Overwrite value with tail and update length */</span></span><br><span class="line">        <span class="comment">// 查到元素后，删除该元素，并将pos后的所有元素向前移动</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; (len<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</span><br><span class="line">        is = intsetResize(is,len<span class="number">-1</span>); <span class="comment">// 重新分配intset内存</span></span><br><span class="line">        is-&gt;length = intrev32ifbe(len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-基数统计hyperloglog</title>
    <url>/Redis/1-data-structure/redis-parse-hyperloglog/</url>
    <content><![CDATA[<p>源码位置：hyperloglog.c  </p>
<p>hyperloglog是一种算法，它提供了不精确的去重计数方案。redis的hyperloglog内部维护了16384个桶来记录各自桶的元素数量，当一个元素到来时，它会散列到其中一个桶，以一定的概率影响到这个桶的计数值。因为是概率算法，所以单个桶的计数值并不准确，但是将所有桶的计数值进行调合均值累加起来后，结果就会非常接近真实的计数值。<br><a id="more"></a><br><a href="http://content.research.neustar.biz/blog/hll.html">算法演示</a></p>
<p>当数据量很大时，redis采用密集模式，它将分配了16384个桶，每个桶占用6个bit空间，所以hyperloglog实际占用的空间大约为(16384*6bit/8+16=12304byte≈12k)左右的内存空间就可以统计大量的不同元素的基数。<br>当在计数比较小的时候，大多数桶的计数值都是0，此时redis采用了稀疏模式存储，稀疏模式存储的占用空间远远小于12k字节，而密集模式存储占用的空间固定为12k。  </p>
<p><strong>稀疏模式存储结构：</strong><br><img src="https://i.loli.net/2020/10/29/6NPQeUOmA5xtohY.png" alt="hyperloglog_sparse.png"><br>当连续多个桶的计数值为0时，redis使用一个字节来表示连续有多少个桶的值为0：00xxxxxx。前缀00表示接下来的6bit的整数值<strong>加1</strong>就是连续为0的桶的数量。比如，00101011：表示连续 101011(bin) + 1 = 44(dec)个桶的计数值都为0。6个bit最多表示能表示连续64个桶的值为0，所以redis将用两个字节表示多个多于64个连续0的桶数：01xxxxxx yyyyyyyy，后面的14个bit可以表示连续16384个桶的值为0。这就是hyperloglog数据结构中16384个桶的初始化状态。<br>当连续多个桶的计数值非0时，则使用一个字节：1vvvvvxx表示，其中中间的5个bit vvvvv表示计数值，后面的2个bit xx表示连续几个桶，所以稀疏模式的计数值最大值为11111(bin)+1=32(dec)，最多连续桶为11(bin)+1=4(dec)，当计数值超过32时，redis会立即转为密集模式（不可逆的）。</p>
<p><strong>密集模式存储结构：</strong><br>是由连续的16384个6bit串成的字符串位图。需要注意，普通的字节位序是左边高位右边低位，而在此处的字节位序是左边低位右边高位，所以需要进行倒置。<br><img src="https://i.loli.net/2020/10/29/jmqgJCNyDT658vc.png" alt="hyperloglog_dense_byte.png"><br>以下是密集模式存储结构：<br><img src="https://i.loli.net/2020/10/29/9b6GYFznQHg7wjc.png" alt="hyperloglog_dense.png"><br><a href="https://blog.csdn.net/u013474436/article/details/88945767">参考这篇文章，图文讲解的很清楚</a></p>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">4</span>];      <span class="comment">/* &quot;HYLL&quot;固定值，用于标识hyperloglog键 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> encoding;   <span class="comment">/* HLL_DENSE密集模式 or HLL_SPARSE稀疏模式. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* Reserved for future use, must be zero.保留字段 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* Cached cardinality, little endian.基数缓存，存储上一次计算的基数 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> registers[]; <span class="comment">/* Data bytes. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The cached cardinality MSB is used to signal validity of the cached value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_INVALIDATE_CACHE(hdr) (hdr)-&gt;card[7] |= (1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_VALID_CACHE(hdr) (((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P 14 <span class="comment">/* The greater is P, the smaller the error. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_Q (64-HLL_P) <span class="comment">/* The number of bits of the hash value used for</span></span></span><br><span class="line"><span class="meta"><span class="comment">                            determining the number of leading zeros. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_REGISTERS (1&lt;&lt;HLL_P) <span class="comment">/* With P=14, 16384 registers. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P_MASK (HLL_REGISTERS-1) <span class="comment">/* Mask to index register. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_BITS 6 <span class="comment">/* Enough to count up to 63 leading zeroes. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_REGISTER_MAX ((1&lt;&lt;HLL_BITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_HDR_SIZE sizeof(struct hllhdr) <span class="comment">// hll结构体的大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_SIZE (HLL_HDR_SIZE+((HLL_REGISTERS*HLL_BITS+7)/8)) <span class="comment">// 密集模式占用空间大小（为什么会+7？这里不是很理解）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE 0 <span class="comment">/* Dense encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE 1 <span class="comment">/* Sparse encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_RAW 255 <span class="comment">/* Only used internally, never exposed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_MAX_ENCODING 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *invalid_hll_err = <span class="string">&quot;-INVALIDOBJ Corrupted HLL object detected\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密集模式获取指定桶的数据</span></span><br><span class="line"><span class="comment">/* Store the value of the register at position &#x27;regnum&#x27; into variable &#x27;target&#x27;.</span></span><br><span class="line"><span class="comment"> * &#x27;p&#x27; is an array of unsigned bytes. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_GET_REGISTER(target,p,regnum) do &#123; \</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *_p = (<span class="keyword">uint8_t</span>*) p; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _byte = regnum*HLL_BITS/<span class="number">8</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb = regnum*HLL_BITS&amp;<span class="number">7</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb8 = <span class="number">8</span> - _fb; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b0 = _p[_byte]; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b1 = _p[_byte+<span class="number">1</span>]; \</span><br><span class="line">    target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; HLL_REGISTER_MAX; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密集模式填充指定桶的数据</span></span><br><span class="line"><span class="comment">/* Set the value of the register at position &#x27;regnum&#x27; to &#x27;val&#x27;.</span></span><br><span class="line"><span class="comment"> * &#x27;p&#x27; is an array of unsigned bytes. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_SET_REGISTER(p,regnum,val) do &#123; \</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *_p = (<span class="keyword">uint8_t</span>*) p; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _byte = regnum*HLL_BITS/<span class="number">8</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb = regnum*HLL_BITS&amp;<span class="number">7</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb8 = <span class="number">8</span> - _fb; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _v = val; \</span><br><span class="line">    _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \</span><br><span class="line">    _p[_byte] |= _v &lt;&lt; _fb; \</span><br><span class="line">    _p[_byte+<span class="number">1</span>] &amp;= ~(HLL_REGISTER_MAX &gt;&gt; _fb8); \</span><br><span class="line">    _p[_byte+<span class="number">1</span>] |= _v &gt;&gt; _fb8; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macros to access the sparse representation.</span></span><br><span class="line"><span class="comment"> * The macros parameter is expected to be an uint8_t pointer. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_BIT 0x40 <span class="comment">/* 01xxxxxx */</span> <span class="comment">// 计数值为0的双字节头两位是01</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_BIT 0x80 <span class="comment">/* 1vvvvvxx */</span> <span class="comment">// 计数值非0的单字节头一位是1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_ZERO(p) (((*(p)) &amp; 0xc0) == 0) <span class="comment">/* 00xxxxxx */</span> <span class="comment">// 判断是否是计数值为0的单字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_XZERO(p) (((*(p)) &amp; 0xc0) == HLL_SPARSE_XZERO_BIT) <span class="comment">// 判断是否是计数值为0的双字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_VAL(p) ((*(p)) &amp; HLL_SPARSE_VAL_BIT) <span class="comment">// 判断计数值非0的计数值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_LEN(p) (((*(p)) &amp; 0x3f)+1) <span class="comment">// 获取单字节计数值为0的桶的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_LEN(p) (((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1) <span class="comment">// 获取双字节计数值为0的桶的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_VALUE(p) ((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1) <span class="comment">// 获取计数值非0的计数值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_LEN(p) (((*(p)) &amp; 0x3)+1) <span class="comment">// 获取计数值非0的桶的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_MAX_VALUE 32 <span class="comment">// 计数值最大值为32（超过则转为密集模式）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_MAX_LEN 4 <span class="comment">// 计数值非0的连续桶的个数为4</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_MAX_LEN 64 <span class="comment">// 单字节计数值为0的连续桶的个数为64（连续的桶个数超过64时，用双字节表示）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_MAX_LEN 16384 <span class="comment">// 双字节计数值为0的连续桶的个数为16384</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_SET(p,val,len) do &#123; \</span></span><br><span class="line">    *(p) = (((val)<span class="number">-1</span>)&lt;&lt;<span class="number">2</span>|((len)<span class="number">-1</span>))|HLL_SPARSE_VAL_BIT; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>) <span class="comment">// 设置计数值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_SET(p,len) do &#123; \</span></span><br><span class="line">    *(p) = (len)<span class="number">-1</span>; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>) <span class="comment">// 设置单字节计数值为0的桶的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_SET(p,len) do &#123; \</span></span><br><span class="line">    <span class="keyword">int</span> _l = (len)<span class="number">-1</span>; \</span><br><span class="line">    *(p) = (_l&gt;&gt;<span class="number">8</span>) | HLL_SPARSE_XZERO_BIT; \</span><br><span class="line">    *((p)+<span class="number">1</span>) = (_l&amp;<span class="number">0xff</span>); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>) <span class="comment">// 设置双字节计数值为0的桶的个数（初始化的值： 0111 1111 1111 1111）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_ALPHA_INF 0.721347520444481703680 <span class="comment">/* constant for 0.5/ln(2) */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建hyperloglog对象，默认sparse encoding（稀疏模式），根据需要升级为密集模式</span></span><br><span class="line"><span class="comment">/* Create an HLL object. We always create the HLL using sparse encoding.</span></span><br><span class="line"><span class="comment"> * This will be upgraded to the dense representation as needed. */</span></span><br><span class="line"><span class="function">robj *<span class="title">createHLLObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">uint8_t</span> *p;</span><br><span class="line">     <span class="comment">// sparselen = HLL_HDR_SIZE(16) + 2 = 18, 16是hll的数据结构大小，2个字节是表示01xxxxxx yyyyyyyyy连续16384个桶的计数值为0</span></span><br><span class="line">    <span class="keyword">int</span> sparselen = HLL_HDR_SIZE +</span><br><span class="line">                    (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN<span class="number">-1</span>)) /</span><br><span class="line">                     HLL_SPARSE_XZERO_MAX_LEN)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> aux;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Populate the sparse representation with as many XZERO opcodes as</span></span><br><span class="line"><span class="comment">     * needed to represent all the registers. */</span></span><br><span class="line">    aux = HLL_REGISTERS;</span><br><span class="line">    s = sdsnewlen(<span class="literal">NULL</span>,sparselen);</span><br><span class="line">    p = (<span class="keyword">uint8_t</span>*)s + HLL_HDR_SIZE;</span><br><span class="line">    <span class="keyword">while</span>(aux) &#123;</span><br><span class="line">        <span class="keyword">int</span> xzero = HLL_SPARSE_XZERO_MAX_LEN;</span><br><span class="line">        <span class="keyword">if</span> (xzero &gt; aux) xzero = aux;</span><br><span class="line">        HLL_SPARSE_XZERO_SET(p,xzero);</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">        aux -= xzero;</span><br><span class="line">    &#125;</span><br><span class="line">    serverAssert((p-(<span class="keyword">uint8_t</span>*)s) == sparselen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the actual object. */</span></span><br><span class="line">    o = createObject(OBJ_STRING,s);</span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line">    <span class="built_in">memcpy</span>(hdr-&gt;magic,<span class="string">&quot;HYLL&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    hdr-&gt;encoding = HLL_SPARSE;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>添加元素:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="comment">/* Call hllDenseAdd() or hllSparseAdd() according to the HLL encoding. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllAdd</span><span class="params">(robj *o, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span> = <span class="title">o</span>-&gt;<span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">switch</span>(hdr-&gt;encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> HLL_DENSE: <span class="keyword">return</span> hllDenseAdd(hdr-&gt;registers,ele,elesize); <span class="comment">// 密集模式</span></span><br><span class="line">    <span class="keyword">case</span> HLL_SPARSE: <span class="keyword">return</span> hllSparseAdd(o,ele,elesize); <span class="comment">// 稀疏模式</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Invalid representation. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于计算hash后的值中第一个1出现的位置</span></span><br><span class="line"><span class="comment">/* Given a string element to add to the HyperLogLog, returns the length</span></span><br><span class="line"><span class="comment"> * of the pattern 000..1 of the element hash. As a side effect &#x27;regp&#x27; is</span></span><br><span class="line"><span class="comment"> * set to the register index this element hashes to. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllPatLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize, <span class="keyword">long</span> *regp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> hash, bit, index;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count the number of zeroes starting from bit HLL_REGISTERS</span></span><br><span class="line"><span class="comment">     * (that is a power of two corresponding to the first bit we don&#x27;t use</span></span><br><span class="line"><span class="comment">     * as index). The max run can be 64-P+1 = Q+1 bits.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that the final &quot;1&quot; ending the sequence of zeroes must be</span></span><br><span class="line"><span class="comment">     * included in the count, so if we find &quot;001&quot; the count is 3, and</span></span><br><span class="line"><span class="comment">     * the smallest count possible is no zeroes at all, just a 1 bit</span></span><br><span class="line"><span class="comment">     * at the first position, that is a count of 1.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This may sound like inefficient, but actually in the average case</span></span><br><span class="line"><span class="comment">     * there are high probabilities to find a 1 after a few iterations. */</span></span><br><span class="line">    hash = MurmurHash64A(ele,elesize,<span class="number">0xadc83b19</span>ULL);</span><br><span class="line">    index = hash &amp; HLL_P_MASK; <span class="comment">/* Register index. */</span> <span class="comment">// 计算应该放在哪个桶中，与操作，保证index在16384范围内</span></span><br><span class="line">    hash &gt;&gt;= HLL_P; <span class="comment">/* Remove bits used to address the register. */</span></span><br><span class="line">    hash |= ((<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;HLL_Q); <span class="comment">/* Make sure the loop terminates</span></span><br><span class="line"><span class="comment">                                     and count will be &lt;= Q+1. */</span> <span class="comment">//为了保证循环能够终止</span></span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">    count = <span class="number">1</span>; <span class="comment">/* Initialized to 1 since we count the &quot;00000...1&quot; pattern. */</span></span><br><span class="line">    <span class="comment">// 查找1出现的位置，并计数</span></span><br><span class="line">    <span class="keyword">while</span>((hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *regp = (<span class="keyword">int</span>) index;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>稀疏模式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 稀疏模式添加元素实现</span></span><br><span class="line"><span class="comment">/* &quot;Add&quot; the element in the sparse hyperloglog data structure.</span></span><br><span class="line"><span class="comment"> * Actually nothing is added, but the max 0 pattern counter of the subset</span></span><br><span class="line"><span class="comment"> * the element belongs to is incremented if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is actually a wrapper for hllSparseSet(), it only performs</span></span><br><span class="line"><span class="comment"> * the hashshing of the elmenet to obtain the index and zeros run length. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseAdd</span><span class="params">(robj *o, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">uint8_t</span> count = hllPatLen(ele,elesize,&amp;index);</span><br><span class="line">    <span class="comment">/* Update the register if this element produced a longer run of zeroes. */</span></span><br><span class="line">    <span class="keyword">return</span> hllSparseSet(o,index,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稀疏模式插入，当计数值大于32时，立即转为密集模式并插入</span></span><br><span class="line"><span class="comment">/* Low level function to set the sparse HLL register at &#x27;index&#x27; to the</span></span><br><span class="line"><span class="comment"> * specified value if the current value is smaller than &#x27;count&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The object &#x27;o&#x27; is the String object holding the HLL. The function requires</span></span><br><span class="line"><span class="comment"> * a reference to the object in order to be able to enlarge the string if</span></span><br><span class="line"><span class="comment"> * needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success, the function returns 1 if the cardinality changed, or 0</span></span><br><span class="line"><span class="comment"> * if the register for this element was not updated.</span></span><br><span class="line"><span class="comment"> * On error (if the representation is invalid) -1 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As a side effect the function may promote the HLL representation from</span></span><br><span class="line"><span class="comment"> * sparse to dense: this happens when a register requires to be set to a value</span></span><br><span class="line"><span class="comment"> * not representable with the sparse representation, or when the resulting</span></span><br><span class="line"><span class="comment"> * size would be greater than server.hll_sparse_max_bytes. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseSet</span><span class="params">(robj *o, <span class="keyword">long</span> index, <span class="keyword">uint8_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> oldcount, *sparse, *end, *p, *prev, *next;</span><br><span class="line">    <span class="keyword">long</span> first, span;</span><br><span class="line">    <span class="keyword">long</span> is_zero = <span class="number">0</span>, is_xzero = <span class="number">0</span>, is_val = <span class="number">0</span>, runlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the count is too big to be representable by the sparse representation</span></span><br><span class="line"><span class="comment">     * switch to dense representation. */</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; HLL_SPARSE_VAL_MAX_VALUE) <span class="keyword">goto</span> promote; <span class="comment">// 当计数值大于32时，立即转为密集模式并插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When updating a sparse representation, sometimes we may need to</span></span><br><span class="line"><span class="comment">     * enlarge the buffer for up to 3 bytes in the worst case (XZERO split</span></span><br><span class="line"><span class="comment">     * into XZERO-VAL-XZERO). Make sure there is enough space right now</span></span><br><span class="line"><span class="comment">     * so that the pointers we take during the execution of the function</span></span><br><span class="line"><span class="comment">     * will be valid all the time. */</span></span><br><span class="line">    o-&gt;ptr = sdsMakeRoomFor(o-&gt;ptr,<span class="number">3</span>); <span class="comment">// 扩大3个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: we need to locate the opcode we need to modify to check</span></span><br><span class="line"><span class="comment">     * if a value update is actually needed. */</span></span><br><span class="line">    <span class="comment">// 第一步，需要定位到需要修改的节点位置，判断值是否需要被修改</span></span><br><span class="line">    sparse = p = ((<span class="keyword">uint8_t</span>*)o-&gt;ptr) + HLL_HDR_SIZE;</span><br><span class="line">    end = p + sdslen(o-&gt;ptr) - HLL_HDR_SIZE;</span><br><span class="line"></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    prev = <span class="literal">NULL</span>; <span class="comment">/* Points to previous opcode at the end of the loop. */</span></span><br><span class="line">    next = <span class="literal">NULL</span>; <span class="comment">/* Points to the next opcode at the end of the loop. */</span></span><br><span class="line">    span = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">        <span class="keyword">long</span> oplen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set span to the number of registers covered by this opcode.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is the most performance critical loop of the sparse</span></span><br><span class="line"><span class="comment">         * representation. Sorting the conditionals from the most to the</span></span><br><span class="line"><span class="comment">         * least frequent opcode in many-bytes sparse HLLs is faster. */</span></span><br><span class="line">        oplen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            span = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_VAL(p)) &#123;</span><br><span class="line">            span = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* XZERO. */</span></span><br><span class="line">            span = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">            oplen = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Break if this opcode covers the register as &#x27;index&#x27;. */</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= first+span<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        prev = p;</span><br><span class="line">        p += oplen;</span><br><span class="line">        first += span;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (span == <span class="number">0</span> || p &gt;= end) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Invalid format. */</span></span><br><span class="line"></span><br><span class="line">    next = HLL_SPARSE_IS_XZERO(p) ? p+<span class="number">2</span> : p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (next &gt;= end) next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cache current opcode type to avoid using the macro again and</span></span><br><span class="line"><span class="comment">     * again for something that will not change.</span></span><br><span class="line"><span class="comment">     * Also cache the run-length of the opcode. */</span></span><br><span class="line">    <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">        is_zero = <span class="number">1</span>;</span><br><span class="line">        runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">        is_xzero = <span class="number">1</span>;</span><br><span class="line">        runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        is_val = <span class="number">1</span>;</span><br><span class="line">        runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: After the loop:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#x27;first&#x27; stores to the index of the first register covered</span></span><br><span class="line"><span class="comment">     *  by the current opcode, which is pointed by &#x27;p&#x27;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#x27;next&#x27; ad &#x27;prev&#x27; store respectively the next and previous opcode,</span></span><br><span class="line"><span class="comment">     *  or NULL if the opcode at &#x27;p&#x27; is respectively the last or first.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#x27;span&#x27; is set to the number of registers covered by the current</span></span><br><span class="line"><span class="comment">     *  opcode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * There are different cases in order to update the data structure</span></span><br><span class="line"><span class="comment">     * in place without generating it from scratch:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A) If it is a VAL opcode already set to a value &gt;= our &#x27;count&#x27;</span></span><br><span class="line"><span class="comment">     *    no update is needed, regardless of the VAL run-length field.</span></span><br><span class="line"><span class="comment">     *    In this case PFADD returns 0 since no changes are performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * B) If it is a VAL opcode with len = 1 (representing only our</span></span><br><span class="line"><span class="comment">     *    register) and the value is less than &#x27;count&#x27;, we just update it</span></span><br><span class="line"><span class="comment">     *    since this is a trivial case. */</span></span><br><span class="line">    <span class="keyword">if</span> (is_val) &#123;</span><br><span class="line">        oldcount = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">        <span class="comment">/* Case A. */</span></span><br><span class="line">        <span class="keyword">if</span> (oldcount &gt;= count) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Case B. */</span></span><br><span class="line">        <span class="keyword">if</span> (runlen == <span class="number">1</span>) &#123;</span><br><span class="line">            HLL_SPARSE_VAL_SET(p,count,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">goto</span> updated;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C) Another trivial to handle case is a ZERO opcode with a len of 1.</span></span><br><span class="line"><span class="comment">     * We can just replace it with a VAL opcode with our value and len of 1. */</span></span><br><span class="line">    <span class="keyword">if</span> (is_zero &amp;&amp; runlen == <span class="number">1</span>) &#123;</span><br><span class="line">        HLL_SPARSE_VAL_SET(p,count,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">goto</span> updated;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* D) General case.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The other cases are more complex: our register requires to be updated</span></span><br><span class="line"><span class="comment">     * and is either currently represented by a VAL opcode with len &gt; 1,</span></span><br><span class="line"><span class="comment">     * by a ZERO opcode with len &gt; 1, or by an XZERO opcode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In those cases the original opcode must be split into multiple</span></span><br><span class="line"><span class="comment">     * opcodes. The worst case is an XZERO split in the middle resuling into</span></span><br><span class="line"><span class="comment">     * XZERO - VAL - XZERO, so the resulting sequence max length is</span></span><br><span class="line"><span class="comment">     * 5 bytes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We perform the split writing the new sequence into the &#x27;new&#x27; buffer</span></span><br><span class="line"><span class="comment">     * with &#x27;newlen&#x27; as length. Later the new sequence is inserted in place</span></span><br><span class="line"><span class="comment">     * of the old one, possibly moving what is on the right a few bytes</span></span><br><span class="line"><span class="comment">     * if the new sequence is longer than the older one. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> seq[<span class="number">5</span>], *n = seq;</span><br><span class="line">    <span class="keyword">int</span> last = first+span<span class="number">-1</span>; <span class="comment">/* Last register covered by the sequence. */</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_zero || is_xzero) &#123;</span><br><span class="line">        <span class="comment">/* Handle splitting of ZERO / XZERO. */</span></span><br><span class="line">        <span class="keyword">if</span> (index != first) &#123;</span><br><span class="line">            len = index-first;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; HLL_SPARSE_ZERO_MAX_LEN) &#123;</span><br><span class="line">                HLL_SPARSE_XZERO_SET(n,len);</span><br><span class="line">                n += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HLL_SPARSE_ZERO_SET(n,len);</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HLL_SPARSE_VAL_SET(n,count,<span class="number">1</span>);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span> (index != last) &#123;</span><br><span class="line">            len = last-index;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; HLL_SPARSE_ZERO_MAX_LEN) &#123;</span><br><span class="line">                HLL_SPARSE_XZERO_SET(n,len);</span><br><span class="line">                n += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HLL_SPARSE_ZERO_SET(n,len);</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Handle splitting of VAL. */</span></span><br><span class="line">        <span class="keyword">int</span> curval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != first) &#123;</span><br><span class="line">            len = index-first;</span><br><span class="line">            HLL_SPARSE_VAL_SET(n,curval,len);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        HLL_SPARSE_VAL_SET(n,count,<span class="number">1</span>);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span> (index != last) &#123;</span><br><span class="line">            len = last-index;</span><br><span class="line">            HLL_SPARSE_VAL_SET(n,curval,len);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: substitute the new sequence with the old one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we already allocated space on the sds string</span></span><br><span class="line"><span class="comment">     * calling sdsMakeRoomFor(). */</span></span><br><span class="line">     <span class="keyword">int</span> seqlen = n-seq;</span><br><span class="line">     <span class="keyword">int</span> oldlen = is_xzero ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> deltalen = seqlen-oldlen;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (deltalen &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         sdslen(o-&gt;ptr)+deltalen &gt; server.hll_sparse_max_bytes) <span class="keyword">goto</span> promote;</span><br><span class="line">     <span class="keyword">if</span> (deltalen &amp;&amp; next) memmove(next+deltalen,next,end-next);</span><br><span class="line">     sdsIncrLen(o-&gt;ptr,deltalen);</span><br><span class="line">     <span class="built_in">memcpy</span>(p,seq,seqlen);</span><br><span class="line">     end += deltalen;</span><br><span class="line"></span><br><span class="line">updated:</span><br><span class="line">    <span class="comment">/* Step 4: Merge adjacent values if possible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The representation was updated, however the resulting representation</span></span><br><span class="line"><span class="comment">     * may not be optimal: adjacent VAL opcodes can sometimes be merged into</span></span><br><span class="line"><span class="comment">     * a single one. */</span></span><br><span class="line">    p = prev ? prev : sparse;</span><br><span class="line">    <span class="keyword">int</span> scanlen = <span class="number">5</span>; <span class="comment">/* Scan up to 5 upcodes starting from prev. */</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; end &amp;&amp; scanlen--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">            p += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            p++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We need two adjacent VAL opcodes to try a merge, having</span></span><br><span class="line"><span class="comment">         * the same value, and a len that fits the VAL opcode max len. */</span></span><br><span class="line">        <span class="keyword">if</span> (p+<span class="number">1</span> &lt; end &amp;&amp; HLL_SPARSE_IS_VAL(p+<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">            <span class="keyword">int</span> v2 = HLL_SPARSE_VAL_VALUE(p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = HLL_SPARSE_VAL_LEN(p)+HLL_SPARSE_VAL_LEN(p+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= HLL_SPARSE_VAL_MAX_LEN) &#123;</span><br><span class="line">                    HLL_SPARSE_VAL_SET(p+<span class="number">1</span>,v1,len);</span><br><span class="line">                    memmove(p,p+<span class="number">1</span>,end-p);</span><br><span class="line">                    sdsIncrLen(o-&gt;ptr,<span class="number">-1</span>);</span><br><span class="line">                    end--;</span><br><span class="line">                    <span class="comment">/* After a merge we reiterate without incrementing &#x27;p&#x27;</span></span><br><span class="line"><span class="comment">                     * in order to try to merge the just merged value with</span></span><br><span class="line"><span class="comment">                     * a value on its right. */</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invalidate the cached cardinality. */</span></span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line">    HLL_INVALIDATE_CACHE(hdr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">promote: <span class="comment">/* Promote to dense representation. */</span></span><br><span class="line">    <span class="keyword">if</span> (hllSparseToDense(o) == C_ERR) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Corrupted HLL. */</span></span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to call hllDenseAdd() to perform the operation after the</span></span><br><span class="line"><span class="comment">     * conversion. However the result must be 1, since if we need to</span></span><br><span class="line"><span class="comment">     * convert from sparse to dense a register requires to be updated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that this in turn means that PFADD will make sure the command</span></span><br><span class="line"><span class="comment">     * is propagated to slaves / AOF, so if there is a sparse -&gt; dense</span></span><br><span class="line"><span class="comment">     * conversion, it will be performed in all the slaves as well. */</span></span><br><span class="line">    <span class="keyword">int</span> dense_retval = hllDenseSet(hdr-&gt;registers,index,count);</span><br><span class="line">    serverAssert(dense_retval == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dense_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>稀疏模式转为密集模式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Convert the HLL with sparse representation given as input in its dense</span></span><br><span class="line"><span class="comment"> * representation. Both representations are represented by SDS strings, and</span></span><br><span class="line"><span class="comment"> * the input representation is freed as a side effect.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns C_OK if the sparse representation was valid,</span></span><br><span class="line"><span class="comment"> * otherwise C_ERR is returned if the representation was corrupted. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseToDense</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    sds sparse = o-&gt;ptr, dense;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>, *<span class="title">oldhdr</span> = (<span class="title">struct</span> <span class="title">hllhdr</span>*)<span class="title">sparse</span>;</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, runlen, regval;</span><br><span class="line">    <span class="keyword">uint8_t</span> *p = (<span class="keyword">uint8_t</span>*)sparse, *end = p+sdslen(sparse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the representation is already the right one return ASAP. */</span></span><br><span class="line">    hdr = (struct hllhdr*) sparse;</span><br><span class="line">    <span class="keyword">if</span> (hdr-&gt;encoding == HLL_DENSE) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请HLL_DENSE_SIZE大小的空间用于密集模式</span></span><br><span class="line">    <span class="comment">/* Create a string of the right size filled with zero bytes.</span></span><br><span class="line"><span class="comment">     * Note that the cached cardinality is set to 0 as a side effect</span></span><br><span class="line"><span class="comment">     * that is exactly the cardinality of an empty HLL. */</span></span><br><span class="line">    dense = sdsnewlen(<span class="literal">NULL</span>,HLL_DENSE_SIZE);</span><br><span class="line">    hdr = (struct hllhdr*) dense;</span><br><span class="line">    *hdr = *oldhdr; <span class="comment">/* This will copy the magic and cached cardinality. */</span></span><br><span class="line">    hdr-&gt;encoding = HLL_DENSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将稀疏模式的数据导入到密集模式中</span></span><br><span class="line">    <span class="comment">/* Now read the sparse representation and set non-zero registers</span></span><br><span class="line"><span class="comment">     * accordingly. */</span></span><br><span class="line">    p += HLL_HDR_SIZE;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">            idx += runlen;</span><br><span class="line">            p++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">            runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">            idx += runlen;</span><br><span class="line">            p += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">            regval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">            <span class="keyword">if</span> ((runlen + idx) &gt; HLL_REGISTERS) <span class="keyword">break</span>; <span class="comment">/* Overflow. */</span></span><br><span class="line">            <span class="keyword">while</span>(runlen--) &#123;</span><br><span class="line">                HLL_DENSE_SET_REGISTER(hdr-&gt;registers,idx,regval);</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the sparse representation was valid, we expect to find idx</span></span><br><span class="line"><span class="comment">     * set to HLL_REGISTERS. */</span></span><br><span class="line">    <span class="keyword">if</span> (idx != HLL_REGISTERS) &#123;</span><br><span class="line">        sdsfree(dense);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the old representation and set the new one. */</span></span><br><span class="line">    sdsfree(o-&gt;ptr);</span><br><span class="line">    o-&gt;ptr = dense;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>密集模式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 密集模式添加元素实现</span></span><br><span class="line"><span class="comment">/* &quot;Add&quot; the element in the dense hyperloglog data structure.</span></span><br><span class="line"><span class="comment"> * Actually nothing is added, but the max 0 pattern counter of the subset</span></span><br><span class="line"><span class="comment"> * the element belongs to is incremented if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is just a wrapper to hllDenseSet(), performing the hashing of the</span></span><br><span class="line"><span class="comment"> * element in order to retrieve the index and zero-run count. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllDenseAdd</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">uint8_t</span> count = hllPatLen(ele,elesize,&amp;index);</span><br><span class="line">    <span class="comment">/* Update the register if this element produced a longer run of zeroes. */</span></span><br><span class="line">    <span class="keyword">return</span> hllDenseSet(registers,index,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level function to set the dense HLL register at &#x27;index&#x27; to the</span></span><br><span class="line"><span class="comment"> * specified value if the current value is smaller than &#x27;count&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;registers&#x27; is expected to have room for HLL_REGISTERS plus an</span></span><br><span class="line"><span class="comment"> * additional byte on the right. This requirement is met by sds strings</span></span><br><span class="line"><span class="comment"> * automatically since they are implicitly null terminated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function always succeed, however if as a result of the operation</span></span><br><span class="line"><span class="comment"> * the approximated cardinality changed, 1 is returned. Otherwise 0</span></span><br><span class="line"><span class="comment"> * is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllDenseSet</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">long</span> index, <span class="keyword">uint8_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> oldcount;</span><br><span class="line"></span><br><span class="line">    HLL_DENSE_GET_REGISTER(oldcount,registers,index);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; oldcount) &#123;</span><br><span class="line">        HLL_DENSE_SET_REGISTER(registers,index,count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-列表对象list</title>
    <url>/Redis/2-object/redis-parse-list/</url>
    <content><![CDATA[<p>源码位置：t_list.c/server.h</p>
<p>Redis3.2 版本之前，list 对象底层是由 <a href="../../1-data-structure/redis-parse-ziplist">ziplist</a> 和 <a href="../../1-data-structure/redis-parse-adlist">linkedlist</a> 实现的。3.2 版本之后，底层是由 <a href="../../1-data-structure/redis-parse-quicklist">quicklist</a> 来实现。</p>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPUSH</td>
<td>从列表的最左边插入一个或多个元素（列表为空则创建）</td>
<td>O(1)</td>
</tr>
<tr>
<td>LRUSHX</td>
<td>从列表的最左边插入一个或多个元素（列表为空时不做操作）</td>
<td>O(1)</td>
</tr>
<tr>
<td>RPUSH</td>
<td>从列表的最右边插入一个或多个元素（列表为空则创建）</td>
<td>O(1)</td>
</tr>
<tr>
<td>RPUSHX</td>
<td>从列表的最右边插入一个或多个元素（列表为空时不做操作）</td>
<td>O(1)</td>
</tr>
<tr>
<td>LPOP</td>
<td>从列表的最左边弹出一个元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>RPOP</td>
<td>从列表的最右边弹出一个元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>BLPOP</td>
<td>弹出指定的多个列表中第一个元素（lpop 阻塞版本）</td>
<td>O(1)</td>
</tr>
<tr>
<td>BRPOP</td>
<td>弹出指定的多个列表中最后一个元素（rpop 阻塞版本）</td>
<td>O(1)</td>
</tr>
<tr>
<td>RPOPLPUSH</td>
<td>弹出列表 A 的最后一个元素，并将该元素插入到列表 B 的首位</td>
<td>O(1)</td>
</tr>
<tr>
<td>BRPOPLPUSH</td>
<td>弹出列表 A 的最后一个元素，并将该元素插入到列表 B 的首位（rpoplpush 阻塞版本）</td>
<td>O(1)</td>
</tr>
<tr>
<td>LINDEX</td>
<td>获取索引位置的元素</td>
<td>平均 O(N)，头尾 O(1)</td>
</tr>
<tr>
<td>LRANGE</td>
<td>从列表中获取指定位置的元素</td>
<td>O(S+N)，S 是距离列表头部的偏移位置，N 为指定范围元素数</td>
</tr>
<tr>
<td>LINSERT</td>
<td>在列表中的另一个元素前或后插入一个元素</td>
<td>平均 O(N)，头部 O(1)</td>
</tr>
<tr>
<td>LSET</td>
<td>设置 index 位置元素的值为 value</td>
<td>平均 O(N)，头尾 O(1)</td>
</tr>
<tr>
<td>LTRIM</td>
<td>修剪一个已存在的列表的大小</td>
<td>平均 O(N)</td>
</tr>
<tr>
<td>LREM</td>
<td>从列表中移除 count 个值为 value 的元素</td>
<td>O(N)</td>
</tr>
<tr>
<td>LLEN</td>
<td>获得列表的长度</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blpopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// blpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// brpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpoplpushCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// brpoplpush命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lpush命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// rpush命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lpushx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// rpushx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linsertCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// linsert命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// rpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpoplpushCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// rpoplpush命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// llen命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lindexCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lindex命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrangeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lrange命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltrimCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// ltrim命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lremCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lrem命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lset命令</span></span><br></pre></td></tr></table></figure>
<h2 id="Redis-命令实现"><a href="#Redis-命令实现" class="headerlink" title="Redis 命令实现"></a>Redis 命令实现</h2><hr>
<p>插入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPUSH key value [value ...]</span><br><span class="line">RPUSH key value [value ...]</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    pushGenericCommand(c,LIST_HEAD); <span class="comment">// 列表头部插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    pushGenericCommand(c,LIST_TAIL); <span class="comment">// 列表尾部插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, pushed = <span class="number">0</span>;</span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]); <span class="comment">// db中查找key</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lobj &amp;&amp; lobj-&gt;type != OBJ_LIST) &#123; <span class="comment">// 判断对象类型</span></span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令解析</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">            lobj = createQuicklistObject(); <span class="comment">// 列表不存在，则创建新的列表对象</span></span><br><span class="line">            quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size,</span><br><span class="line">                                server.list_compress_depth); <span class="comment">// 设置列表压缩节点的大小和压缩深度</span></span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj); <span class="comment">// 加入到db中</span></span><br><span class="line">        &#125;</span><br><span class="line">        listTypePush(lobj,c-&gt;argv[j],where); <span class="comment">// 调用quicklistPush函数插入元素</span></span><br><span class="line">        pushed++;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : <span class="number">0</span>)); <span class="comment">// 返回列表长度</span></span><br><span class="line">    <span class="keyword">if</span> (pushed) &#123;</span><br><span class="line">        <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">&quot;lpush&quot;</span> : <span class="string">&quot;rpush&quot;</span>;</span><br><span class="line"></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]); <span class="comment">// 修改信号</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id); <span class="comment">// 事件通知</span></span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += pushed; <span class="comment">// 存储上次保存前所有数据变动的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他与插入相关的命令不做代码解析了，可自行查看源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPUSHX key value <span class="comment">// 如果db中有该列表，则调用quicklistPush插入元素到列表头部，无列表则不做操作返回</span></span><br><span class="line">RPUSHX key value <span class="comment">// 如果db中有该列表，则调用quicklistPush插入元素到列表尾部，无列表则不做操作返回</span></span><br><span class="line">LINSERT key BEFORE|AFTER pivot value <span class="comment">// 使用quicklist迭代器查找到列表中对应的位置，然后在指定位置前或后插入元素</span></span><br><span class="line">RPOPLPUSH source destination <span class="comment">// 调用quicklistPopCustom从列表source中弹出最后一个元素，并调用quicklistPush插入到destination列表中</span></span><br><span class="line">BRPOPLPUSH source destination timeout <span class="comment">// timeout时间内，如果有source列表，则调用rpoplpushCommand函数，否则返回不做操作返回</span></span><br><span class="line">LSET key index value <span class="comment">// 调用quicklistReplaceAtIndex修改指定位置的值</span></span><br></pre></td></tr></table></figure>
<hr>
<p>弹出命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPOP key</span><br><span class="line">RPOP key</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,LIST_HEAD); <span class="comment">// 列表头部弹出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,LIST_TAIL); <span class="comment">// 列表尾部弹出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.null[c-&gt;resp]); <span class="comment">// db中查找key</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    robj *value = listTypePop(o,where); <span class="comment">// 调用quicklistPopCustom弹出指定位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReplyNull(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">&quot;lpop&quot;</span> : <span class="string">&quot;rpop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        addReplyBulk(c,value);</span><br><span class="line">        decrRefCount(value); <span class="comment">// 元素value引用计数自减</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id); <span class="comment">// 事件通知</span></span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                                c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">            dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]); <span class="comment">// 如果列表长度为0，则删除改列表对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他与插入相关的命令不做代码解析了，可自行查看源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BLPOP key [key ...] timeout</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>
<hr>
<p>获取元素命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LINDEX key index</span><br><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LINDEX</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lindexCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.null[c-&gt;resp]);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;index, <span class="literal">NULL</span>) != C_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        quicklistEntry entry;</span><br><span class="line">        <span class="keyword">if</span> (quicklistIndex(o-&gt;ptr, index, &amp;entry)) &#123; <span class="comment">// 获取列表中的指定index位置的元素</span></span><br><span class="line">            <span class="keyword">if</span> (entry.value) &#123;</span><br><span class="line">                value = createStringObject((<span class="keyword">char</span>*)entry.value,entry.sz); <span class="comment">// 创建字符串对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = createStringObjectFromLongLong(entry.longval); <span class="comment">// 创建longlong对象</span></span><br><span class="line">            &#125;</span><br><span class="line">            addReplyBulk(c,value);</span><br><span class="line">            decrRefCount(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRANGE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrangeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> start, end, llen, rangelen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptyarray)) == <span class="literal">NULL</span></span><br><span class="line">         || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    llen = listTypeLength(o); <span class="comment">// 获取列表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将start和end转为正数的索引 */</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        addReply(c,shared.emptyarray);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">    rangelen = (end-start)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the result in form of a multi-bulk reply */</span></span><br><span class="line">    addReplyArrayLen(c,rangelen);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="comment">// 获取列表的迭代器（从start位置开始）</span></span><br><span class="line">        listTypeIterator *iter = listTypeInitIterator(o, start, LIST_TAIL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123; <span class="comment">// 循环遍历获取数据</span></span><br><span class="line">            listTypeEntry entry;</span><br><span class="line">            listTypeNext(iter, &amp;entry);</span><br><span class="line">            quicklistEntry *qe = &amp;entry.entry;</span><br><span class="line">            <span class="keyword">if</span> (qe-&gt;value) &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,qe-&gt;value,qe-&gt;sz);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkLongLong(c,qe-&gt;longval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listTypeReleaseIterator(iter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;List encoding is not QUICKLIST!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>其他命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LTRIM key start stop</span><br><span class="line">LREM key count value</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* LREM count参数：</span></span><br><span class="line"><span class="comment">* count &gt; 0: 从头往尾移除值为 value 的元素。</span></span><br><span class="line"><span class="comment">* count &lt; 0: 从尾往头移除值为 value 的元素。</span></span><br><span class="line"><span class="comment">* count = 0: 移除所有值为 value 的元素。 */</span></span><br><span class="line"></span><br><span class="line">LLEN key</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltrimCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> start, end, llen, ltrim, rtrim;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.ok)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将start和end转为正数的索引</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要修剪的位置</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        <span class="comment">/* Out of range start or start &gt; end result in empty list */</span></span><br><span class="line">        ltrim = llen;</span><br><span class="line">        rtrim = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">        ltrim = start;</span><br><span class="line">        rtrim = llen-end<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉列表中需要修剪的范围</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        quicklistDelRange(o-&gt;ptr,<span class="number">0</span>,ltrim);</span><br><span class="line">        quicklistDelRange(o-&gt;ptr,-rtrim,rtrim);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_LIST,<span class="string">&quot;ltrim&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lremCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *subject, *obj;</span><br><span class="line">    obj = c-&gt;argv[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">long</span> toremove;</span><br><span class="line">    <span class="keyword">long</span> removed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;toremove, <span class="literal">NULL</span>) != C_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    subject = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (subject == <span class="literal">NULL</span> || checkType(c,subject,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    <span class="keyword">if</span> (toremove &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        toremove = -toremove;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">-1</span>,LIST_HEAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,LIST_TAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listTypeEqual(&amp;entry,obj)) &#123;</span><br><span class="line">            listTypeDelete(li, &amp;entry);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            removed++;</span><br><span class="line">            <span class="keyword">if</span> (toremove &amp;&amp; removed == toremove) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listTypeReleaseIterator(li);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,<span class="string">&quot;lrem&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(subject) == <span class="number">0</span>) &#123;</span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addReplyLongLong(c,removed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    addReplyLongLong(c,listTypeLength(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>2-object</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-内存分配zmalloc</title>
    <url>/Redis/1-data-structure/redis-parse-malloc/</url>
    <content><![CDATA[<p>源码位置：zmalloc.c/zmalloc.h  </p>
<p>因为Redis没有自己实现内存池，所以系统内存分配器的性能及碎片率会对redis造成一些性能上的影响。<br>Redis采用了3种内存分配器：tcmalloc、jemalloc、malloc。<br>Redis在编译时，首先会判断是否使用tcmalloc，其次是jemalloc，如果都没有使用，则使用libc中的内存管理函数malloc。<br><a id="more"></a></p>
<h2 id="功能函数总览"><a href="#功能函数总览" class="headerlink" title="功能函数总览"></a>功能函数总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用malloc函数申请size大小的内存空间（malloc不初始化，里边的数据是随机的）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用calloc函数申请size大小的内存空间（calloc系统会自动初始化内存为零）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用realloc函数重新分配size大小的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 调用free释放ptr的内存</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>; <span class="comment">// 深拷贝字符串s</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_used_memory</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取以分配的内存空间大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_set_oom_handler</span><span class="params">(<span class="keyword">void</span> (*oom_handler)(<span class="keyword">size_t</span>))</span></span>; <span class="comment">// 可自定义内存溢出的处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取rss信息（Resident Set Size 常驻内存集）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zmalloc_get_allocator_info</span><span class="params">(<span class="keyword">size_t</span> *allocated, <span class="keyword">size_t</span> *active, <span class="keyword">size_t</span> *resident)</span></span>; <span class="comment">// 获取jemalloc分配的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_jemalloc_bg_thread</span><span class="params">(<span class="keyword">int</span> enable)</span></span>; <span class="comment">// flushdb没有通信后，让jemalloc异步清除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jemalloc_purge</span><span class="params">()</span></span>; <span class="comment">// 手动清理内存碎片</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_private_dirty</span><span class="params">(<span class="keyword">long</span> pid)</span></span>; <span class="comment">// 获取smap中的Private_Dirty大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid)</span></span>; <span class="comment">// 获取smap中的某字段大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_memory_size</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取物理内存的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlibc_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 释放内存，不更新used_memory（不知道为啥，等以后看懂了再注释）</span></span><br></pre></td></tr></table></figure>
<h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录以使用的内存总大小，对该变量的操作都是原子操作</span></span><br><span class="line"><span class="comment">// 在redis-cli使用info命令可以查看</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用系统函数malloc申请size大小的内存空间，PREFIX_SIZE根据不同平台和HAVE_MALLOC_SIZE控制的。</span></span><br><span class="line"><span class="comment">// 如果分配失败，则调用zmalloc_oom_handler()函数来打印异常，并返回空值。</span></span><br><span class="line"><span class="comment">// 若分配成功，会在update_zmalloc_stat_alloc()宏定义函数中更新used_memory这个静态变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用系统函数calloc申请size大小的内存空间，功能函数与zmalloc()相同</span></span><br><span class="line"><span class="comment">// malloc与calloc的区别在于，malloc申请的内存不进行初始化，内存里的值是随机的，calloc申请的内存系统会讲其初始化为零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据新的size进行内存分配，并且更新used_memory变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        zfree(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = zmalloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放ptr的内存空间，并更新used_memory变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深拷贝字符串s，创建字符串副本</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取used_memory的值</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_used_memory</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line">    atomicGet(used_memory,um);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可自定义分配失败时的处理方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_set_oom_handler</span><span class="params">(<span class="keyword">void</span> (*oom_handler)(<span class="keyword">size_t</span>))</span> </span>&#123;</span><br><span class="line">    zmalloc_oom_handler = oom_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取rss信息（Resident Set Size 常驻内存集）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">size_t</span> rss;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">&quot;/proc/%d/stat&quot;</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    rss *= page;</span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取jemalloc分配的信息，在jemalloc前提下使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zmalloc_get_allocator_info</span><span class="params">(<span class="keyword">size_t</span> *allocated,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *active,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *resident)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> epoch = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> sz;</span><br><span class="line">    *allocated = *resident = *active = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Update the statistics cached by mallctl. */</span></span><br><span class="line">    sz = <span class="keyword">sizeof</span>(epoch);</span><br><span class="line">    je_mallctl(<span class="string">&quot;epoch&quot;</span>, &amp;epoch, &amp;sz, &amp;epoch, sz);</span><br><span class="line">    sz = <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="comment">/* Unlike RSS, this does not include RSS from shared libraries and other non</span></span><br><span class="line"><span class="comment">     * heap mappings. */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.resident&quot;</span>, resident, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Unlike resident, this doesn&#x27;t not include the pages jemalloc reserves</span></span><br><span class="line"><span class="comment">     * for re-use (purge will clean that). */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.active&quot;</span>, active, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Unlike zmalloc_used_memory, this matches the stats.resident by taking</span></span><br><span class="line"><span class="comment">     * into account all allocations done by this process (not only zmalloc). */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.allocated&quot;</span>, allocated, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flushdb没有通信后，让jemalloc异步清除，在jemalloc前提下使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_jemalloc_bg_thread</span><span class="params">(<span class="keyword">int</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* let jemalloc do purging asynchronously, required when there&#x27;s no traffic </span></span><br><span class="line"><span class="comment">     * after flushdb */</span></span><br><span class="line">    <span class="keyword">char</span> val = !!enable;</span><br><span class="line">    je_mallctl(<span class="string">&quot;background_thread&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;val, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整理内存碎片，在jemalloc前提下使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jemalloc_purge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* return all unused (reserved) pages to the OS */</span></span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> narenas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>);</span><br><span class="line">    <span class="keyword">if</span> (!je_mallctl(<span class="string">&quot;arenas.narenas&quot;</span>, &amp;narenas, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;arena.%d.purge&quot;</span>, narenas);</span><br><span class="line">        <span class="keyword">if</span> (!je_mallctl(tmp, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取smap中的Private_Dirty（映射中已由此进程写入但未被任何其他进程引用的页面）大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_private_dirty</span><span class="params">(<span class="keyword">long</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zmalloc_get_smap_bytes_by_field(<span class="string">&quot;Private_Dirty:&quot;</span>,pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取进程的smap文件中，某字段字节的大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">size_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flen = <span class="built_in">strlen</span>(field);</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        fp = fopen(<span class="string">&quot;/proc/self/smaps&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> filename[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(filename,<span class="keyword">sizeof</span>(filename),<span class="string">&quot;/proc/%ld/smaps&quot;</span>,pid);</span><br><span class="line">        fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fgets(line,<span class="keyword">sizeof</span>(line),fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line,field,flen) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> *p = <span class="built_in">strchr</span>(line,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                bytes += strtol(line+flen,<span class="literal">NULL</span>,<span class="number">10</span>) * <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取物理内存的大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_memory_size</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__unix) || defined(unix) || \</span></span><br><span class="line">    (defined(__APPLE__) &amp;&amp; defined(__MACH__))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CTL_HW) &amp;&amp; (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_MEMSIZE)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_MEMSIZE;            <span class="comment">/* OSX. --------------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PHYSMEM64)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM64;          <span class="comment">/* NetBSD, OpenBSD. --------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int64_t</span> size = <span class="number">0</span>;               <span class="comment">/* 64-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl( mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_SC_PHYS_PAGES) &amp;&amp; defined(_SC_PAGESIZE)</span></span><br><span class="line">    <span class="comment">/* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>)sysconf(_SC_PHYS_PAGES) * (<span class="keyword">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CTL_HW) &amp;&amp; (defined(HW_PHYSMEM) || defined(HW_REALMEM))</span></span><br><span class="line">    <span class="comment">/* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_REALMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_REALMEM;        <span class="comment">/* FreeBSD. ----------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PHYSMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM;        <span class="comment">/* Others. ------------------ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="number">0</span>;      <span class="comment">/* 32-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown method to get the data. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown OS. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用对应的内存分配器的free函数进行内存释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlibc_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-紧凑列表listpack</title>
    <url>/Redis/1-data-structure/redis-parse-listpack/</url>
    <content><![CDATA[<p>源码位置：listpack.c/listpack.h</p>
<p>Redis 5.0版本引入的一个新的数据结构，它是对ziplist压缩列表的改进，listpack结构更为精简，更加节省内存空间。它的实现方式也和ziplist很类似，所以阅读理解起来并不难。也许该数据结构设计出来是要替代ziplist的，只不过ziplist目前在redis中的应用非常广泛，替换起来复杂度很高，所以目前该数据结构只有在新引入的stream数据结构中使用，可能将来有一天会全面替换ziplist。  </p>
<p>相对于ziplist，listpack取消了存储前置节点长度的字段，listpack的节点之间是相互独立的，改变前置节点的长度，不会影响到后续节点的长度，所以再也不需要连锁更新操作。<br><a id="more"></a><br>和ziplist一样，没有专门定义的结构体，在内存中的表现如下：<br><strong>listpack结构：</strong><br><img src="https://i.loli.net/2020/10/29/KbiyRrgpVwvAaqU.png" alt="listpack.png"><br>|属性       |长度        |用途        |<br>|—-        |—-        |—-        |<br>|lpbyte     |4byte      |表示整个lp的字节数（最大可存储4GB）。可用于快速定位最后一个节点的位置。|<br>|lpsize     |2byte      |表示元素（节点）个数。|<br>|lpentry    |不定长     |节点。存储数据编码类型，数据，和当前元素的长度。|<br>|lpend      |1byte      |lp结束标志，和ziplist一样，恒为0xff。|</p>
<p><strong>lpentry节点：</strong><br><img src="https://i.loli.net/2020/10/29/4PNFi12ueAg6ndK.png" alt="listpack_entry.png"><br>encoding：数据的编码类型，如下：<br><img src="https://i.loli.net/2020/10/29/F2AfskTOS6nexP8.png" alt="listpack_encoding.png"><br>data：元素。<br>backlen：存储encoding+data的长度，这个是用于反向遍历的关键，通过位置指针p-backlen_size-backlen，可移动到上一个节点的位置。编码如下：<br><img src="https://i.loli.net/2020/10/29/MCeUzOo8qwh2idN.png" alt="listpack_backlen.png"></p>
<p>下面来列举一下主要函数的时间复杂度：<br>|函数|作用 |复杂度|<br>|—-|—-|—-|<br>|lpNew()|创建listpack|O(1)|<br>|lpFree()|释放listpack|O(1)|<br>|lpSeek()|获取指定位置的节点指针|平均O(N)，首尾O(1)|<br>|lpAppend()|指定位置插入元素|O(1)|<br>|lpDelete()|指定位置删除元素|O(1)|</p>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// listpack_malloc.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp_malloc zmalloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp_realloc zrealloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp_free zfree</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_INTBUF_SIZE 21 <span class="comment">/* 20 digits of -2^63 + 1 null term = 21. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// listpack.h</span></span><br><span class="line"><span class="comment">/* lpInsert() where argument possible values: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_BEFORE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_AFTER 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_REPLACE 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// listpack.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_HDR_SIZE 6       <span class="comment">/* 32 bit total len + 16 bit number of elements. */</span> <span class="comment">// 前4个byte表示占用的总字节数，后2个byte表示元素个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_HDR_NUMELE_UNKNOWN UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_MAX_INT_ENCODING_LEN 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_MAX_BACKLEN_SIZE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_MAX_ENTRY_BACKLEN 34359738367ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_INT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_STRING 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_7BIT_UINT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_7BIT_UINT_MASK 0x80 <span class="comment">// 1000 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_7BIT_UINT(byte) (((byte)&amp;LP_ENCODING_7BIT_UINT_MASK)==LP_ENCODING_7BIT_UINT) <span class="comment">// 0xxx xxxx : 7bit正整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_6BIT_STR 0x80 <span class="comment">// 1000 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_6BIT_STR_MASK 0xC0 <span class="comment">// 1100 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_6BIT_STR(byte) (((byte)&amp;LP_ENCODING_6BIT_STR_MASK)==LP_ENCODING_6BIT_STR) <span class="comment">// 10aa aaaa : 6bit字符串编码，前2个bit表示6bit字符串编码，后跟6个bit表示字符串长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_13BIT_INT 0xC0 <span class="comment">// 1100 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_13BIT_INT_MASK 0xE0 <span class="comment">// 1110 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_13BIT_INT(byte) (((byte)&amp;LP_ENCODING_13BIT_INT_MASK)==LP_ENCODING_13BIT_INT) <span class="comment">// 1100 xxxx : 13bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_12BIT_STR 0xE0 <span class="comment">// 1110 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_12BIT_STR_MASK 0xF0 <span class="comment">// 1111 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_12BIT_STR(byte) (((byte)&amp;LP_ENCODING_12BIT_STR_MASK)==LP_ENCODING_12BIT_STR) <span class="comment">// 1100 aaaa aaaa aaaa : 12bit字符串编码，前4个bit表示12bit字符串编码，后跟12个bit表示字符串长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_16BIT_INT 0xF1 <span class="comment">// 1111 0001</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_16BIT_INT_MASK 0xFF <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_16BIT_INT(byte) (((byte)&amp;LP_ENCODING_16BIT_INT_MASK)==LP_ENCODING_16BIT_INT) <span class="comment">// 1110 0001 : 16bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_24BIT_INT 0xF2 <span class="comment">// 1111 0010</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_24BIT_INT_MASK 0xFF <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_24BIT_INT(byte) (((byte)&amp;LP_ENCODING_24BIT_INT_MASK)==LP_ENCODING_24BIT_INT) <span class="comment">// 1111 0010 : 24bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_INT 0xF3 <span class="comment">// 1111 0011</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_INT_MASK 0xFF <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_32BIT_INT(byte) (((byte)&amp;LP_ENCODING_32BIT_INT_MASK)==LP_ENCODING_32BIT_INT) <span class="comment">// 1111 0011 : 32bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_64BIT_INT 0xF4 <span class="comment">// 1111 0100</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_64BIT_INT_MASK 0xFF <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_64BIT_INT(byte) (((byte)&amp;LP_ENCODING_64BIT_INT_MASK)==LP_ENCODING_64BIT_INT) <span class="comment">// 1111 0100 : 64bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_STR 0xF0 <span class="comment">// 1111 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_STR_MASK 0xFF  <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_32BIT_STR(byte) (((byte)&amp;LP_ENCODING_32BIT_STR_MASK)==LP_ENCODING_32BIT_STR) <span class="comment">// 1111 0000 : 32bit字符串编码，前8个bit表示32bit字符串编码，后跟32个bit表示字符串长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_EOF 0xFF <span class="comment">// listpack结束标志</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算6bit字符串类型编码的实际长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_6BIT_STR_LEN(p) ((p)[0] &amp; 0x3F)</span></span><br><span class="line"><span class="comment">// 计算12bit字符串类型编码的实际长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_12BIT_STR_LEN(p) ((((p)[0] &amp; 0xF) &lt;&lt; 8) | (p)[1])</span></span><br><span class="line"><span class="comment">// 计算32bit字符串类型编码的实际长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_STR_LEN(p) (((uint32_t)(p)[1]&lt;&lt;0) | \</span></span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>) | \</span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">3</span>]&lt;&lt;<span class="number">16</span>) | \</span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">4</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line"><span class="comment">// 获取listpack总字节数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lpGetTotalBytes(p)           (((uint32_t)(p)[0]&lt;&lt;0) | \</span></span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>) | \</span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">2</span>]&lt;&lt;<span class="number">16</span>) | \</span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">3</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line"><span class="comment">// 获取listpack元素个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lpGetNumElements(p)          (((uint32_t)(p)[4]&lt;&lt;0) | \</span></span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">5</span>]&lt;&lt;<span class="number">8</span>))</span><br><span class="line"><span class="comment">// 设置listpack的总字节数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lpSetTotalBytes(p,v) do &#123; \</span></span><br><span class="line">    (p)[<span class="number">0</span>] = (v)&amp;<span class="number">0xff</span>; \</span><br><span class="line">    (p)[<span class="number">1</span>] = ((v)&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>; \</span><br><span class="line">    (p)[<span class="number">2</span>] = ((v)&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>; \</span><br><span class="line">    (p)[<span class="number">3</span>] = ((v)&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 设置元素个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lpSetNumElements(p,v) do &#123; \</span></span><br><span class="line">    (p)[<span class="number">4</span>] = (v)&amp;<span class="number">0xff</span>; \</span><br><span class="line">    (p)[<span class="number">5</span>] = ((v)&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpNew</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建listpack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpFree</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// 释放listpack</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **newp)</span></span>; <span class="comment">// 指定节点插入或删除操作（ele为空，则为删除）</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpAppend</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size)</span></span>; <span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **newp)</span></span>; <span class="comment">// 删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">lpLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// listpack节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int64_t</span> *count, <span class="keyword">unsigned</span> <span class="keyword">char</span> *intbuf)</span></span>; <span class="comment">// 获取节点的数据</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpFirst</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// 获取头节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpLast</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// 获取尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>; <span class="comment">// 跳到下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>; <span class="comment">// 跳到上一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">lpBytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// 获取listpack的大小</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpSeek</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">long</span> index)</span></span>; <span class="comment">// 获取指定位置节点的指针</span></span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建listpack</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *lp = lp_malloc(LP_HDR_SIZE+<span class="number">1</span>); <span class="comment">// 申请7byte的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (lp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    lpSetTotalBytes(lp,LP_HDR_SIZE+<span class="number">1</span>);</span><br><span class="line">    lpSetNumElements(lp,<span class="number">0</span>);</span><br><span class="line">    lp[LP_HDR_SIZE] = LP_EOF; <span class="comment">// 节点结束标志（恒为0xFF）</span></span><br><span class="line">    <span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放listpack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpFree</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span> </span>&#123;</span><br><span class="line">    lp_free(lp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编码相关：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素编码类型和长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lpEncodeGetType</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">char</span> *intenc, <span class="keyword">uint64_t</span> *enclen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> v;</span><br><span class="line">    <span class="keyword">if</span> (lpStringToInt64((<span class="keyword">const</span> <span class="keyword">char</span>*)ele, size, &amp;v)) &#123;</span><br><span class="line">        <span class="comment">// 如果能转为整数，则判定元素为整数，根据数值编码到intenc中</span></span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">            <span class="comment">/* Single byte 0-127 integer. */</span></span><br><span class="line">            intenc[<span class="number">0</span>] = v;</span><br><span class="line">            *enclen = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">-4096</span> &amp;&amp; v &lt;= <span class="number">4095</span>) &#123;</span><br><span class="line">            <span class="comment">/* 13 bit integer. */</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v = ((<span class="keyword">int64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">13</span>)+v;</span><br><span class="line">            intenc[<span class="number">0</span>] = (v&gt;&gt;<span class="number">8</span>)|LP_ENCODING_13BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = v&amp;<span class="number">0xff</span>;</span><br><span class="line">            *enclen = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">-32768</span> &amp;&amp; v &lt;= <span class="number">32767</span>) &#123;</span><br><span class="line">            <span class="comment">/* 16 bit integer. */</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v = ((<span class="keyword">int64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">16</span>)+v;</span><br><span class="line">            intenc[<span class="number">0</span>] = LP_ENCODING_16BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = v&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">2</span>] = v&gt;&gt;<span class="number">8</span>;</span><br><span class="line">            *enclen = <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">-8388608</span> &amp;&amp; v &lt;= <span class="number">8388607</span>) &#123;</span><br><span class="line">            <span class="comment">/* 24 bit integer. */</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v = ((<span class="keyword">int64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">24</span>)+v;</span><br><span class="line">            intenc[<span class="number">0</span>] = LP_ENCODING_24BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = v&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">2</span>] = (v&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">3</span>] = v&gt;&gt;<span class="number">16</span>;</span><br><span class="line">            *enclen = <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">-2147483648</span> &amp;&amp; v &lt;= <span class="number">2147483647</span>) &#123;</span><br><span class="line">            <span class="comment">/* 32 bit integer. */</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v = ((<span class="keyword">int64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">32</span>)+v;</span><br><span class="line">            intenc[<span class="number">0</span>] = LP_ENCODING_32BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = v&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">2</span>] = (v&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">3</span>] = (v&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">4</span>] = v&gt;&gt;<span class="number">24</span>;</span><br><span class="line">            *enclen = <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 64 bit integer. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> uv = v;</span><br><span class="line">            intenc[<span class="number">0</span>] = LP_ENCODING_64BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = uv&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">2</span>] = (uv&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">3</span>] = (uv&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">4</span>] = (uv&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">5</span>] = (uv&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">6</span>] = (uv&gt;&gt;<span class="number">40</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">7</span>] = (uv&gt;&gt;<span class="number">48</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">8</span>] = uv&gt;&gt;<span class="number">56</span>;</span><br><span class="line">            *enclen = <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LP_ENCODING_INT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是字符串，则计算字符串的编码长度</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">64</span>) *enclen = <span class="number">1</span>+size;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size &lt; <span class="number">4096</span>) *enclen = <span class="number">2</span>+size;</span><br><span class="line">        <span class="keyword">else</span> *enclen = <span class="number">5</span>+size;</span><br><span class="line">        <span class="keyword">return</span> LP_ENCODING_STRING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把encoding+data的长度编码到backlen中</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">lpEncodeBacklen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">uint64_t</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) buf[<span class="number">0</span>] = l;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; <span class="number">16383</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">            buf[<span class="number">0</span>] = l&gt;&gt;<span class="number">7</span>;</span><br><span class="line">            buf[<span class="number">1</span>] = (l&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; <span class="number">2097151</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">            buf[<span class="number">0</span>] = l&gt;&gt;<span class="number">14</span>;</span><br><span class="line">            buf[<span class="number">1</span>] = ((l&gt;&gt;<span class="number">7</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = (l&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; <span class="number">268435455</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">            buf[<span class="number">0</span>] = l&gt;&gt;<span class="number">21</span>;</span><br><span class="line">            buf[<span class="number">1</span>] = ((l&gt;&gt;<span class="number">14</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = ((l&gt;&gt;<span class="number">7</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = (l&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">            buf[<span class="number">0</span>] = l&gt;&gt;<span class="number">28</span>;</span><br><span class="line">            buf[<span class="number">1</span>] = ((l&gt;&gt;<span class="number">21</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = ((l&gt;&gt;<span class="number">14</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = ((l&gt;&gt;<span class="number">7</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">4</span>] = (l&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解码出encoding+data的长度</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">lpDecodeBacklen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        val |= (<span class="keyword">uint64_t</span>)(p[<span class="number">0</span>] &amp; <span class="number">127</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> (!(p[<span class="number">0</span>] &amp; <span class="number">128</span>)) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">        p--;</span><br><span class="line">        <span class="keyword">if</span> (shift &gt; <span class="number">28</span>) <span class="keyword">return</span> UINT64_MAX;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串类型编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpEncodeString</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">64</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = len | LP_ENCODING_6BIT_STR;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf+<span class="number">1</span>,s,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; <span class="number">4096</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = (len &gt;&gt; <span class="number">8</span>) | LP_ENCODING_12BIT_STR;</span><br><span class="line">        buf[<span class="number">1</span>] = len &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf+<span class="number">2</span>,s,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = LP_ENCODING_32BIT_STR;</span><br><span class="line">        buf[<span class="number">1</span>] = len &amp; <span class="number">0xff</span>;</span><br><span class="line">        buf[<span class="number">2</span>] = (len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        buf[<span class="number">3</span>] = (len &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        buf[<span class="number">4</span>] = (len &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf+<span class="number">5</span>,s,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入和删除：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpAppend</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> listpack_bytes = lpGetTotalBytes(lp);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *eofptr = lp + listpack_bytes - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> lpInsert(lp,ele,size,eofptr,LP_BEFORE,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **newp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lpInsert(lp,<span class="literal">NULL</span>,<span class="number">0</span>,p,LP_REPLACE,newp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（删除）元素实现，根据ele是否为NULL来判定是哪种操作类型（NULL为删除操作，非NULL为插入操作）</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **newp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> intenc[LP_MAX_INT_ENCODING_LEN]; <span class="comment">// intenc数组用来记录整型元素的编码和元素内容</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> backlen[LP_MAX_BACKLEN_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> enclen; <span class="comment">/* The length of the encoded element. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* An element pointer set to NULL means deletion, which is conceptually</span></span><br><span class="line"><span class="comment">     * replacing the element with a zero-length element. So whatever we</span></span><br><span class="line"><span class="comment">     * get passed as &#x27;where&#x27;, set it to LP_REPLACE. */</span></span><br><span class="line">    <span class="comment">// 如果元素ele为空意味着删除，即用0长度元素去替换，所以where设置为LP_REPLACE</span></span><br><span class="line">    <span class="keyword">if</span> (ele == <span class="literal">NULL</span>) where = LP_REPLACE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we need to insert after the current element, we just jump to the</span></span><br><span class="line"><span class="comment">     * next element (that could be the EOF one) and handle the case of</span></span><br><span class="line"><span class="comment">     * inserting before. So the function will actually deal with just two</span></span><br><span class="line"><span class="comment">     * cases: LP_BEFORE and LP_REPLACE. */</span></span><br><span class="line">    <span class="comment">// 如果想要在位置p后插入元素，则将p跳到下一个元素并在之前处理插入的情况，所以该函数实际上只处理两种情况，LP_BEFORE和LP_REPLACE</span></span><br><span class="line">    <span class="keyword">if</span> (where == LP_AFTER) &#123;</span><br><span class="line">        p = lpSkip(p);</span><br><span class="line">        where = LP_BEFORE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the offset of the element &#x27;p&#x27;, so that we can obtain its</span></span><br><span class="line"><span class="comment">     * address again after a reallocation. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> poff = p-lp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Calling lpEncodeGetType() results into the encoded version of the</span></span><br><span class="line"><span class="comment">     * element to be stored into &#x27;intenc&#x27; in case it is representable as</span></span><br><span class="line"><span class="comment">     * an integer: in that case, the function returns LP_ENCODING_INT.</span></span><br><span class="line"><span class="comment">     * Otherwise if LP_ENCODING_STR is returned, we&#x27;ll have to call</span></span><br><span class="line"><span class="comment">     * lpEncodeString() to actually write the encoded string on place later.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Whatever the returned encoding is, &#x27;enclen&#x27; is populated with the</span></span><br><span class="line"><span class="comment">     * length of the encoded element. */</span></span><br><span class="line">    <span class="keyword">int</span> enctype;</span><br><span class="line">    <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">        <span class="comment">// 获取编码类型和编码长度</span></span><br><span class="line">        enctype = lpEncodeGetType(ele,size,intenc,&amp;enclen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        enctype = <span class="number">-1</span>;</span><br><span class="line">        enclen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to also encode the backward-parsable length of the element</span></span><br><span class="line"><span class="comment">     * and append it to the end: this allows to traverse the listpack from</span></span><br><span class="line"><span class="comment">     * the end to the start. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> backlen_size = ele ? lpEncodeBacklen(backlen,enclen) : <span class="number">0</span>; <span class="comment">// 编码长度</span></span><br><span class="line">    <span class="keyword">uint64_t</span> old_listpack_bytes = lpGetTotalBytes(lp); <span class="comment">// 获取当前lp的字节数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> replaced_len  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (where == LP_REPLACE) &#123;</span><br><span class="line">        <span class="comment">// 如果是删除操作，则计算p位置节点的长度</span></span><br><span class="line">        replaced_len = lpCurrentEncodedSize(p); <span class="comment">// 当前位置p的元素编码字节数</span></span><br><span class="line">        replaced_len += lpEncodeBacklen(<span class="literal">NULL</span>,replaced_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> new_listpack_bytes = old_listpack_bytes + enclen + backlen_size</span><br><span class="line">                                  - replaced_len;</span><br><span class="line">    <span class="keyword">if</span> (new_listpack_bytes &gt; UINT32_MAX) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 单个listpack最大只能是4GB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We now need to reallocate in order to make space or shrink the</span></span><br><span class="line"><span class="comment">     * allocation (in case &#x27;when&#x27; value is LP_REPLACE and the new element is</span></span><br><span class="line"><span class="comment">     * smaller). However we do that before memmoving the memory to</span></span><br><span class="line"><span class="comment">     * make room for the new element if the final allocation will get</span></span><br><span class="line"><span class="comment">     * larger, or we do it after if the final allocation will get smaller. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *dst = lp + poff; <span class="comment">/* May be updated after reallocation. */</span> <span class="comment">// 指向元素将要插入的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Realloc before: we need more room. */</span></span><br><span class="line">    <span class="keyword">if</span> (new_listpack_bytes &gt; old_listpack_bytes) &#123;</span><br><span class="line">        <span class="comment">// 如果是插入，则lp需要分配更多内存空间</span></span><br><span class="line">        <span class="keyword">if</span> ((lp = lp_realloc(lp,new_listpack_bytes)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        dst = lp + poff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the listpack relocating the elements to make the exact room</span></span><br><span class="line"><span class="comment">     * we need to store the new one. */</span></span><br><span class="line">    <span class="keyword">if</span> (where == LP_BEFORE) &#123;</span><br><span class="line">        <span class="comment">// 移动结束位（lpend）到最后</span></span><br><span class="line">        memmove(dst+enclen+backlen_size,dst,old_listpack_bytes-poff);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* LP_REPLACE. */</span></span><br><span class="line">        <span class="comment">// 将删除的节点后面的所有内存数据往前移动到节点的位置上</span></span><br><span class="line">        <span class="keyword">long</span> lendiff = (enclen+backlen_size)-replaced_len;</span><br><span class="line">        memmove(dst+replaced_len+lendiff,</span><br><span class="line">                dst+replaced_len,</span><br><span class="line">                old_listpack_bytes-poff-replaced_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Realloc after: we need to free space. */</span></span><br><span class="line">    <span class="keyword">if</span> (new_listpack_bytes &lt; old_listpack_bytes) &#123;</span><br><span class="line">        <span class="comment">// 如果是删除操作，则lp也需要重新分配内存空间</span></span><br><span class="line">        <span class="keyword">if</span> ((lp = lp_realloc(lp,new_listpack_bytes)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        dst = lp + poff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the entry. */</span></span><br><span class="line">    <span class="keyword">if</span> (newp) &#123;</span><br><span class="line">        <span class="comment">// 将当前位置赋给newp</span></span><br><span class="line">        *newp = dst;</span><br><span class="line">        <span class="comment">/* In case of deletion, set &#x27;newp&#x27; to NULL if the next element is</span></span><br><span class="line"><span class="comment">         * the EOF element. */</span></span><br><span class="line">         <span class="comment">// 如果是删除操作，并且已经到了列表尾了，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!ele &amp;&amp; dst[<span class="number">0</span>] == LP_EOF) *newp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">        <span class="comment">// 插入操作将数据填充到节点</span></span><br><span class="line">        <span class="keyword">if</span> (enctype == LP_ENCODING_INT) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(dst,intenc,enclen);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lpEncodeString(dst,ele,size);</span><br><span class="line">        &#125;</span><br><span class="line">        dst += enclen;</span><br><span class="line">        <span class="comment">// 填充backlen</span></span><br><span class="line">        <span class="built_in">memcpy</span>(dst,backlen,backlen_size);</span><br><span class="line">        dst += backlen_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update header. */</span></span><br><span class="line">    <span class="comment">// 更新lp信息</span></span><br><span class="line">    <span class="keyword">if</span> (where != LP_REPLACE || ele == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> num_elements = lpGetNumElements(lp);</span><br><span class="line">        <span class="keyword">if</span> (num_elements != LP_HDR_NUMELE_UNKNOWN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ele)</span><br><span class="line">                lpSetNumElements(lp,num_elements+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lpSetNumElements(lp,num_elements<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lpSetTotalBytes(lp,new_listpack_bytes);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">/* This code path is normally disabled: what it does is to force listpack</span></span><br><span class="line"><span class="comment">     * to return *always* a new pointer after performing some modification to</span></span><br><span class="line"><span class="comment">     * the listpack, even if the previous allocation was enough. This is useful</span></span><br><span class="line"><span class="comment">     * in order to spot bugs in code using listpacks: by doing so we can find</span></span><br><span class="line"><span class="comment">     * if the caller forgets to set the new pointer where the listpack reference</span></span><br><span class="line"><span class="comment">     * is stored, after an update. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *oldlp = lp;</span><br><span class="line">    lp = lp_malloc(new_listpack_bytes);</span><br><span class="line">    <span class="built_in">memcpy</span>(lp,oldlp,new_listpack_bytes);</span><br><span class="line">    <span class="keyword">if</span> (newp) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> offset = (*newp)-oldlp;</span><br><span class="line">        *newp = lp + offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Make sure the old allocation contains garbage. */</span></span><br><span class="line">    <span class="built_in">memset</span>(oldlp,<span class="string">&#x27;A&#x27;</span>,new_listpack_bytes);</span><br><span class="line">    lp_free(oldlp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>节点遍历相关操作：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是在位置p的节点后进行操作，则先把p跳到该节点的后一个节点上</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpSkip</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前节点encoding+data的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> entrylen = lpCurrentEncodedSize(p);</span><br><span class="line">    <span class="comment">// 获取当前backlen的长度</span></span><br><span class="line">    entrylen += lpEncodeBacklen(<span class="literal">NULL</span>,entrylen);</span><br><span class="line">    <span class="comment">// 指针移动到下一个节点的位置</span></span><br><span class="line">    p += entrylen;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳到下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>) lp); <span class="comment">/* lp is not used for now. However lpPrev() uses it. */</span></span><br><span class="line">    p = lpSkip(p);</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == LP_EOF) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳到上一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-lp == LP_HDR_SIZE) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    p--; <span class="comment">/* Seek the first backlen byte of the last element. */</span></span><br><span class="line">    <span class="comment">// 获取encoding+data的长度</span></span><br><span class="line">    <span class="keyword">uint64_t</span> prevlen = lpDecodeBacklen(p);</span><br><span class="line">    <span class="comment">// 获取backlen的长度</span></span><br><span class="line">    prevlen += lpEncodeBacklen(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">// 指针移动到上一个节点的位置</span></span><br><span class="line">    <span class="keyword">return</span> p-prevlen+<span class="number">1</span>; <span class="comment">/* Seek the first byte of the previous entry. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer to the first element of the listpack, or NULL if the</span></span><br><span class="line"><span class="comment"> * listpack has no elements. */</span></span><br><span class="line"><span class="comment">// 首节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpFirst</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span> </span>&#123;</span><br><span class="line">    lp += LP_HDR_SIZE; <span class="comment">/* Skip the header. */</span></span><br><span class="line">    <span class="keyword">if</span> (lp[<span class="number">0</span>] == LP_EOF) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer to the last element of the listpack, or NULL if the</span></span><br><span class="line"><span class="comment"> * listpack has no elements. */</span></span><br><span class="line"><span class="comment">// 尾节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpLast</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = lp+lpGetTotalBytes(lp)<span class="number">-1</span>; <span class="comment">/* Seek EOF element. */</span></span><br><span class="line">    <span class="keyword">return</span> lpPrev(lp,p); <span class="comment">/* Will return NULL if EOF is the only element. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查询：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取指定位置的节点指针</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpSeek</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> forward = <span class="number">1</span>; <span class="comment">/* Seek forward by default. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We want to seek from left to right or the other way around</span></span><br><span class="line"><span class="comment">     * depending on the listpack length and the element position.</span></span><br><span class="line"><span class="comment">     * However if the listpack length cannot be obtained in constant time,</span></span><br><span class="line"><span class="comment">     * we always seek from left to right. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> numele = lpGetNumElements(lp); <span class="comment">// 获取整个listpack的节点数</span></span><br><span class="line">    <span class="comment">// 计算index在listpack中的上半区域还是下半区域</span></span><br><span class="line">    <span class="keyword">if</span> (numele != LP_HDR_NUMELE_UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = (<span class="keyword">long</span>)numele+index;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* Index still &lt; 0 means out of range. */</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= numele) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* Out of range the other side. */</span></span><br><span class="line">        <span class="comment">/* We want to scan right-to-left if the element we are looking for</span></span><br><span class="line"><span class="comment">         * is past the half of the listpack. */</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; numele/<span class="number">2</span>) &#123;</span><br><span class="line">            forward = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* Left to right scanning always expects a negative index. Convert</span></span><br><span class="line"><span class="comment">             * our index to negative form. */</span></span><br><span class="line">            index -= numele;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If the listpack length is unspecified, for negative indexes we</span></span><br><span class="line"><span class="comment">         * want to always scan left-to-right. */</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) forward = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Forward and backward scanning is trivially based on lpNext()/lpPrev(). */</span></span><br><span class="line">    <span class="keyword">if</span> (forward) &#123;</span><br><span class="line">        <span class="comment">// 如果在上半区域，则从头节点开始正向遍历到index的位置</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele = lpFirst(lp);</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; ele) &#123;</span><br><span class="line">            ele = lpNext(lp,ele);</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在下半区域，则尾头节点开始正向遍历到index的位置</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele = lpLast(lp);</span><br><span class="line">        <span class="keyword">while</span> (index &lt; <span class="number">-1</span> &amp;&amp; ele) &#123;</span><br><span class="line">            ele = lpPrev(lp,ele);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取节点p的数据</span></span><br><span class="line"><span class="comment">// 如果数据是字符串，则返回值就是字符串的头指针，count是字符串的长度</span></span><br><span class="line"><span class="comment">// 如果数据是整数，数值填入count，如果不为空，将数值转为字符串填入intbuf</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int64_t</span> *count, <span class="keyword">unsigned</span> <span class="keyword">char</span> *intbuf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> val;</span><br><span class="line">    <span class="keyword">uint64_t</span> uval, negstart, negmax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是判断数据的编码类型，如果是字符串，则直接取出返回</span></span><br><span class="line">    <span class="keyword">if</span> (LP_ENCODING_IS_7BIT_UINT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        negstart = UINT64_MAX; <span class="comment">/* 7 bit ints are always positive. */</span></span><br><span class="line">        negmax = <span class="number">0</span>;</span><br><span class="line">        uval = p[<span class="number">0</span>] &amp; <span class="number">0x7f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_6BIT_STR(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        *count = LP_ENCODING_6BIT_STR_LEN(p);</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_13BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = ((p[<span class="number">0</span>]&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">8</span>) | p[<span class="number">1</span>];</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">12</span>;</span><br><span class="line">        negmax = <span class="number">8191</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_16BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = (<span class="keyword">uint64_t</span>)p[<span class="number">1</span>] |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>;</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">15</span>;</span><br><span class="line">        negmax = UINT16_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_24BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = (<span class="keyword">uint64_t</span>)p[<span class="number">1</span>] |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">2</span>]&lt;&lt;<span class="number">8</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">3</span>]&lt;&lt;<span class="number">16</span>;</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">23</span>;</span><br><span class="line">        negmax = UINT32_MAX&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_32BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = (<span class="keyword">uint64_t</span>)p[<span class="number">1</span>] |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">2</span>]&lt;&lt;<span class="number">8</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">3</span>]&lt;&lt;<span class="number">16</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">4</span>]&lt;&lt;<span class="number">24</span>;</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">        negmax = UINT32_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_64BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = (<span class="keyword">uint64_t</span>)p[<span class="number">1</span>] |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">2</span>]&lt;&lt;<span class="number">8</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">3</span>]&lt;&lt;<span class="number">16</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">4</span>]&lt;&lt;<span class="number">24</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">5</span>]&lt;&lt;<span class="number">32</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">6</span>]&lt;&lt;<span class="number">40</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">7</span>]&lt;&lt;<span class="number">48</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">8</span>]&lt;&lt;<span class="number">56</span>;</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>;</span><br><span class="line">        negmax = UINT64_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_12BIT_STR(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        *count = LP_ENCODING_12BIT_STR_LEN(p);</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_32BIT_STR(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        *count = LP_ENCODING_32BIT_STR_LEN(p);</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        uval = <span class="number">12345678900000000U</span>LL + p[<span class="number">0</span>];</span><br><span class="line">        negstart = UINT64_MAX;</span><br><span class="line">        negmax = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We reach this code path only for integer encodings.</span></span><br><span class="line"><span class="comment">     * Convert the unsigned value to the signed one using two&#x27;s complement</span></span><br><span class="line"><span class="comment">     * rule. */</span></span><br><span class="line">     <span class="comment">// 如果是负整数，则转为有符号整数</span></span><br><span class="line">    <span class="keyword">if</span> (uval &gt;= negstart) &#123;</span><br><span class="line">        <span class="comment">/* This three steps conversion should avoid undefined behaviors</span></span><br><span class="line"><span class="comment">         * in the unsigned -&gt; signed conversion. */</span></span><br><span class="line">        uval = negmax-uval;</span><br><span class="line">        val = uval;</span><br><span class="line">        val = -val<span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = uval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the string representation of the integer or the value itself</span></span><br><span class="line"><span class="comment">     * depending on intbuf being NULL or not. */</span></span><br><span class="line">    <span class="keyword">if</span> (intbuf) &#123;</span><br><span class="line">        *count = <span class="built_in">snprintf</span>((<span class="keyword">char</span>*)intbuf,LP_INTBUF_SIZE,<span class="string">&quot;%lld&quot;</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)val);</span><br><span class="line">        <span class="keyword">return</span> intbuf;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *count = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-通知功能notify</title>
    <url>/Redis/3-database/redis-parse-notify/</url>
    <content><![CDATA[<p>源码位置：notify.c/server.h</p>
<p><strong>1. 事件通知概述</strong><br>对于Redis服务器，它可以通过订阅发布功能来发送服务器中的键空间事件。所谓的键空间事件，就是数据库中键的增加、修改和删除等操作，用于告知收听该类事件的客户端当前数据库中执行了哪些操作。客户端可以通过 订阅与发布功能（pub/sub）功能，来接收那些以某种方式改动了Redis数据集的事件。<br>目前Redis的订阅与发布功能采用的是发送即忘（fire and forget）的策略，当订阅事件的客户端断线时，它会丢失所有在断线期间分发给它的事件。<br>订阅与发布功能（pub/sub）功能实现在pubsub.c中，后续会在博文中讲到。</p>
<a id="more"></a>
<p><strong>2. 事件类型</strong><br>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件：  </p>
<ul>
<li>键空间通知（key-space）</li>
<li>键事件通知（key-event）</li>
</ul>
<p>当 <code>del mykey</code> 命令执行时：</p>
<ul>
<li>键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 del</li>
<li>键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 mykey</li>
</ul>
<p><strong>3. 配置</strong><br>因为开启键空间通知功能需要消耗一些 CPU，所以在默认配置下，该功能处于关闭状态。开启通知功能有以下两种方式：  </p>
<ol>
<li>修改 redis.conf 中的 <code>notify-keyspace-events</code> 参数</li>
<li>通过 CONFIG SET 命令来设定 <code>notify-keyspace-events</code> 参数</li>
</ol>
<p><code>notify-keyspace-events</code> 参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>发送的通知</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>键空间通知，所有通知以 <strong>keyspace@\<db></db></strong> 为前缀</td>
</tr>
<tr>
<td>E</td>
<td>键事件通知，所有通知以 <strong>keyevent@\<db></db></strong> 为前缀</td>
</tr>
<tr>
<td>g</td>
<td>DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</td>
</tr>
<tr>
<td>$</td>
<td>字符串命令的通知</td>
</tr>
<tr>
<td>l</td>
<td>列表命令的通知</td>
</tr>
<tr>
<td>s</td>
<td>集合命令的通知</td>
</tr>
<tr>
<td>h</td>
<td>哈希命令的通知</td>
</tr>
<tr>
<td>z</td>
<td>有序集合命令的通知</td>
</tr>
<tr>
<td>x</td>
<td>过期事件：每当有过期键被删除时发送</td>
</tr>
<tr>
<td>e</td>
<td>驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</td>
</tr>
<tr>
<td>A</td>
<td>参数 g$lshzxe 的别名，包含所有的字符</td>
</tr>
</tbody>
</table>
</div>
<p>输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何通知被分发。<br>在源码中设定了一系列的宏定义，用来标识以上这些字符事件的类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键空间通知的类型，每个类型都关联着一个有目的的字符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_KEYSPACE (1&lt;&lt;0)    <span class="comment">/* K */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_KEYEVENT (1&lt;&lt;1)    <span class="comment">/* E */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_GENERIC (1&lt;&lt;2)     <span class="comment">/* g */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_STRING (1&lt;&lt;3)      <span class="comment">/* $ */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_LIST (1&lt;&lt;4)        <span class="comment">/* l */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_SET (1&lt;&lt;5)         <span class="comment">/* s */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_HASH (1&lt;&lt;6)        <span class="comment">/* h */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_ZSET (1&lt;&lt;7)        <span class="comment">/* z */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_EXPIRED (1&lt;&lt;8)     <span class="comment">/* x */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_EVICTED (1&lt;&lt;9)     <span class="comment">/* e */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_STREAM (1&lt;&lt;10)     <span class="comment">/* t */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_KEY_MISS (1&lt;&lt;11)   <span class="comment">/* m (Note: This one is excluded from NOTIFY_ALL on purpose) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_ALL (NOTIFY_GENERIC | NOTIFY_STRING | NOTIFY_LIST | NOTIFY_SET | NOTIFY_HASH | NOTIFY_ZSET | NOTIFY_EXPIRED | NOTIFY_EVICTED | NOTIFY_STREAM) <span class="comment">/* A flag */</span></span></span><br></pre></td></tr></table></figure>
<p>在notify.c文件中，只有三个功能函数，下面让我们来看看源码实现吧。</p>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Keyspace events notification */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyspaceEventsStringToFlags</span><span class="params">(<span class="keyword">char</span> *classes)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">keyspaceEventsFlagsToString</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 因为redis命令中事件类型是字符类型，所以会使用一个int类型的flags参数</span></span><br><span class="line"><span class="comment"> * 通过多个字符按位或运算保存起来，方便后面使用 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyspaceEventsStringToFlags</span><span class="params">(<span class="keyword">char</span> *classes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = classes;</span><br><span class="line">    <span class="keyword">int</span> c, flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = *p++) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: flags |= NOTIFY_ALL; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>: flags |= NOTIFY_GENERIC; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: flags |= NOTIFY_STRING; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: flags |= NOTIFY_LIST; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: flags |= NOTIFY_SET; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: flags |= NOTIFY_HASH; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>: flags |= NOTIFY_ZSET; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: flags |= NOTIFY_EXPIRED; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: flags |= NOTIFY_EVICTED; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>: flags |= NOTIFY_KEYSPACE; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: flags |= NOTIFY_KEYEVENT; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: flags |= NOTIFY_STREAM; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: flags |= NOTIFY_KEY_MISS; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将flags参数转为sds类型</span></span><br><span class="line"><span class="function">sds <span class="title">keyspaceEventsFlagsToString</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    sds res;</span><br><span class="line"></span><br><span class="line">    res = sdsempty();</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; NOTIFY_ALL) == NOTIFY_ALL) &#123;</span><br><span class="line">        res = sdscatlen(res,<span class="string">&quot;A&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_GENERIC) res = sdscatlen(res,<span class="string">&quot;g&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_STRING) res = sdscatlen(res,<span class="string">&quot;$&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_LIST) res = sdscatlen(res,<span class="string">&quot;l&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_SET) res = sdscatlen(res,<span class="string">&quot;s&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_HASH) res = sdscatlen(res,<span class="string">&quot;h&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_ZSET) res = sdscatlen(res,<span class="string">&quot;z&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_EXPIRED) res = sdscatlen(res,<span class="string">&quot;x&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_EVICTED) res = sdscatlen(res,<span class="string">&quot;e&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_STREAM) res = sdscatlen(res,<span class="string">&quot;t&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NOTIFY_KEYSPACE) res = sdscatlen(res,<span class="string">&quot;K&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NOTIFY_KEYEVENT) res = sdscatlen(res,<span class="string">&quot;E&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NOTIFY_KEY_MISS) res = sdscatlen(res,<span class="string">&quot;m&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用Redis的订阅和发布功能来发送键空间事件通知。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果任何模块对事件感兴趣，将立即通知感兴趣的模块。这将绕过通知配置，但模块引擎将仅在事件类型与事件订阅者感兴趣的类型匹配时调用事件订阅者。 */</span></span><br><span class="line">     moduleNotifyKeyspaceEvent(type, event, key, dbid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知功能关闭，直接退出 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(server.notify_keyspace_events &amp; type)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事件对象</span></span><br><span class="line">    eventobj = createStringObject(event,<span class="built_in">strlen</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 键空间通知，格式为__keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">&quot;__keyspace@&quot;</span>,<span class="number">11</span>);</span><br><span class="line">        len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">&quot;__:&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        <span class="comment">// 调用pub/sub命令发送</span></span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 键时间通知，格式为__keyevente@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">&quot;__keyevent@&quot;</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">&quot;__:&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        <span class="comment">// 调用pub/sub命令发送</span></span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>3-database</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-网络通信</title>
    <url>/Redis/4-net/redis-parse-networking/</url>
    <content><![CDATA[<p>源码位置：anet.c/anet.h/networking.c</p>
<p><strong>1. 简介</strong><br>Redis在<code>anet.c</code>中对TCP/IP网络中socket api接口和状态设置进行了封装。状态设置主要包括socket连接的阻塞性、tcp的保活定时器的设置、设置发送缓冲区、tcp的nagle算法设置、设置发送/接收超时时间、地址重用的设置和IPv6/IPv4的设置等。<br>Redis网络通讯的具体实现在<code>networking.c</code>中，主要包括如何建立和客户端的连接，并且接收其命令，返回给客户端。</p>
<a id="more"></a>
<p><strong>2. 回顾tcp socket编程</strong><br>2.1 TCP客户/服务器程序socket编程流程如下：<br><img src="https://i.loli.net/2020/10/29/5diHCr9l4joFegw.png" alt="socket.png"></p>
<p>2.2 TCP的三次握手<br><img src="https://i.loli.net/2020/10/29/o5zhlJdUMWrGpC3.png" alt="tcp_handshake.png"></p>
<p>2.3 TCP的四次挥手<br>TCP的断开连接操作可由<strong>任意一端发起</strong><br><img src="https://i.loli.net/2020/10/29/miRLwn5sPd63Ycb.png" alt="tcp_close.png"></p>
<p><strong>3. anet解析</strong><br>anet.h中定义的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port)</span></span>; <span class="comment">// tcp连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port)</span></span>; <span class="comment">// TCP非阻塞连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockBindConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *source_addr)</span></span>; <span class="comment">// TCP非阻塞绑定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockBestEffortBindConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *source_addr)</span></span>; <span class="comment">// TCP非阻塞绑定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">// unix socket连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixNonBlockConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">// unix socket非阻塞连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetRead</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span>; <span class="comment">// socket读数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetResolve</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *host, <span class="keyword">char</span> *ipbuf, <span class="keyword">size_t</span> ipbuf_len)</span></span>; <span class="comment">// 解析所有的东西</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetResolveIP</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *host, <span class="keyword">char</span> *ipbuf, <span class="keyword">size_t</span> ipbuf_len)</span></span>; <span class="comment">// 解析IP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// IPv4下创建socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcp6Server</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// IPv6下创建socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> perm, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// unix创建socket和bind</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> serversock, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// tcp socket接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> serversock)</span></span>; <span class="comment">// unix tcp socket接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetWrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span>; <span class="comment">// socket写数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetNonBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置socket为非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置socket为阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetEnableTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 启用tcp_nodelay选项（关闭Nagle算法）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetDisableTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 禁用tcp_nodelay选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置tcp keepalive选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetSendTimeout</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> ms)</span></span>; <span class="comment">// 设置发送超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetRecvTimeout</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> ms)</span></span>; <span class="comment">// 设置接收超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetPeerToString</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// 获取客户端的ip、port</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">int</span> interval)</span></span>; <span class="comment">// 设置tcp keepalive选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetSockName</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// 获取套接字的名字</span></span><br><span class="line"><span class="comment">/* 格式化操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatAddr</span><span class="params">(<span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len, <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatPeer</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatSock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Redis服务启动后会调用<code>server.c/listenToPort()</code>进行socket相关的设置和端口监听。如果服务器配置不包含要绑定的特定地址，则该函数会尝试IPv6（调用<code>anetTcp6Server()</code>）和IPv4（调用<code>anetTcpServer()</code>）协议进行绑定。<br>不管是使用IPv6还是IPv4协议，最终调用的都是<code>_anetTcpServer()</code>来创建socket并进行绑定监听，以下是该函数的实现代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _anetTcpServer(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> af, <span class="keyword">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">-1</span>, rv;</span><br><span class="line">    <span class="keyword">char</span> _port[<span class="number">6</span>];  <span class="comment">/* strlen(&quot;65535&quot;) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">servinfo</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(_port,<span class="number">6</span>,<span class="string">&quot;%d&quot;</span>,port);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = af;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE;    <span class="comment">/* No effect if bindaddr != NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将域名解析成ip地址</span></span><br><span class="line">    <span class="keyword">if</span> ((rv = getaddrinfo(bindaddr,_port,&amp;hints,&amp;servinfo)) != <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;%s&quot;</span>, gai_strerror(rv));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = servinfo; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = socket(p-&gt;ai_family,p-&gt;ai_socktype,p-&gt;ai_protocol)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (af == AF_INET6 &amp;&amp; anetV6Only(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// 设置SO_REUSEADDR允许我们重复bind相同的本地地址</span></span><br><span class="line">        <span class="keyword">if</span> (anetSetReuseAddr(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// bind &amp;&amp; listen</span></span><br><span class="line">        <span class="keyword">if</span> (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;unable to bind socket, errno: %d&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">-1</span>) close(s);</span><br><span class="line">    s = ANET_ERR;</span><br><span class="line">end:</span><br><span class="line">    freeaddrinfo(servinfo);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. networking解析</strong><br>新版本Redis增加了多线程I/O来改进读写缓冲区的性能，而不是改进命令执行的性能主要原因是：</p>
<ol>
<li>读写缓冲区在命令执行的生命周期中是占了比较大的比重</li>
<li>Redis更倾向于保持简单的设计，如果在命令执行部分改用多线程会不得不处理各种问题，例如并发写入、加锁等</li>
</ol>
<p>那么将读写缓冲区改为多线程后整个模型大致如下：<br><img src="https://i.loli.net/2020/10/29/AXlEnyOF3qk7vbg.png" alt="thread-io.png"></p>
<p>4.1 线程初始化<br>首先，如果用户没有开启多线程IO，也就是io_threads_num == 1时直接按照单线程模型处理，如果超过线程数IO_THREADS_MAX_NUM上限则异常退出。</p>
<p>紧接着Redis使用listCreate()创建io_threads_num个线程，并且对主线程（id=0）以外的线程进行处理：</p>
<ul>
<li>初始化线程的等待任务数为0</li>
<li>获取锁，使得线程不能进行操作</li>
<li>将线程tid与Redis中的线程id（for循环生成）进行映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    io_threads_active = <span class="number">0</span>; <span class="comment">/* We start with threads not active. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果io_threads_num为1，则按照单线程模型处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程数设置超过上限</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num &gt; IO_THREADS_MAX_NUM) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal: too many I/O threads configured. &quot;</span></span><br><span class="line">                             <span class="string">&quot;The maximum number is %d.&quot;</span>, IO_THREADS_MAX_NUM);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 生成并初始化对应 io_threads_num 个I/O线程 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; server.io_threads_num; i++) &#123;</span><br><span class="line">        io_threads_list[i] = listCreate();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* 0为主线程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 非主线程则需要以下处理 */</span></span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">// 为线程初始化对应的锁</span></span><br><span class="line">        pthread_mutex_init(&amp;io_threads_mutex[i],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 线程等待状态初始化为0</span></span><br><span class="line">        io_threads_pending[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化后将线程暂时锁住</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[i]); <span class="comment">/* Thread will be stopped. */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid,<span class="literal">NULL</span>,IOThreadMain,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Fatal: Can&#x27;t initialize IO thread.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将index和对应线程ID加以映射</span></span><br><span class="line">        io_threads[i] = tid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.2 建立连接<br>Redis服务端会初始化一个socket端口来监听客户端的连接，当一个连接建立后，服务端会对客户端的socket进行设置：</p>
<ol>
<li>客户端socket设置为非阻塞模式，因为Redis采用的是非阻塞I/O多路复用模型。</li>
<li>客户端socket设置为 TCP_NODELAY 属性，禁用 Nagle 算法。</li>
<li>将该socket绑定读事件到时间loop，用于监听这个客户端socket的数据发送。</li>
<li>建立连接后如果发现已经超过最大连接数，则关闭连接，删除该客户端socket。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当conn为NULL时，创建无网络连接的伪客户端</span></span><br><span class="line"><span class="comment">     * 当conn不为NULL时，创建带网络连接的客户端</span></span><br><span class="line"><span class="comment">     * 因为 Redis 的命令必须在客户端的上下文中使用，所以在执行 Lua 环境中的命令时</span></span><br><span class="line"><span class="comment">     * 需要用到这种伪终端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (conn) &#123;</span><br><span class="line">        <span class="comment">// 设置非阻塞</span></span><br><span class="line">        connNonBlock(conn);</span><br><span class="line">        <span class="comment">// 禁用tcp_nodelay</span></span><br><span class="line">        connEnableTcpNoDelay(conn);</span><br><span class="line">        <span class="comment">// 设置 keep alive</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            connKeepAlive(conn,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 绑定读事件和处理函数到事件loop（开始接收命令请求）</span></span><br><span class="line">        connSetReadHandler(conn, readQueryFromClient);</span><br><span class="line">        <span class="comment">// 将私有数据指针与连接相关联</span></span><br><span class="line">        connSetPrivateData(conn, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化客户端参数</span></span><br><span class="line">    selectDb(c,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> client_id = ++server.next_client_id;</span><br><span class="line">    c-&gt;id = client_id;</span><br><span class="line">    c-&gt;resp = <span class="number">2</span>;</span><br><span class="line">    c-&gt;conn = conn;</span><br><span class="line">    c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">    c-&gt;qb_pos = <span class="number">0</span>;</span><br><span class="line">    c-&gt;querybuf = sdsempty();</span><br><span class="line">    c-&gt;pending_querybuf = sdsempty();</span><br><span class="line">    c-&gt;querybuf_peak = <span class="number">0</span>;</span><br><span class="line">    c-&gt;reqtype = <span class="number">0</span>;</span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    c-&gt;argv = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;user = DefaultUser;</span><br><span class="line">    c-&gt;multibulklen = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">    c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">    c-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">/* If the default user does not require authentication, the user is</span></span><br><span class="line"><span class="comment">     * directly authenticated. */</span></span><br><span class="line">    c-&gt;authenticated = (c-&gt;user-&gt;flags &amp; USER_FLAG_NOPASS) != <span class="number">0</span>;</span><br><span class="line">    c-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line">    c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    c-&gt;reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;read_reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_off = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_time = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_listening_port = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_ip[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    c-&gt;slave_capa = SLAVE_CAPA_NONE;</span><br><span class="line">    c-&gt;reply = listCreate();</span><br><span class="line">    c-&gt;reply_bytes = <span class="number">0</span>;</span><br><span class="line">    c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line">    listSetFreeMethod(c-&gt;reply,freeClientReplyValue);</span><br><span class="line">    listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span><br><span class="line">    c-&gt;btype = BLOCKED_NONE;</span><br><span class="line">    c-&gt;bpop.timeout = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.keys = dictCreate(&amp;objectKeyHeapPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_group = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_consumer = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_group_noack = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.numreplicas = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.reploffset = <span class="number">0</span>;</span><br><span class="line">    c-&gt;woff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;watched_keys = listCreate();</span><br><span class="line">    c-&gt;pubsub_channels = dictCreate(&amp;objectKeyPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    c-&gt;pubsub_patterns = listCreate();</span><br><span class="line">    c-&gt;peerid = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;client_list_node = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;client_tracking_redirection = <span class="number">0</span>;</span><br><span class="line">    c-&gt;client_tracking_prefixes = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_callback = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_callback_privdata = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_module = <span class="literal">NULL</span>;</span><br><span class="line">    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</span><br><span class="line">    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</span><br><span class="line">    <span class="keyword">if</span> (conn) linkClient(c); <span class="comment">// 如果不是伪客户端，那么添加到服务器的客户端链表中</span></span><br><span class="line">    initClientMultiState(c); <span class="comment">// 初始化客户端的事务状态</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.3 读事件到来<br>读事件到来，Redis需要判断是否满足Threaded IO条件。如果符合，则将client放到等待读取的队列中，并将client的flag设置为等待读取；如果不符合，则按照单线程模型往下继续处理。<br>等待读取队列由server维护，包含了所有处于读事件pending的客户端列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取客户端结构体</span></span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果启动了 I/O 线程，则将客户端加到server.clients_pending_read列表中 */</span></span><br><span class="line">    <span class="keyword">if</span> (postponeClientRead(c)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    readlen = PROTO_IOBUF_LEN; <span class="comment">// 通用缓冲区大小 1024*16</span></span><br><span class="line">    <span class="comment">/* 如果是批量请求，则需要提高缓冲区的大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> remaining = (<span class="keyword">size_t</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在某些边缘情况下，“remaining”变量可能为零，例如，在客户端暂停后恢复被阻塞的客户端。 */</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &gt; <span class="number">0</span> &amp;&amp; remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取缓冲区内当前内容的长度</span></span><br><span class="line"><span class="comment">     * 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span></span><br><span class="line"><span class="comment">     * 这些滞留内容也许不能完整构成一个符合协议的命令 */</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen); <span class="comment">// 扩容querybuf的大小</span></span><br><span class="line">    nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen); <span class="comment">// 读取内容到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取错误</span></span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE, <span class="string">&quot;Reading from client: %s&quot;</span>,connGetLastError(c-&gt;conn));</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF</span></span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">&quot;Client closed connection&quot;</span>);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) &#123;</span><br><span class="line">        <span class="comment">/* 将缓冲区内的内容追加到pending缓冲区中，稍后将使用这个缓冲区，以便在执行最后一个命令时应用字符串的副本 */</span></span><br><span class="line">        c-&gt;pending_querybuf = sdscatlen(c-&gt;pending_querybuf,</span><br><span class="line">                                        c-&gt;querybuf+qblen,nread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据内容，更新查询缓冲区（SDS） free 和 len 属性</span></span><br><span class="line">    <span class="comment">// 并将 &#x27;\0&#x27; 正确地放到内容的最后</span></span><br><span class="line">    sdsIncrLen(c-&gt;querybuf,nread);</span><br><span class="line">    <span class="comment">// 记录服务器和客户端最后一次互动的时间</span></span><br><span class="line">    c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 如果客户端是 master 的话，更新它的复制偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) c-&gt;read_reploff += nread;</span><br><span class="line">    server.stat_net_input_bytes += nread;</span><br><span class="line">    <span class="comment">// 查询缓冲区长度超出服务器最大缓冲区长度</span></span><br><span class="line">    <span class="comment">// 清空缓冲区并释放客户端</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;</span>, ci, bytes);</span><br><span class="line">        sdsfree(ci);</span><br><span class="line">        sdsfree(bytes);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 客户端输入缓冲区中有更多数据，继续分析以防有完整的命令要执行. */</span></span><br><span class="line">     processInputBufferAndReplicate(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了Threaded-IO，如何分配读取pending的client给thread呢？<code>handleClientsWithPendingReadsUsingThreads()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingReadsUsingThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!io_threads_active || !server.io_threads_do_reads) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查有多少等待读的client</span></span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;%d TOTAL READ pending clients\n&quot;</span>, processed);</span><br><span class="line"></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将每个等待的client分配给线程，当等待长度超过线程数时，每个线程分配到的client可能会超过1个</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改每个线程需要完成的数量 */</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_READ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        io_threads_pending[j] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 也可以使用主线程来处理客户端的一部分 */</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        readQueryFromClient(c-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待线程处理直到没有剩余任务 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += io_threads_pending[j];</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;I/O READ All threads finshed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次运行客户端列表以处理新的缓冲区 */</span></span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) &#123;</span><br><span class="line">            c-&gt;flags &amp;= ~ CLIENT_PENDING_COMMAND;</span><br><span class="line">            processCommandAndResetClient(c);</span><br><span class="line">        &#125;</span><br><span class="line">        processInputBufferAndReplicate(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空client_pending_read</span></span><br><span class="line">    listEmpty(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何处理读请求？<br>在上面的过程中，当任务分发完毕后，每个线程按照正常流程将自己负责的Client的读取缓冲区的内容进行处理，和原来的单线程没有太大差异。</p>
<p>每轮处理中，需要将各个线程的锁开启，打开标志：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) &#123; <span class="built_in">printf</span>(<span class="string">&quot;S&quot;</span>); fflush(<span class="built_in">stdout</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;--- STARTING THREADED IO ---\n&quot;</span>);</span><br><span class="line">    serverAssert(io_threads_active == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">        <span class="comment">// 解开线程的锁定状态</span></span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[j]);</span><br><span class="line">    <span class="comment">// 现在可以开始多线程IO执行对应读/写任务</span></span><br><span class="line">    io_threads_active = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样结束时，首先需要检查是否有剩余待读的IO，如果没有，将线程锁定，标志关闭：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要停止的时候可能还有等待读的Client 在停止前进行处理</span></span><br><span class="line">    handleClientsWithPendingReadsUsingThreads();</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) &#123; <span class="built_in">printf</span>(<span class="string">&quot;E&quot;</span>); fflush(<span class="built_in">stdout</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;--- STOPPING THREADED IO [R%d] [W%d] ---\n&quot;</span>,</span><br><span class="line">        (<span class="keyword">int</span>) listLength(server.clients_pending_read),</span><br><span class="line">        (<span class="keyword">int</span>) listLength(server.clients_pending_write));</span><br><span class="line">    serverAssert(io_threads_active == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">        <span class="comment">// 本轮IO结束 将所有线程上锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[j]);</span><br><span class="line">    <span class="comment">// IO状态设置为关闭</span></span><br><span class="line">    io_threads_active = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.3 写入返回缓冲区<br>众多的<code>addReply*()</code>方法最终会调用<code>_addReplyToBuffer()</code>函数在缓冲区中添加回复数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _addReplyToBuffer(client *c, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> available = <span class="keyword">sizeof</span>(c-&gt;buf)-c-&gt;bufpos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正准备关闭客户端，无需回复任何内容</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果回复列表中已经有内容，则无法向静态缓冲区添加更多内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;reply) &gt; <span class="number">0</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查缓冲区是否有足够的空间用于该字符串 */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; available) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内容追加到c-&gt;buf中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;buf+c-&gt;bufpos,s,len);</span><br><span class="line">    c-&gt;bufpos+=len;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用<code>_addReplyToBuffer()</code>函数失败，将会调用另一个函数<code>_addReplyProtoToList()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _addReplyProtoToList(client *c, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    listNode *ln = listLast(c-&gt;reply);</span><br><span class="line">    clientReplyBlock *tail = ln? listNodeValue(ln): <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that &#x27;tail&#x27; may be NULL even if we have a tail node, becuase when</span></span><br><span class="line"><span class="comment">     * addDeferredMultiBulkLength() is used, it sets a dummy node to NULL just</span></span><br><span class="line"><span class="comment">     * fo fill it later, when the size of the bulk length is set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Append to tail string when possible. */</span></span><br><span class="line">    <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">        <span class="comment">/* Copy the part we can fit into the tail, and leave the rest for a</span></span><br><span class="line"><span class="comment">         * new node */</span></span><br><span class="line">        <span class="keyword">size_t</span> avail = tail-&gt;size - tail-&gt;used;</span><br><span class="line">        <span class="keyword">size_t</span> copy = avail &gt;= len? len: avail;</span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf + tail-&gt;used, s, copy);</span><br><span class="line">        tail-&gt;used += copy;</span><br><span class="line">        s += copy;</span><br><span class="line">        len -= copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        <span class="comment">/* Create a new node, make sure it is allocated to at</span></span><br><span class="line"><span class="comment">         * least PROTO_REPLY_CHUNK_BYTES */</span></span><br><span class="line">        <span class="keyword">size_t</span> size = len &lt; PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;</span><br><span class="line">        tail = zmalloc(size + <span class="keyword">sizeof</span>(clientReplyBlock));</span><br><span class="line">        <span class="comment">/* take over the allocation&#x27;s internal fragmentation */</span></span><br><span class="line">        tail-&gt;size = zmalloc_usable(tail) - <span class="keyword">sizeof</span>(clientReplyBlock);</span><br><span class="line">        tail-&gt;used = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf, s, len);</span><br><span class="line">        listAddNodeTail(c-&gt;reply, tail);</span><br><span class="line">        c-&gt;reply_bytes += tail-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    asyncCloseClientOnOutputBufferLimitReached(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>4-net</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-事务</title>
    <url>/Redis/3-database/redis-parse-multi/</url>
    <content><![CDATA[<p>源码位置：multi.c/redis.h</p>
<p><strong>1. 简介</strong><br>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<a id="more"></a>
<p>Redis事务的ACID特性：</p>
<p><strong>A原子性（atomicity）</strong><br>单个Redis命令的执行是原子性的，但Redis没有在事务上增加任何维护原子性的机制，所以<strong>Redis事务的执行不是原子性</strong>的。<br>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败<br>事务失败时，Redis 也不会进行任何的重试或者回滚动作，不满足要么全部全部执行，要么都不执行的条件</p>
<p><strong>C一致性（consistency）：</strong><br>一致性分下面几种情况来讨论：</p>
<p>首先，如果一个事务的指令全部被执行，那么数据库的状态是满足数据库完整性约束的</p>
<p>其次，如果一个事务中有的指令有错误，那么数据库的状态是满足数据完整性约束的</p>
<p>最后，如果事务运行到某条指令时，进程被kill掉了，那么要分下面几种情况讨论：</p>
<ul>
<li>如果当前redis采用的是内存模式，那么重启之后redis数据库是空的，那么满足一致性条件</li>
<li>如果当前采用RDB模式存储的，在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。 恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数 据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的</li>
<li>如果当前采用的是AOF存储的，那么可能事务的内容还未写入到AOF文件，那么此时肯定是满足一致性的，如果事务的内容有部分写入到AOF文件中，那么需要用工具把AOF中事务执行部分成功的指令移除，这时，移除之后的AOF文件也是满足一致性的</li>
</ul>
<p>所以，<strong>redis事务满足一致性约束</strong>。</p>
<p><strong>I隔离性（isolation）：</strong><br>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性</strong>的。</p>
<p><strong>D持久性（durability）：</strong><br>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定</p>
<ul>
<li>在单纯的内存模式下，事务肯定是不持久的</li>
<li>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的</li>
<li>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync 或 fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</li>
<li>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</li>
</ul>
<p><strong>2. 命令介绍</strong><br>下面介绍命令的使用详情：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>MULTI</td>
<td>标记一个事务的开始</td>
</tr>
<tr>
<td>DISCARD</td>
<td>取消事务，放弃执行事务块内的所有命令</td>
</tr>
<tr>
<td>EXEC</td>
<td>执行事务内的所有命令</td>
</tr>
<tr>
<td>WATCH key [key …]</td>
<td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断，不会被执行</td>
</tr>
<tr>
<td>UNWATCH</td>
<td>取消 WATCH 命令对所有 key 的监视</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3. 实现细节</strong><br>Redis事务从开始到结束通常分为三步：</p>
<ol>
<li>事务开始(MULTI)：MULTI命令可以将执行该命令的客户端从非事务状态切换成事务状态，这一切换是通过客户端状态的flags属性中打开 <code>CLIENT_MULTI</code> 标识完成的。</li>
<li>命令入队：切换到事务状态后，该客户端输入的所有命令，都会被暂存到一个命令队列里，不会立即执行。</li>
<li>事务执行(EXEX)：EXEC命令将命令队列里的命令挨个执行完成。</li>
</ol>
<p>Redis会把每个连接的客户端封装成一个client结构体，该结构体包含大量的字段用来保存需要的信息。其中，事务相关的字段如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    multiState mstate;</span><br><span class="line">    <span class="built_in">list</span> *watched_keys; <span class="comment">// 监视的key列表（节点结构：watchedKey）</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Client MULTI/EXEC state */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    robj **argv;    <span class="comment">/* 参数 */</span></span><br><span class="line">    <span class="keyword">int</span> argc;       <span class="comment">/* 参数数量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span>   <span class="comment">/* 命令本身 */</span></span><br><span class="line">&#125; multiCmd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">/* 事务命令队列 */</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">/* 队列中命令的数量 */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">int</span> minreplicas;        <span class="comment">/* 需要同步复制的最小数量 */</span></span><br><span class="line">    <span class="keyword">time_t</span> minreplicas_timeout; <span class="comment">/* 同步复制超时时间 */</span></span><br><span class="line">&#125; multiState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视列表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchedKey</span> &#123;</span></span><br><span class="line">    robj *key;      <span class="comment">/* watch的key*/</span></span><br><span class="line">    redisDb *db;    <span class="comment">/* 指向的db */</span></span><br><span class="line">&#125; watchedKey;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，客户端打开事务操作标识后，只有命令：EXEC、DISCARD、WATCH、MULTI命令会被立即执行，该逻辑在server.c文件中的processCommand方法中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Exec the command */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将命令插入队列</span></span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 立即执行</span></span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将命令插入队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    multiCmd *mc;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">            <span class="keyword">sizeof</span>(multiCmd)*(c-&gt;mstate.count+<span class="number">1</span>));</span><br><span class="line">    mc = c-&gt;mstate.commands+c-&gt;mstate.count;</span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv,c-&gt;argv,<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        incrRefCount(mc-&gt;argv[j]);</span><br><span class="line">    c-&gt;mstate.count++;</span><br><span class="line">    c-&gt;mstate.cmd_flags |= c-&gt;cmd-&gt;flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们考虑一下watch机制的触发时机，现在我们已经把想要watch的key加入到了watch的数据结构中，可以想到触发watch的时机应该是修改key的内容时，通知到所有watch了该key的客户端。该触发机制的源码在multi.c文件的<code>touchWatchedKey()</code>函数中实现。</p>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 设置客户端事务标识</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 执行命令队列中的命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 取消事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 监视一个或多个key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 取消监视</span></span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<p><strong>事务开始：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;MULTI calls can not be nested&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置客户端的事务标识</span></span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行事务：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> must_propagate = <span class="number">0</span>; <span class="comment">// 标记是否需要把MULTI/EXEC传递到AOF或者slaves节点</span></span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>; <span class="comment">// 标记当前redis节点是否为主节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有处于事务状态，则返回错误提示信息</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;EXEC without MULTI&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先对两个需要终止当前事务的条件进行判断:</span></span><br><span class="line"><span class="comment">     * 1) 当有WATCH的key被修改时则终止，返回一个nullmultibulk对象</span></span><br><span class="line"><span class="comment">     * 2) 当之前有命令加入事务命令数组出错则终止，例如传入的命令参数数量不对，会返回execaborterr */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">        addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                                                   shared.nullarray[c-&gt;resp]);</span><br><span class="line">        <span class="comment">// 删除当前事务信息</span></span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">goto</span> handle_monitor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果事务命令中有写的操作，并且当前redis节点为只读slave节点，将返回错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (!server.loading &amp;&amp; server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; c-&gt;mstate.cmd_flags &amp; CMD_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;Transaction contains write commands but instance &quot;</span></span><br><span class="line">            <span class="string">&quot;is now a read-only replica. EXEC aborted.&quot;</span>);</span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">goto</span> handle_monitor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行队列中的所有命令 */</span></span><br><span class="line">    unwatchAllKeys(c); <span class="comment">/* 把watch的key都删除 */</span></span><br><span class="line">    <span class="comment">// 保存当前命令上下文</span></span><br><span class="line">    orig_argv = c-&gt;argv;</span><br><span class="line">    orig_argc = c-&gt;argc;</span><br><span class="line">    orig_cmd = c-&gt;cmd;</span><br><span class="line">    addReplyArrayLen(c,c-&gt;mstate.count);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 同步事务操作到AOF或者集群中的从节点. */</span></span><br><span class="line">        <span class="keyword">if</span> (!must_propagate &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; (CMD_READONLY|CMD_ADMIN))) &#123;</span><br><span class="line">            execCommandPropagateMulti(c);</span><br><span class="line">            must_propagate = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> acl_keypos;</span><br><span class="line">        <span class="keyword">int</span> acl_retval = ACLCheckCommandPerm(c,&amp;acl_keypos);</span><br><span class="line">        <span class="keyword">if</span> (acl_retval != ACL_OK) &#123;</span><br><span class="line">            addACLLogEntry(c,acl_retval,acl_keypos,<span class="literal">NULL</span>);</span><br><span class="line">            addReplyErrorFormat(c,</span><br><span class="line">                <span class="string">&quot;-NOPERM ACLs rules changed between the moment the &quot;</span></span><br><span class="line">                <span class="string">&quot;transaction was accumulated and the EXEC call. &quot;</span></span><br><span class="line">                <span class="string">&quot;This command is no longer allowed for the &quot;</span></span><br><span class="line">                <span class="string">&quot;following reason: %s&quot;</span>,</span><br><span class="line">                (acl_retval == ACL_DENIED_CMD) ?</span><br><span class="line">                <span class="string">&quot;no permission to execute the command or subcommand&quot;</span> :</span><br><span class="line">                <span class="string">&quot;no permission to touch the specified keys&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            call(c,server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 由于命令可以修改参数的值或者数量，因此重新保存命令上下文 */</span></span><br><span class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复原始命令上下文</span></span><br><span class="line">    c-&gt;argv = orig_argv;</span><br><span class="line">    c-&gt;argc = orig_argc;</span><br><span class="line">    c-&gt;cmd = orig_cmd;</span><br><span class="line">    <span class="comment">// 事务执行完成，删除该事务</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保EXEC会进行传递 */</span></span><br><span class="line">    <span class="keyword">if</span> (must_propagate) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog &amp;&amp; was_master &amp;&amp; !is_master) &#123;</span><br><span class="line">            <span class="keyword">char</span> *execcmd = <span class="string">&quot;*1\r\n$4\r\nEXEC\r\n&quot;</span>;</span><br><span class="line">            feedReplicationBacklog(execcmd,<span class="built_in">strlen</span>(execcmd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">handle_monitor:</span><br><span class="line">    <span class="comment">/* monitor命令操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp; !server.loading)</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>取消事务：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;DISCARD without MULTI&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的删除逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="comment">// 状态位还原</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);</span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放事务中的所有命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeClientMultiState</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        multiCmd *mc = c-&gt;mstate.commands+j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mc-&gt;argc; i++)</span><br><span class="line">            decrRefCount(mc-&gt;argv[i]);</span><br><span class="line">        zfree(mc-&gt;argv);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(c-&gt;mstate.commands);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事务相关字段设为初始值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initClientMultiState</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;mstate.commands = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;mstate.count = <span class="number">0</span>;</span><br><span class="line">    c-&gt;mstate.cmd_flags = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>watch监视：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;WATCH inside MULTI is not allowed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        watchForKey(c,c-&gt;argv[j]);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    watchedKey *wk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断key是否已经被watch过 */</span></span><br><span class="line">    listRewind(c-&gt;watched_keys,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key,wk-&gt;key))</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果未被watch，则将key加入到列表中</span></span><br><span class="line"><span class="comment">     * 整个watch操作保存了两套数据结构，一套是在db-&gt;watched_keys中的字典结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys,key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) &#123;</span><br><span class="line">        clients = listCreate();</span><br><span class="line">        dictAdd(c-&gt;db-&gt;watched_keys,key,clients);</span><br><span class="line">        incrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    listAddNodeTail(clients,c);</span><br><span class="line">    <span class="comment">/* 另一套是在c-&gt;watched_keys中的链表结构 */</span></span><br><span class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</span><br><span class="line">    wk-&gt;key = key;</span><br><span class="line">    wk-&gt;db = c-&gt;db;</span><br><span class="line">    incrRefCount(key);</span><br><span class="line">    listAddNodeTail(c-&gt;watched_keys,wk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>unwatch取消监视：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">    <span class="comment">// 修改客户端状态</span></span><br><span class="line">    c-&gt;flags &amp;= (~CLIENT_DIRTY_CAS);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchAllKeys</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="comment">// 如果客户端没有watch任何key，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    listRewind(c-&gt;watched_keys,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        <span class="built_in">list</span> *clients;</span><br><span class="line">        watchedKey *wk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 遍历取出该客户端watch的key */</span></span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        clients = dictFetchValue(wk-&gt;db-&gt;watched_keys, wk-&gt;key);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,clients != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,listSearchKey(clients,c));</span><br><span class="line">        <span class="comment">/* Kill the entry at all if this was the only client */</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>)</span><br><span class="line">            dictDelete(wk-&gt;db-&gt;watched_keys, wk-&gt;key);</span><br><span class="line">        <span class="comment">/* Remove this watched key from the client-&gt;watched list */</span></span><br><span class="line">        listDelNode(c-&gt;watched_keys,ln);</span><br><span class="line">        decrRefCount(wk-&gt;key);</span><br><span class="line">        zfree(wk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>3-database</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-发布和订阅</title>
    <url>/Redis/3-database/redis-parse-pubsub/</url>
    <content><![CDATA[<p>源码位置：pubsub.c/redis.h</p>
<p><strong>1. 前言</strong><br>Redis发布订阅(pub/sub)是一种消息通信模式，由三部分组成：发布者(pub)，频道(channel)，订阅者(sub)。具体结构如下：</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/10/29/ujSpaOfrmVAbRyd.png" alt="pubsub1.png"><br>发布者和订阅者都是Redis客户端，频道是Redis服务端，发布者将消息发布到某一频道上，订阅了这一频道的订阅者就会收到该条信息。Redis客户端可订阅任意数量的频道。<br>Redis的发布订阅功能并不保证可靠，因为所有数据都存在内存中，没有提供持久化的功能，也不记录消费端状态，所以相对市面上的一些消息队列相比（如kafka、rabittMQ等），可靠性会差很多。在Redis5.0版本的stream消息队列功能发布之前，会有使用者使用redis-list来实现消息队列和发布订阅的功能，虽然有持久化（AOF &amp; RDB）的功能，但是实现起来比较笨拙，不够方便。</p>
<p>pubsub与stream比较：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>pub/sub</th>
<th>stream</th>
</tr>
</thead>
<tbody>
<tr>
<td>不能持久化消息</td>
<td>可以持久化，支持RDB和AOF两种持久化机制</td>
</tr>
<tr>
<td>没有消息队列中群组的概念</td>
<td>引入了消费组的概念</td>
</tr>
<tr>
<td>redis客户端断线重连会丢失中间的数据</td>
<td>支持position，能够消费历史消息。断线后支持消息继续从上次的时间点读取，不会丢失消息，也可以直接读取最新消息</td>
</tr>
<tr>
<td>redis断线后需要重新订阅</td>
<td></td>
<td>不存在这个问题</td>
</tr>
<tr>
<td>没有ack机制</td>
<td>有ACK机制，能够一定程度保证消息“at least once” 消费</td>
</tr>
</tbody>
</table>
</div>
<p>基于stream消息队列的多种好处，pub/sub功能仅做源码学习，实际项目中推荐使用stream或者kafka等消息队列。</p>
<p><strong>2. 命令介绍</strong><br>下面介绍命令的使用详情：</p>
<ul>
<li>PSUBSCRIBE pattern [pattern1 ….]<ul>
<li>说明：订阅一个或多个符合给定模式的频道，每个模式以*作为匹配符</li>
<li>参数：pattern(给定的模式)</li>
<li>返回：接受到的信息</li>
</ul>
</li>
<li>PUNSUBSCRIBE pattern [pattern1 ….]<ul>
<li>说明：用于退订所有给定模式的频道</li>
<li>参数：pattern(给定的模式)</li>
<li>返回：这个命令在不同的客户端中有不同的表现。</li>
</ul>
</li>
<li>SUBSCRIBE channel [channel1 …]<ul>
<li>说明：用于订阅给定的一个或多个频道的信息</li>
<li>参数：channel(给定的频道名)</li>
<li>返回：接收到的信息</li>
</ul>
</li>
<li>UNSUBSCRIBE channel [channel1 …]<ul>
<li>说明：用于退订给定的一个或多个频道的信息</li>
<li>参数：channel(给定的频道名)</li>
<li>返回：这个命令在不同的客户端中有不同的表现</li>
</ul>
</li>
<li>PUBLISH channel message<ul>
<li>说明：用于将信息发送到指定的频道</li>
<li>参数：channel(频道名称)，message(将要发送的信息)</li>
<li>返回：接收到此消息的订阅者数量</li>
</ul>
</li>
<li>PUBSUB &lt; subcommand &gt; argument [argument1 ….]<ul>
<li>说明：用于查看订阅与发布系统状态，它由数个不同格式的子命令组成</li>
<li>参数：subcommand(子命令)，argument(子命令参数)</li>
<li>返回：由活跃频道组成的列表</li>
</ul>
</li>
</ul>
<p>子命令如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>subcommand</th>
<th>argument</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHANNELS</td>
<td>[pattern]</td>
<td>返回指定模式pattern的活跃的频道,指定返回由SUBSCRIBE订阅的频道</td>
</tr>
<tr>
<td>NUMSUB</td>
<td>channel channel2 …</td>
<td>返回指定频道的订阅数量</td>
</tr>
<tr>
<td>NUMPAT</td>
<td></td>
<td>返回订阅模式的数量，注意：这个命令返回的不是订阅模式的客户端的数量， 而是客户端订阅的所有模式的数量总和</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3. 实现原理</strong><br>每个 Redis 服务器进程维持着一个标识服务器状态 的 redis.h/redisServer 结构，其中就 保存着有订阅的频道 以及 订阅模式 的信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Pubsub */</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* 订阅频道（字典数据结构） */</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* 订阅模式（列表结构） */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* 该客户端订阅的频道 */</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* 该客户端订阅的模式 */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.在Redis服务端内部维护了一个 <code>pubsub_channels</code> 的channel列表，记录了此客户端所订阅的频道。</p>
<p>2.当客户端订阅某一个频道之后，Redis服务端就会往自身的 <code>pubsub_channels</code> 这个字典变量中新添加一条数据，实际上这个 dict 字典维护的是一张链表，比如，下图展示的 pubsub_channels 示例中，client 1、client 2 就订阅了 channel 1，而其他频道也分别被其他客户端订阅：<br><img src="https://i.loli.net/2020/10/29/WBJRmu3PDoazsct.png" alt="pubsub2.png"></p>
<p>3.当一个Redis客户端publish一个message的时候，会先去服务端的 <code>pubsub_channels</code> 找相应的channel，遍历里面的client，然后发送通知，即完成了整个发布订阅的流程。</p>
</blockquote>
<p>下面我们通过代码来看看pub/sub的实现吧。</p>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Pubsub commands implementation */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于订阅给定的一个或多个频道的信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于退订给定的一个或多个频道的信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psubscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 订阅一个或多个符合给定模式的频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">punsubscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于退订所有给定模式的频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于将信息发送到指定的频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pubsubCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于查看订阅与发布系统状态 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pubsub low level API */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freePubsubPattern</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; <span class="comment">/* 释放发布订阅的模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listMatchPubsubPattern</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span>; <span class="comment">/* 发布订阅模式是否匹配 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clientSubscriptionsCount</span><span class="params">(redisClient *c)</span></span>; <span class="comment">/* 返回客户端的所订阅的数量，包括channels + patterns频道和模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(redisClient *c, robj *channel)</span></span>; <span class="comment">/* Client订阅一个Channel频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeChannel</span><span class="params">(redisClient *c, robj *channel, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* 取消订阅Client中的Channel */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribePattern</span><span class="params">(redisClient *c, robj *pattern)</span></span>; <span class="comment">/* Client客户端订阅一种模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribePattern</span><span class="params">(redisClient *c, robj *pattern, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* Client客户端取消订阅pattern模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllChannels</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* 客户端取消自身订阅的所有Channel */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllPatterns</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* 客户端取消订阅所有的pattern模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span></span>; <span class="comment">/* 为所有订阅了Channel的Client发送消息message */</span></span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<p><strong>Redis客户端订阅频道：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        pubsubSubscribeChannel(c,c-&gt;argv[j]);</span><br><span class="line">    <span class="comment">// 添加pubsub订阅标识，方便其他地方判断</span></span><br><span class="line">    c-&gt;flags |= CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(client *c, robj *channel)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step.1 将要订阅的 channel 添加到各自客户端的 pubsub_channels 容器中 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(c-&gt;pubsub_channels,channel,<span class="literal">NULL</span>) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        incrRefCount(channel);</span><br><span class="line">        <span class="comment">/* step.2 将要订阅的channel 添加到 server.pubsub_channels 中, 方便在publish时判定是否触发通知 */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果此频道的client列表为空，则创建新列表并添加</span></span><br><span class="line">            clients = listCreate();</span><br><span class="line">            dictAdd(server.pubsub_channels,channel,clients);</span><br><span class="line">            incrRefCount(channel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，获取频道的客户端列表，在尾部添加新的元素</span></span><br><span class="line">            clients = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* step.3 将客户端自身添加到相应的 server.pubsub_channels 对应的队列中去, 在通知时只需遍历该队列即可 */</span></span><br><span class="line">        listAddNodeTail(clients,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 回复客户端 */</span></span><br><span class="line">    addReplyPubsubSubscribed(c,channel);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端订阅的总channel数, 两种订阅方式相加</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clientSubscriptionsCount</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictSize(c-&gt;pubsub_channels)+</span><br><span class="line">           listLength(c-&gt;pubsub_patterns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>客户端自行管理需要订阅的channel, 放到 c-&gt;pubsub_channels 中;</li>
<li>redis使用的一个统一的 server-&gt;pubsub_channels dict容器进行管理所有的channel;</li>
<li>对于多个客户端订阅一个channel, redis 使用list进行管理追加;</li>
</ol>
<p><strong>Redis客户端退订频道：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">        pubsubUnsubscribeAllChannels(c,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">            pubsubUnsubscribeChannel(c,c-&gt;argv[j],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 退订所有频道，返回退订的数目 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllChannels</span><span class="params">(client *c, <span class="keyword">int</span> notify)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = dictGetSafeIterator(c-&gt;pubsub_channels);</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历该客户端订阅的所有频道并退订</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *channel = dictGetKey(de);</span><br><span class="line"></span><br><span class="line">        count += pubsubUnsubscribeChannel(c,channel,notify);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We were subscribed to nothing? Still reply to the client. */</span></span><br><span class="line">    <span class="keyword">if</span> (notify &amp;&amp; count == <span class="number">0</span>) addReplyPubsubUnsubscribed(c,<span class="literal">NULL</span>);</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeChannel</span><span class="params">(client *c, robj *channel, <span class="keyword">int</span> notify)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从client.pubsub_channels中移除频道 */</span></span><br><span class="line">    incrRefCount(channel);</span><br><span class="line">    <span class="keyword">if</span> (dictDelete(c-&gt;pubsub_channels,channel) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 从server.pubsub_channels中移除频道 */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</span><br><span class="line">        clients = dictGetVal(de);</span><br><span class="line">        ln = listSearchKey(clients,c);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,ln);</span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果列表中没有数据了，就移除频道列表</span></span><br><span class="line">            dictDelete(server.pubsub_channels,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (notify) addReplyPubsubUnsubscribed(c,channel);</span><br><span class="line">    decrRefCount(channel); <span class="comment">/* it is finally safe to release it */</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>3-database</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-对象系统object</title>
    <url>/Redis/2-object/redis-parse-object/</url>
    <content><![CDATA[<p>源码位置：object.c/server.h</p>
<p>在之前的文章中，我们介绍了redis底层的数据结构，比如简单动态字符串，双端链表，跳跃表，字典，整数集合，压缩列表，快速列表，基数树，紧凑列表等。<br><a id="more"></a><br>然而Redis没有用这些数据结构来实现键值对的数据库，而是在这些数据结构之上又封装了一层RedisObject，RedisObject有6种类型：string字符串，hash散列，set集合，zset有序集合，list列表，stream消息队列这些类型是面向用户的，有些对象内部至少有两种编码方式，不同的编码方式适用于不同的使用场景。<br>Redis对象带有引用计数功能，类似于智能指针，当引用计数为0时，对象将会被自动释放。<br>Redis还会对每一个对象记录其最近被使用时间，从而计算对象的空转时长，便于在适当的时候释放内存。</p>
<p>redis对象的类型和其对应使用的编码方式（数据结构）：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>type</th>
<th>encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_STRING</td>
<td>OBJ_ENCODING_RAW ,OBJ_ENCODING_INT ,OBJ_ENCODING_EMBSTR</td>
</tr>
<tr>
<td>OBJ_LIST</td>
<td>OBJ_ENCODING_QUICKLIST</td>
</tr>
<tr>
<td>OBJ_SET</td>
<td>OBJ_ENCODING_INTSET ,OBJ_ENCODING_HT</td>
</tr>
<tr>
<td>OBJ_ZSET</td>
<td>OBJ_ENCODING_ZIPLIST ,OBJ_ENCODING_SKIPLIST</td>
</tr>
<tr>
<td>OBJ_HASH</td>
<td>OBJ_ENCODING_ZIPLIST ,OBJ_ENCODING_HT</td>
</tr>
<tr>
<td>OBJ_STREAM</td>
<td>OBJ_ENCODING_STREAM</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type：标识redis对象的七种类型，占用4个位</span></span><br><span class="line"><span class="comment">encoding：标识redis对象的编码方式，也就是ptr所指向的数据用何种数据结构作为底层实现方式，占用4个位</span></span><br><span class="line"><span class="comment">lru:最后一次被访问的时间，占用24个位</span></span><br><span class="line"><span class="comment">refcount：引用计数，实现自动内存回收机制。</span></span><br><span class="line"><span class="comment">    1. 当创建一个对象时，其引用计数初始化为1；</span></span><br><span class="line"><span class="comment">    2. 当这个对象被一个新程序使用时，其引用计数加1；</span></span><br><span class="line"><span class="comment">    3. 当这个对象不再被一个程序使用时，其引用计数减1；</span></span><br><span class="line"><span class="comment">    4. 当引用计数为0时，释放该对象，回收内存。</span></span><br><span class="line"><span class="comment">ptr：指向真正的存储结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 七种对象类型 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_MODULE 5    <span class="comment">/* Module object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STREAM 6    <span class="comment">/* Stream object. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 11种对象编码类型，不同的对象类型会根据实际情况选择不同的编码类型 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span> <span class="comment">// sds简单动态字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span> <span class="comment">// long类型的整数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span> <span class="comment">// dict字典</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span> <span class="comment">// 不再使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span> <span class="comment">// adlist双端链表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span> <span class="comment">// ziplist压缩列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span> <span class="comment">// intset整数集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span> <span class="comment">// skiplist跳跃表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span> <span class="comment">// EMBSTR编码的简单动态字符串sds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span> <span class="comment">// quicklist快速列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span> <span class="comment">// stream消息队列</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当字符串小于44字节时，使用EMBSTR编码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Redis object implementation */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span></span>; <span class="comment">// 引用计数减1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCountVoid</span><span class="params">(<span class="keyword">void</span> *o)</span></span>; <span class="comment">// 调用decrRefCount</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span></span>; <span class="comment">// 引用计数加1</span></span><br><span class="line"><span class="function">robj *<span class="title">makeObjectShared</span><span class="params">(robj *o)</span></span>; <span class="comment">// 共享对象，将引用计数设定为一个特殊值OBJ_SHARED_REFCOUNT(INT_MAX)</span></span><br><span class="line"><span class="function">robj *<span class="title">resetRefCount</span><span class="params">(robj *obj)</span></span>; <span class="comment">// 将引用计数置为0</span></span><br><span class="line"><span class="comment">// free object-------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放字符串对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放列表对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放有序集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放哈希对象</span></span><br><span class="line"><span class="comment">// ------------------------</span></span><br><span class="line"><span class="comment">// create object-----------</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 创建对象，设定类型</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建SDS的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建EMBSTR编码的字符串对象</span></span><br><span class="line"><span class="comment">// ------------------------</span></span><br><span class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(<span class="keyword">const</span> robj *o)</span></span>; <span class="comment">// 复制string对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSdsRepresentableAsLongLong</span><span class="params">(sds s, <span class="keyword">long</span> <span class="keyword">long</span> *llval)</span></span>; <span class="comment">// sds转为long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isObjectRepresentableAsLongLong</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *llongval)</span></span>; <span class="comment">// 判断一个对象是否能用long long表示</span></span><br><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span></span>; <span class="comment">// 尝试对字符串对象进行编码，以节省空间，如果无法压缩，则增加引用计数</span></span><br><span class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 获取字符串编码对象的解码版本，能解码则返回一个新的对象，不能则增加引用计数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">stringObjectLen</span><span class="params">(robj *o)</span></span>; <span class="comment">// 获取字符串对象的长度</span></span><br><span class="line"><span class="comment">// create object-----------</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>; <span class="comment">// 根据传入的longlong整型值，创建一个字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLongForValue</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value, <span class="keyword">int</span> humanfriendly)</span></span>; <span class="comment">// 根据传入的long double类型值，创建一个字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createQuicklistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建快速列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建压缩列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建整数集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建hash对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建有序集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建压缩列表编码的有序集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStreamObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建消息队列对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createModuleObject</span><span class="params">(moduleType *mt, <span class="keyword">void</span> *value)</span></span>; <span class="comment">// 创建模块对象</span></span><br><span class="line"><span class="comment">// -------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// getLongLongFromObject函数的封装，如果发生错误可以发回指定响应消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkType</span><span class="params">(client *c, robj *o, <span class="keyword">int</span> type)</span></span>; <span class="comment">// 检查o的类型是否与type一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// getLongLongFromObject的封装，如果发生错误则可以发出指定的错误消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// getDoubleFromObject的封装，如果发生错误可以发回指定响应消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObject</span><span class="params">(<span class="keyword">const</span> robj *o, <span class="keyword">double</span> *target)</span></span>; <span class="comment">// 从字符串对象中解码出一个double类型的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target)</span></span>; <span class="comment">// 从字符串对象中解码出一个long long类型的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongDoubleFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">double</span> *target)</span></span>; <span class="comment">// 从字符串对象中解码出一个long double类型的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongDoubleFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">long</span> <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// getLongDoubleFromObject的封装，如果发生错误可以发回指定响应消息</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strEncoding</span><span class="params">(<span class="keyword">int</span> encoding)</span></span>; <span class="comment">// 返回编码对应的字符串名称</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 以二进制方式比较两个字符串对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">collateStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 以本地指定的文字排列次序coll方式比较两个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">equalStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 比较两个字符串对象是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span></span>; <span class="comment">// 计算给定对象的闲置时长，使用近似LRU算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimStringObjectIfNeeded</span><span class="params">(robj *o)</span></span>; <span class="comment">// 优化字符串对象中的SDS字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW || objptr-&gt;encoding == OBJ_ENCODING_EMBSTR)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>2-object</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-快速列表quicklist</title>
    <url>/Redis/1-data-structure/redis-parse-quicklist/</url>
    <content><![CDATA[<p>源码位置：quicklist.c/quicklist.h</p>
<p>Redis3.2版本以前的列表底层的编码是ziplist和linkedlist(adlist.c)实现的，3.2版本后引入了quicklist的数据结构，列表底层都由quicklist来实现。本质上，quicklist是由ziplist和linkedlist结合而成。所以，学习quicklist之前，需要明白<a href="../redis-parse-zskiplist">ziplist</a>的原理。<br><a id="more"></a><br><strong>ziplist：</strong><br>优点：存储效率高，内存开销少。<br>缺点：进行插入、修改、删除操作时，需要频繁的申请和释放内存，当ziplist很长时，一次realloc可能会导致很大的内存拷贝。ziplist操作还有可能进行连锁更新操作，时间复杂度增加。<br><strong>linkedlist：</strong><br>优点：便于在两端进行push或pop操作时间复杂度低。<br>缺点：内存开销大，因为是不连续的内存块，所以节点多了容易产生内存碎片。<br><strong>quicklist：</strong><br>quicklist本质上节点为ziplist的双向链表的数据结构，所以quicklist结合了两者的优点。<br>从存储效率上分析：</p>
<ol>
<li>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能产生很多无法利用的内存碎片，导致存储效率降低。</li>
<li>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续的内存空间难度就越大。有可能出现内存里有很多小的空闲空间无法使用，同样会导致存储效率降低。  </li>
</ol>
<p>所以ziplist的长度，需要根据实际使用场景来进行调整，redis提供了配置参数list-max-ziplist-size，可供使用者来进行设定。</p>
<p><strong>quicklist结构：</strong><br><img src="https://i.loli.net/2020/10/29/t3kdbfizKcxwsGV.png" alt="quicklist.png"></p>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;           <span class="comment">// 压缩列表ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">// 表示指向ziplist结构的总长度(内存占用长度)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">// ziplist中的节点数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">// ziplist是否压缩。取值：1--ziplist，2--quicklistLZF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">// 存储类型，目前使用固定值2 表示使用ziplist存储</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">// 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span> <span class="comment">// // 测试相关</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span> <span class="comment">// // 扩展字段，暂时没用</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span> <span class="comment">// 压缩后的ziplist大小</span></span><br><span class="line">    <span class="keyword">char</span> compressed[]; <span class="comment">// 柔性数组，存放压缩后的ziplist字节数组</span></span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistBookmark</span> &#123;</span></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">&#125; quicklistBookmark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="keyword">int</span> fill : QL_FILL_BITS;              <span class="comment">/* fill factor for individual nodes */</span> <span class="comment">// 负数代表级别，正数代表个数，配置文件中定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span> <span class="comment">// 压缩级别，配置文件中定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bookmark_count: QL_BM_BITS; <span class="comment">// 书签数，测试用</span></span><br><span class="line">    quicklistBookmark bookmarks[]; <span class="comment">// 书签，测试用</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fill和compress由配置文件redis.conf定义。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">fill成员对应的配置：list-max-ziplist-size -2</span></span><br><span class="line"><span class="comment">当数字为负数，表示以下含义：</span></span><br><span class="line"><span class="comment">-1 每个quicklistNode节点的ziplist字节大小不能超过4kb。（建议）</span></span><br><span class="line"><span class="comment">-2 每个quicklistNode节点的ziplist字节大小不能超过8kb。（默认配置）</span></span><br><span class="line"><span class="comment">-3 每个quicklistNode节点的ziplist字节大小不能超过16kb。（一般不建议）</span></span><br><span class="line"><span class="comment">-4 每个quicklistNode节点的ziplist字节大小不能超过32kb。（不建议）</span></span><br><span class="line"><span class="comment">-5 每个quicklistNode节点的ziplist字节大小不能超过64kb。（正常工作量不建议）</span></span><br><span class="line"><span class="comment">代码中的定义static const size_t optimization_level[] = &#123;4096, 8192, 16384, 32768, 65536&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当数字为正数，表示：ziplist结构所最多包含的entry个数。最大值为 215215。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">compress成员对应的配置：list-compress-depth 0</span></span><br><span class="line"><span class="comment">后面的数字有以下含义：</span></span><br><span class="line"><span class="comment">0： 表示不压缩。（默认）</span></span><br><span class="line"><span class="comment">1： 表示quicklist列表的两端各有1个节点不压缩，中间的节点压缩。</span></span><br><span class="line"><span class="comment">2： 表示quicklist列表的两端各有2个节点不压缩，中间的节点压缩。</span></span><br><span class="line"><span class="comment">3： 表示quicklist列表的两端各有3个节点不压缩，中间的节点压缩。</span></span><br><span class="line"><span class="comment">以此类推，最大为 216216。</span></span><br><span class="line"><span class="comment">首位节点不压缩，是因为支持快速的push/pop操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *current;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;</span><br><span class="line">    <span class="keyword">long</span> offset; <span class="comment">/* offset in current ziplist */</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; quicklistIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间结构，用于查找、删除等操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist; <span class="comment">// quicklist</span></span><br><span class="line">    quicklistNode *node; <span class="comment">// 当前的节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi; <span class="comment">// ziplist结构指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value; <span class="comment">// 当前entry的数据，是字符串</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval; <span class="comment">// 当前entry的数据，是整数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">// 当前ziplist的字节数</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">// entry的当前偏移量</span></span><br><span class="line">&#125; quicklistEntry;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_TAIL -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist node encodings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_ENCODING_RAW 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_ENCODING_LZF 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist compression disable */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NOCOMPRESS 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist container formats */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_CONTAINER_NONE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_CONTAINER_ZIPLIST 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> quicklistNodeIsCompressed(node)                                        \</span></span><br><span class="line">    ((node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF)</span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Prototypes */</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建quicklist</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistNew</span><span class="params">(<span class="keyword">int</span> fill, <span class="keyword">int</span> compress)</span></span>; <span class="comment">// 创建quicklist并设定fill和compress</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistSetCompressDepth</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> depth)</span></span>; <span class="comment">// 设置quicklist的compress</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistSetFill</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> fill)</span></span>; <span class="comment">// 设置quicklist的fill</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistSetOptions</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> fill, <span class="keyword">int</span> depth)</span></span>; <span class="comment">// 设置quicklist的fill和compress</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRelease</span><span class="params">(quicklist *quicklist)</span></span>; <span class="comment">// 释放quicklist</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// 头部节点插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// 尾部节点插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> where)</span></span>; <span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistAppendZiplist</span><span class="params">(quicklist *quicklist, <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>; <span class="comment">// 向quicklist中插入一个已定义的ziplist（需要创建quicklistCreateNode）(浅拷贝)</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistAppendValuesFromZiplist</span><span class="params">(quicklist *quicklist,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>; <span class="comment">// 向quicklist复制ziplist中的值（深拷贝）</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistCreateFromZiplist</span><span class="params">(<span class="keyword">int</span> fill, <span class="keyword">int</span> compress,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>; <span class="comment">//创建quicklist并复制ziplist中的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertAfter</span><span class="params">(quicklist *quicklist, quicklistEntry *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertBefore</span><span class="params">(quicklist *quicklist, quicklistEntry *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span></span>; <span class="comment">// 删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistReplaceAtIndex</span><span class="params">(quicklist *quicklist, <span class="keyword">long</span> index, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> sz)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> start, <span class="keyword">const</span> <span class="keyword">long</span> stop)</span></span>;</span><br><span class="line"><span class="function">quicklistIter *<span class="title">quicklistGetIterator</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"><span class="function">quicklistIter *<span class="title">quicklistGetIteratorAtIdx</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">int</span> direction, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistNext</span><span class="params">(quicklistIter *iter, quicklistEntry *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistReleaseIterator</span><span class="params">(quicklistIter *iter)</span></span>;</span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistDup</span><span class="params">(quicklist *orig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistIndex</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                   quicklistEntry *entry)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRewind</span><span class="params">(quicklist *quicklist, quicklistIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRewindTail</span><span class="params">(quicklist *quicklist, quicklistIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRotate</span><span class="params">(quicklist *quicklist)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPopCustom</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *sval,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *(*saver)(<span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> sz))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPop</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *slong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">quicklistCount</span><span class="params">(<span class="keyword">const</span> quicklist *ql)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistCompare</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p1, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p2, <span class="keyword">int</span> p2_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">quicklistGetLzf</span><span class="params">(<span class="keyword">const</span> quicklistNode *node, <span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bookmarks */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistBookmarkCreate</span><span class="params">(quicklist **ql_ref, <span class="keyword">const</span> <span class="keyword">char</span> *name, quicklistNode *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistBookmarkDelete</span><span class="params">(quicklist *ql, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">quicklistNode *<span class="title">quicklistBookmarkFind</span><span class="params">(quicklist *ql, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistBookmarksClear</span><span class="params">(quicklist *ql)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<p><strong>创建与释放：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// quicklist创建</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> *<span class="title">quicklist</span>;</span></span><br><span class="line"></span><br><span class="line">    quicklist = zmalloc(<span class="keyword">sizeof</span>(*quicklist));</span><br><span class="line">    quicklist-&gt;head = quicklist-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    quicklist-&gt;len = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;count = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;compress = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;fill = <span class="number">-2</span>;</span><br><span class="line">    quicklist-&gt;bookmark_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> quicklist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quicklistNode创建</span></span><br><span class="line"><span class="function">REDIS_STATIC quicklistNode *<span class="title">quicklistCreateNode</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    node = zmalloc(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">    node-&gt;zl = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;count = <span class="number">0</span>;</span><br><span class="line">    node-&gt;sz = <span class="number">0</span>;</span><br><span class="line">    node-&gt;next = node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;encoding = QUICKLIST_NODE_ENCODING_RAW;</span><br><span class="line">    node-&gt;container = QUICKLIST_NODE_CONTAINER_ZIPLIST;</span><br><span class="line">    node-&gt;recompress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRelease</span><span class="params">(quicklist *quicklist)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    quicklistNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = quicklist-&gt;head;</span><br><span class="line">    len = quicklist-&gt;len;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        zfree(current-&gt;zl);</span><br><span class="line">        quicklist-&gt;count -= current-&gt;count;</span><br><span class="line"></span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        quicklist-&gt;len--;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    quicklistBookmarksClear(quicklist);</span><br><span class="line">    zfree(quicklist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistBookmarksClear</span><span class="params">(quicklist *ql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ql-&gt;bookmark_count)</span><br><span class="line">        zfree(ql-&gt;bookmarks[--ql-&gt;bookmark_count].name);</span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> We do not shrink (realloc) the quick list. main use case for this</span></span><br><span class="line"><span class="comment">     * function is just before releasing the allocation. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>push操作：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="comment">// likely可以让编译器进行代码优化，表示告知编译器，括号里的值为真的可能性更大，这样编译器在编译过程中，会将可能性更大的代码紧跟着前面的代码，从而减少指令跳转带来的性能上的下降</span></span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            <span class="comment">// 判断头节点是否能插入新元素</span></span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 如果能插入，则调用ziplistPush插入新元素</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        <span class="comment">// 更新node的sz指针指向</span></span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不能插入，则创建一个新的quicklistNode用于插入新元素</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        <span class="comment">// 调用ziplistNew创建新的ziplist，并ziplistPush插入新元素</span></span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新node的sz指针指向</span></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新的node结点插入到quicklist头部</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_tail = quicklist-&gt;tail;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;tail-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;tail);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新的node结点插入到quicklist尾部</span></span><br><span class="line">        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;tail-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_tail != quicklist-&gt;tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node,</span><br><span class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ziplist_overhead; <span class="comment">// 根据sz来估算将要插入的entry的大小</span></span><br><span class="line">    <span class="comment">/* size of previous offset */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)   <span class="comment">// 根据ziplist的性质，计算entry的prevlen的编码大小，小于254为1位，大于等于254为5位</span></span><br><span class="line">        ziplist_overhead = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of forward offset */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)    <span class="comment">// 对entry的len进行编码，小于64为ZIP_STR_06B或者整数，1个字节</span></span><br><span class="line">        ziplist_overhead += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>)) <span class="comment">// 小于16384，为ZIP_STR_14B，2个字节</span></span><br><span class="line">        ziplist_overhead += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 否则为ZIP_STR_32B，5个字节</span></span><br><span class="line">        ziplist_overhead += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* new_sz overestimates if &#x27;sz&#x27; encodes to an integer type */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead; <span class="comment">// 插入元素后，大致计算出ziplist的大小（忽略连锁更新）</span></span><br><span class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill))) <span class="comment">// 是否超过ziplist设定的存储限制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz)) <span class="comment">// 判断是不是安全的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill) <span class="comment">// 最后判断个数限制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pop操作：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPop</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *slong)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">    <span class="keyword">if</span> (quicklist-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = quicklistPopCustom(quicklist, where, &amp;vstr, &amp;vlen, &amp;vlong,</span><br><span class="line">                                 _quicklistSaver);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        *data = vstr;</span><br><span class="line">    <span class="keyword">if</span> (slong)</span><br><span class="line">        *slong = vlong;</span><br><span class="line">    <span class="keyword">if</span> (sz)</span><br><span class="line">        *sz = vlen;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPopCustom</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *sval,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *(*saver)(<span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> sz))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">    <span class="keyword">int</span> pos = (where == QUICKLIST_HEAD) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quicklist-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        *data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (sz)</span><br><span class="line">        *sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sval)</span><br><span class="line">        *sval = <span class="number">-123456789</span>;</span><br><span class="line"></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD &amp;&amp; quicklist-&gt;head) &#123;</span><br><span class="line">        node = quicklist-&gt;head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL &amp;&amp; quicklist-&gt;tail) &#123;</span><br><span class="line">        node = quicklist-&gt;tail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = ziplistIndex(node-&gt;zl, pos);</span><br><span class="line">    <span class="keyword">if</span> (ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vlong)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data)</span><br><span class="line">                *data = saver(vstr, vlen);</span><br><span class="line">            <span class="keyword">if</span> (sz)</span><br><span class="line">                *sz = vlen;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data)</span><br><span class="line">                *data = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (sval)</span><br><span class="line">                *sval = vlong;</span><br><span class="line">        &#125;</span><br><span class="line">        quicklistDelIndex(quicklist, node, &amp;p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> </span>&#123;</span><br><span class="line">    quicklistNode *prev = entry-&gt;node-&gt;prev;</span><br><span class="line">    quicklistNode *next = entry-&gt;node-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,</span><br><span class="line">                                         entry-&gt;node, &amp;entry-&gt;zi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* after delete, the zi is now invalid for any future usage. */</span></span><br><span class="line">    iter-&gt;zi = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If current node is deleted, we must update iterator node and offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (deleted_node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</span><br><span class="line">            iter-&gt;current = next;</span><br><span class="line">            iter-&gt;offset = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</span><br><span class="line">            iter-&gt;current = prev;</span><br><span class="line">            iter-&gt;offset = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* else if (!deleted_node), no changes needed.</span></span><br><span class="line"><span class="comment">     * we already reset iter-&gt;zi above, and the existing iter-&gt;offset</span></span><br><span class="line"><span class="comment">     * doesn&#x27;t move again because:</span></span><br><span class="line"><span class="comment">     *   - [1, 2, 3] =&gt; delete offset 1 =&gt; [1, 3]: next element still offset 1</span></span><br><span class="line"><span class="comment">     *   - [1, 2, 3] =&gt; delete offset 0 =&gt; [2, 3]: next element still offset 0</span></span><br><span class="line"><span class="comment">     *  if we deleted the last element at offet N and now</span></span><br><span class="line"><span class="comment">     *  length of this ziplist is N-1, the next call into</span></span><br><span class="line"><span class="comment">     *  quicklistNext() will jump to the next node. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">REDIS_STATIC <span class="keyword">int</span> <span class="title">quicklistDelIndex</span><span class="params">(quicklist *quicklist, quicklistNode *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gone = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    node-&gt;zl = ziplistDelete(node-&gt;zl, p);</span><br><span class="line">    node-&gt;count--;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">        gone = <span class="number">1</span>;</span><br><span class="line">        __quicklistDelNode(quicklist, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count--;</span><br><span class="line">    <span class="comment">/* If we deleted the node, the original node is no longer valid */</span></span><br><span class="line">    <span class="keyword">return</span> gone ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">void</span> __quicklistDelNode(quicklist *quicklist,</span><br><span class="line">                                     quicklistNode *node) &#123;</span><br><span class="line">    <span class="comment">/* Update the bookmark if any */</span></span><br><span class="line">    quicklistBookmark *bm = _quicklistBookmarkFindByNode(quicklist, node);</span><br><span class="line">    <span class="keyword">if</span> (bm) &#123;</span><br><span class="line">        bm-&gt;node = node-&gt;next;</span><br><span class="line">        <span class="comment">/* if the bookmark was to the last node, delete it. */</span></span><br><span class="line">        <span class="keyword">if</span> (!bm-&gt;node)</span><br><span class="line">            _quicklistBookmarkDelete(quicklist, bm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == quicklist-&gt;tail) &#123;</span><br><span class="line">        quicklist-&gt;tail = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == quicklist-&gt;head) &#123;</span><br><span class="line">        quicklist-&gt;head = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we deleted a node within our compress depth, we</span></span><br><span class="line"><span class="comment">     * now have compressed nodes needing to be decompressed. */</span></span><br><span class="line">    __quicklistCompress(quicklist, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    quicklist-&gt;count -= node-&gt;count;</span><br><span class="line"></span><br><span class="line">    zfree(node-&gt;zl);</span><br><span class="line">    zfree(node);</span><br><span class="line">    quicklist-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistIndex</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                   quicklistEntry *entry)</span> </span>&#123;</span><br><span class="line">    quicklistNode *n;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> accum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">int</span> forward = idx &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">/* &lt; 0 -&gt; reverse, 0+ -&gt; forward */</span> <span class="comment">// 正向遍历或者是反向遍历</span></span><br><span class="line"></span><br><span class="line">    initEntry(entry);</span><br><span class="line">    entry-&gt;quicklist = quicklist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向遍历，从头节点开始查找，反向遍历，从尾节点开始查找</span></span><br><span class="line">    <span class="keyword">if</span> (!forward) &#123;</span><br><span class="line">        index = (-idx) - <span class="number">1</span>;</span><br><span class="line">        n = quicklist-&gt;tail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        index = idx;</span><br><span class="line">        n = quicklist-&gt;head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= quicklist-&gt;count)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找index在哪个quicklistNode中</span></span><br><span class="line">    <span class="keyword">while</span> (likely(n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((accum + n-&gt;count) &gt; index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            D(<span class="string">&quot;Skipping over (%p) %u at accum %lld&quot;</span>, (<span class="keyword">void</span> *)n, n-&gt;count,</span><br><span class="line">              accum);</span><br><span class="line">            accum += n-&gt;count;</span><br><span class="line">            n = forward ? n-&gt;next : n-&gt;prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    D(<span class="string">&quot;Found node: %p at accum %llu, idx %llu, sub+ %llu, sub- %llu&quot;</span>, (<span class="keyword">void</span> *)n,</span><br><span class="line">      accum, index, index - accum, (-index) - <span class="number">1</span> + accum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算index在命中的节点中的偏移量</span></span><br><span class="line">    entry-&gt;node = n;</span><br><span class="line">    <span class="keyword">if</span> (forward) &#123;</span><br><span class="line">        <span class="comment">/* forward = normal head-to-tail offset. */</span></span><br><span class="line">        entry-&gt;offset = index - accum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* reverse = need negative offset for tail-to-head, so undo</span></span><br><span class="line"><span class="comment">         * the result of the original if (index &lt; 0) above. */</span></span><br><span class="line">        entry-&gt;offset = (-index) - <span class="number">1</span> + accum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quicklistDecompressNodeForUse(entry-&gt;node); <span class="comment">// listzip如果压缩，则进行解压</span></span><br><span class="line">    entry-&gt;zi = ziplistIndex(entry-&gt;node-&gt;zl, entry-&gt;offset); <span class="comment">// 定位ziplist中指定index的地址</span></span><br><span class="line">    ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval); <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="comment">/* The caller will use our result, so we don&#x27;t re-compress here.</span></span><br><span class="line"><span class="comment">     * The caller can recompress or delete the node as needed. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-动态字符串sds</title>
    <url>/Redis/1-data-structure/redis-parse-sds/</url>
    <content><![CDATA[<p>源码位置：sds.c/sds.h  </p>
<p>因为C语言没有实现动态字符串，所以redis实现了sds（simple dynamic string）简单动态字符串。既然是动态的，意味着它是能够支持修改的。​虽然是简单的动态字符串，但是redis为了省内存，快速获得字符串长度等需求，redis作者在结构上可是煞费苦心了。​<br><a id="more"></a><br>sds为了省内存，对不同长度的字符串，采用了不同的内存大小的结构体达到省内存的目的。为了减少内存的频繁分配，sds采用预分配冗余空间的方式来达到目的。<br>SDS结构一共有5种header定义，结构体主要包含以下几个部分：<br>len：字符串的实际长度<br>alloc：字符串的最大容量<br>flags：表示结构体的类型<br>buf：字符串<br><img src="https://i.loli.net/2020/10/29/n3tC1EMfqwexdlX.png" alt="sds.png"></p>
<h2 id="SDS结构体"><a href="#SDS结构体" class="headerlink" title="SDS结构体"></a>SDS结构体</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7 <span class="comment">// 类型掩码(通过(flags &amp; SDS_TYPE_MASK)可判断sdshdrXX)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); <span class="comment">// 获取header头指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) <span class="comment">// 获取header头指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS) <span class="comment">// 获取sdshdr5的长度</span></span></span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>; <span class="comment">// 生成新的sds字符串（返回sdshdrXX中的buf头指针）</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>; <span class="comment">// 生成新的sds字符串（调用sdsnewlen()）</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个空的sds字符串（调用sdsnewlen(&quot;&quot;, 0)）</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>; <span class="comment">// 复制（深拷贝）s（调用sdsnewlen(&quot;&quot;, 0)）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>; <span class="comment">// 释放sds字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 将字符串s增加到指定长度len（s的实际长度为len）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 字符串s增加len的长度（s的实际长度为len（s） + len）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>; <span class="comment">// 字符串拼接（调用sdscatlen()）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span>; <span class="comment">// 同上（调用sdscatlen()）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 字符串拷贝</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>; <span class="comment">// 字符串拷贝（调用sdscpylen()）</span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>; <span class="comment">// 字符串格式化，类似于sprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="comment">// 字符串格式化（调用sdscatvprintf()）</span></span></span><br><span class="line"><span class="function">    __<span class="title">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>; <span class="comment">// 字符串格式化（调用sdscatvprintf()）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>; <span class="comment">// 字符串格式化拼接</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>; <span class="comment">// 字符串s剔除指定的cset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">ssize_t</span> start, <span class="keyword">ssize_t</span> end)</span></span>; <span class="comment">// 选取指定长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>; <span class="comment">// 更新s的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>; <span class="comment">// 清空s的内容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span></span>; <span class="comment">// 字符串拷贝</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">ssize_t</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span>; <span class="comment">// 字符串分割，将字符串s根据sep分割符来进行分割，返回字符串数组，count为数组个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>; <span class="comment">// 释放字符串数组tokens</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>; <span class="comment">// 字符串转小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>; <span class="comment">// 字符串转大写</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>; <span class="comment">// long long 转为sds格式</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 将s里不可打印的字符(&#x27;\n&#x27;、&#x27;\t&#x27;等)转义为可用来打印的字符(&#x27;\\n&#x27;、&#x27;\\t&#x27;等)</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span></span>; <span class="comment">// 替换字符串，将s中为from的字符串替换为to</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span></span>; <span class="comment">// 字符串数组连接</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">size_t</span> seplen)</span></span>; <span class="comment">// sds格式的字符串连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level functions exposed to the user API */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span></span>; <span class="comment">// 字符串s增加扩大addlen个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">ssize_t</span> incr)</span></span>; <span class="comment">// 调整sds中len的大小</span></span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span></span>; <span class="comment">// 删除掉sds中的末端空间(local-len)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdsAllocSize</span><span class="params">(sds s)</span></span>; <span class="comment">// 返回整个结构的内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sdsAllocPtr</span><span class="params">(sds s)</span></span>; <span class="comment">// 返回结构体的头指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Export the allocator used by SDS to the program using SDS.</span></span><br><span class="line"><span class="comment"> * Sometimes the program SDS is linked to, may use a different set of</span></span><br><span class="line"><span class="comment"> * allocators, but may want to allocate or free things that SDS will</span></span><br><span class="line"><span class="comment"> * respectively free or allocate. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 分配内存size大小的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 重新分配内存大小为size的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sds_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-基数树rax</title>
    <url>/Redis/1-data-structure/redis-parse-rax/</url>
    <content><![CDATA[<p>源码位置：rax.c/rax.h</p>
<p>Redis 5.0版本引入的一个新的数据结构。目前主要用在stream这个数据结构上。Rax是一个有序字典树（基数树），按照key的字典序排列，支持快速定位、查找和删除操作。<br><a id="more"></a><br><strong>一、Rax数据结构：</strong><br><img src="https://i.loli.net/2020/10/29/WbrpgM9KYSknzqC.png" alt="rax_node.png"><br>字段说明：</p>
<ol>
<li>iskey：占用1个bit。表示该节点是否包含key。<ul>
<li>0：没有key</li>
<li>1：表示从头结点到该节点的父节点的路径完整的存储了key，查找的时候按子节点iskey=1判断key是否存在</li>
</ul>
</li>
<li>isnull：占用1个bit。表示该节点是否存储value值。</li>
<li>iscompr：占用1个bit。表示该节点是否为压缩节点，决定了data的存储结构（如果当前节点有多个子节点，为非压缩结构，如果只有一个子节点，则为压缩结构）。</li>
<li>size：占用29个bit。<ul>
<li>非压缩：子节点的数量</li>
<li>压缩：该节点字符个数</li>
</ul>
</li>
<li><p>data：柔性数组。包含路由键，子节点指针，value指针。为了提高cpu性能，data内存空间对齐(sizeof(void*))，所以会根据计算结果来进行相应的字节填充。</p>
<ul>
<li><p>非压缩节点的data伪代码：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">     <span class="keyword">char</span>[] childKey; <span class="comment">// 路由键字符列表</span></span><br><span class="line">     raxNode*[] childNodes; <span class="comment">// 多个子节点指针</span></span><br><span class="line">     <span class="keyword">void</span>* value; <span class="comment">// 取决于 header 的 isNull 字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩节点的data伪代码：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span>[] childKey; <span class="comment">// 路由键字符列表</span></span><br><span class="line">        raxNode* childNodes; <span class="comment">// 单个子节点指针</span></span><br><span class="line">    &#125; child; <span class="comment">// 取决于 header 的 size 字段是否为零（如果是叶节点，则不存在child）</span></span><br><span class="line">     <span class="keyword">void</span>* value; <span class="comment">// 取决于 header 的 isNull 字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  非压缩与压缩节点图示如下：<br> <img src="https://i.loli.net/2020/10/29/r8SCUzsHvRWmdMY.png" alt="rax_compr.png"></p>
</li>
</ul>
</li>
</ol>
<p><strong>二、Rax创建：</strong><br><img src="https://i.loli.net/2020/10/29/buEDwOajJA8x72S.png" alt="rax_new.png"></p>
<p><strong>三、Rax插入：</strong><br>ps：以下内容中的padding皆是为了内存对齐填充的空间。  </p>
<p><strong>1. 在空的基数树中插入数据：<dog, "狗是人类的朋友"></dog,></strong><br>解析：<br>首先从头结点开始查找，因为这是一个空的基数树，所以直接将”dog”插入到节点中，设置该节点为压缩节点（iscompr=1）,padding部分是为了内存对齐而填充的，创建该节点的叶子结点，叶子结点中，iskey=1是表示从头结点到该节点的父节点是一个完整的key，iskey=1 &amp;&amp; isnull=0表示该叶子结点存储了key的value。<br>结果如下图：<br><img src="https://i.loli.net/2020/10/29/EIhFsJoVjm95ucA.png" alt="rax_insert_1.png"></p>
<p><strong>2. 接着插入数据：<cat, "猫咪很可爱"></cat,></strong><br>解析：<br>接着上面的基数树，从头结点开始查找，当前头结点存储的第一个字符是’d’，与要插入的key的第一个字符’c’不相等，所以需要将该节点拆分成两个节点（拆分的过程可看我下面的源码注释），分别存储[d]和[og]，此时基数树有3个节点。随后将字符’c’插入到首节点中，接着创建’c’子节点，将[at]插入到子节点中，并创建子节点的叶节点插入value的指针，此时基数树存在5个节点，元素个数为2。<br>结果如下图：<br><img src="https://i.loli.net/2020/10/29/xqupKsLR5PilDSd.png" alt="rax_insert_2.png"></p>
<p><strong>3. 接着插入数据：<doggy, "小狗很可爱"></doggy,></strong><br>解析：<br>接着上面的基数树，从头结点开始查找key[‘doggy’]，发现头结点只有一个’d’，接着在’d’的子节点node_1中比较[‘oggy’]，找到[‘og’]，’og’的子节点为叶子结点，这时只要直接把[‘gy’]插入到叶子结点中，并创建一个’gy’的叶子结点插入value指针，即可完成插入。此时该基数树的节点数为6，元素个数为3。<br>结果如下图：<br><img src="https://i.loli.net/2020/10/29/K9yoSLO8pPHlw1U.png" alt="rax_insert_3.png"></p>
<p><strong>4. 接着插入数据：<carry, "携带"></carry,></strong><br>解析：<br>步骤如上一步，当匹配到节点[‘at’]时，需要拆分该节点为[‘a’]节点和[‘rt’]节点， [‘a’]为[‘rt’]的父节点，[‘rt’]节点为非压缩节点，’r’指针指向新的节点[‘ry’]，并创建[‘ry’]的叶子结点，’t’指针指向原先的叶子结点，基数树右边部分保持不变，完成插入操作。此时该基数树的节点数为9，元素个数为4。<br>结果如下图：<br><img src="https://i.loli.net/2020/10/29/QJBCOAD3Wm1ljah.png" alt="rax_insert_4.png"></p>
<p><strong>四、Rax查找：</strong><br>查找实现函数为：raxLowWalk()<br>从基数树的头节点往下遍历。比较节点的data值，并通过子节点指针往下继续遍历，直到找到完整的key。</p>
<p><strong>五、Rax删除：</strong><br>分为几个步骤：  </p>
<ol>
<li>通过raxLowWalk()找到要删除的key的节点</li>
<li>接着判断删除后，附近节点是否可以进行压缩、收敛树的高度</li>
<li><p>如果可以压缩，则进行压缩合并，合并的条件如下：</p>
<ul>
<li>iskey=1的节点</li>
<li>子节点只有一个字符</li>
<li>父节点只有一个子节点</li>
</ul>
</li>
</ol>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_NODE_MAX_SIZE ((1&lt;&lt;29)-1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raxNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> iskey:<span class="number">1</span>;       <span class="comment">// 该节点是否包含key，1个bit</span></span><br><span class="line">    <span class="keyword">uint32_t</span> isnull:<span class="number">1</span>;      <span class="comment">// 该该节点是否存储value值，1个bit</span></span><br><span class="line">    <span class="keyword">uint32_t</span> iscompr:<span class="number">1</span>;     <span class="comment">// 该节点是否压缩，1个bit</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size:<span class="number">29</span>;       <span class="comment">// 子节点的数量或者是压缩字符串的长度，29个bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[];   <span class="comment">// 柔性数组，保存节点对应的数据，0bit</span></span><br><span class="line">&#125; raxNode; <span class="comment">// raxNode size：4byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rax</span> &#123;</span></span><br><span class="line">    raxNode *head;      <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">uint64_t</span> numele;    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> numnodes;  <span class="comment">// 节点数</span></span><br><span class="line">&#125; rax;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_STACK_STATIC_ITEMS 32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raxStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> **<span class="built_in">stack</span>; <span class="comment">// 存储每一层节点的地址</span></span><br><span class="line">    <span class="keyword">size_t</span> items, maxitems;</span><br><span class="line">    <span class="keyword">void</span> *static_items[RAX_STACK_STATIC_ITEMS];</span><br><span class="line">    <span class="keyword">int</span> oom;</span><br><span class="line">&#125; raxStack; <span class="comment">// 用于迭代，查找，删除的时候记录节点信息的栈结构，FILO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_ITER_STATIC_LEN 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_ITER_JUST_SEEKED (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_ITER_EOF (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_ITER_SAFE (1&lt;&lt;2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raxIterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    rax *rt;                <span class="comment">// 需要迭代的基数树</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *key;     <span class="comment">/* The current string. */</span></span><br><span class="line">    <span class="keyword">void</span> *data;             <span class="comment">/* Data associated to this key. */</span></span><br><span class="line">    <span class="keyword">size_t</span> key_len;         <span class="comment">/* Current key length. */</span></span><br><span class="line">    <span class="keyword">size_t</span> key_max;         <span class="comment">/* Max key len the current key buffer can hold. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key_static_string[RAX_ITER_STATIC_LEN];</span><br><span class="line">    raxNode *node;          <span class="comment">/* Current node. Only for unsafe iteration. */</span></span><br><span class="line">    raxStack <span class="built_in">stack</span>;         <span class="comment">/* Stack used for unsafe iteration. */</span></span><br><span class="line">    raxNodeCallback node_cb; <span class="comment">/* Optional node callback. Normally set to NULL. */</span></span><br><span class="line">&#125; raxIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为了内存对齐填充的字节，为什么需要填充，本质上来说是为了提高cpu性能。填充之后的数据首地址按照</span></span><br><span class="line"><span class="comment"> * sizeof(void*)字节对齐，保证每个节点都是内存对齐的：</span></span><br><span class="line"><span class="comment"> * 在64位系统中(sizeof(void*)=8)，节点大小如下：</span></span><br><span class="line"><span class="comment"> * 1. [header-4][padding-4] = 8byte</span></span><br><span class="line"><span class="comment"> * 2. [header-4][data-2][padding-2] = 8byte</span></span><br><span class="line"><span class="comment"> * 3. [header-4][data-11][padding-1] = 16byte</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1))</span></span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">rax *<span class="title">raxNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxInsert</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> *data, <span class="keyword">void</span> **old)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxTryInsert</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> *data, <span class="keyword">void</span> **old)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxRemove</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> **old)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">raxFind</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxFree</span><span class="params">(rax *rax)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxFreeWithCallback</span><span class="params">(rax *rax, <span class="keyword">void</span> (*free_callback)(<span class="keyword">void</span>*))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxStart</span><span class="params">(raxIterator *it, rax *rt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxSeek</span><span class="params">(raxIterator *it, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxNext</span><span class="params">(raxIterator *it)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxPrev</span><span class="params">(raxIterator *it)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxRandomWalk</span><span class="params">(raxIterator *it, <span class="keyword">size_t</span> steps)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxCompare</span><span class="params">(raxIterator *iter, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">size_t</span> key_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxStop</span><span class="params">(raxIterator *it)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxEOF</span><span class="params">(raxIterator *it)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxShow</span><span class="params">(rax *rax)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">raxSize</span><span class="params">(rax *rax)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">raxTouch</span><span class="params">(raxNode *n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxSetDebugMsg</span><span class="params">(<span class="keyword">int</span> onoff)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal API. May be used by the node callback in order to access rax nodes</span></span><br><span class="line"><span class="comment"> * in a low level way, so this function is exported as well. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxSetData</span><span class="params">(raxNode *n, <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<p><strong>创建：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建基数树</span></span><br><span class="line"><span class="function">rax *<span class="title">raxNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    rax *rax = rax_malloc(<span class="keyword">sizeof</span>(*rax)); <span class="comment">// sizeof(*rax) = 4</span></span><br><span class="line">    <span class="keyword">if</span> (rax == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    rax-&gt;numele = <span class="number">0</span>;</span><br><span class="line">    rax-&gt;numnodes = <span class="number">1</span>;</span><br><span class="line">    rax-&gt;head = raxNewNode(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// 创建首节点</span></span><br><span class="line">    <span class="keyword">if</span> (rax-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rax_free(rax);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个节点</span></span><br><span class="line"><span class="function">raxNode *<span class="title">raxNewNode</span><span class="params">(<span class="keyword">size_t</span> children, <span class="keyword">int</span> datafield)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nodesize = <span class="keyword">sizeof</span>(raxNode)+children+raxPadding(children)+</span><br><span class="line">                      <span class="keyword">sizeof</span>(raxNode*)*children;</span><br><span class="line">    <span class="keyword">if</span> (datafield) nodesize += <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">    raxNode *node = rax_malloc(nodesize);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">    node-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">    node-&gt;iscompr = <span class="number">0</span>;</span><br><span class="line">    node-&gt;size = children;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">raxLowWalk</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, raxNode **stopnode, raxNode ***plink, <span class="keyword">int</span> *splitpos, raxStack *ts)</span> </span>&#123;</span><br><span class="line">    raxNode *h = rax-&gt;head; <span class="comment">// 从头节点开始往下遍历</span></span><br><span class="line">    raxNode **parentlink = &amp;rax-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>; <span class="comment">/* Position in the string. */</span></span><br><span class="line">    <span class="keyword">size_t</span> j = <span class="number">0</span>; <span class="comment">/* Position in the node children (or bytes if compressed).*/</span></span><br><span class="line">    <span class="keyword">while</span>(h-&gt;size &amp;&amp; i &lt; len) &#123;</span><br><span class="line">        debugnode(<span class="string">&quot;Lookup current node&quot;</span>,h);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *v = h-&gt;data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iscompr) &#123;</span><br><span class="line">            <span class="comment">/* 如果是压缩节点，表明该节点存储的全部字符应该和s中的部分或者全部字符相等</span></span><br><span class="line"><span class="comment">             * 例如：</span></span><br><span class="line"><span class="comment">             * 1. node:[header|&#x27;abcd&#x27;|d-ptr]  s:[&#x27;abc&#x27;]  那么j=3</span></span><br><span class="line"><span class="comment">             * 2. node:[header|&#x27;ab&#x27;|b-ptr] s:[&#x27;abc&#x27;] 继续往下遍历节点(b-ptr)找到字符&#x27;C&#x27;</span></span><br><span class="line"><span class="comment">             *    然后在子节点中确定&#x27;c&#x27;的位置j */</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; h-&gt;size &amp;&amp; i &lt; len; j++, i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j] != s[i]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != h-&gt;size) <span class="keyword">break</span>; <span class="comment">// 表示已经找到节点，退出循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果是非压缩节点，找到s[i]字符的位置j</span></span><br><span class="line"><span class="comment">             * 例如：</span></span><br><span class="line"><span class="comment">             * node:[header|&#x27;abc&#x27;|&#x27;a-ptr&#x27;|&#x27;b-ptr&#x27;|&#x27;c-ptr&#x27;]， s[i]:[&#x27;b&#x27;]，那么j=1</span></span><br><span class="line"><span class="comment">             * 然后可以根据j来确定子节点的地址&#x27;b-ptr&#x27;，便可继续往下遍历 */</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; h-&gt;size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j] == s[i]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == h-&gt;size) <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ts) raxStackPush(ts,h); <span class="comment">// 将当前节点压入栈中</span></span><br><span class="line">        raxNode **children = raxNodeFirstChildPtr(h); <span class="comment">// 获取当前节点的第一个子节点指针的地址</span></span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iscompr) j = <span class="number">0</span>; <span class="comment">/* 压缩节点不需要设置偏移量j */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;h,children+j,<span class="keyword">sizeof</span>(h)); <span class="comment">// 根据偏移量j计算得到子节点的指针，并拷贝给h，接着继续while循环往下遍历</span></span><br><span class="line">        parentlink = children+j;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    debugnode(<span class="string">&quot;Lookup stop node is&quot;</span>,h);</span><br><span class="line">    <span class="keyword">if</span> (stopnode) *stopnode = h;</span><br><span class="line">    <span class="keyword">if</span> (plink) *plink = parentlink;</span><br><span class="line">    <span class="keyword">if</span> (splitpos &amp;&amp; h-&gt;iscompr) *splitpos = j;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">raxFind</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    raxNode *h;</span><br><span class="line"></span><br><span class="line">    debugf(<span class="string">&quot;### Lookup: %.*s\n&quot;</span>, (<span class="keyword">int</span>)len, s);</span><br><span class="line">    <span class="keyword">int</span> splitpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> i = raxLowWalk(rax,s,len,&amp;h,<span class="literal">NULL</span>,&amp;splitpos,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (i != len || (h-&gt;iscompr &amp;&amp; splitpos != <span class="number">0</span>) || !h-&gt;iskey)</span><br><span class="line">        <span class="keyword">return</span> raxNotFound;</span><br><span class="line">    <span class="keyword">return</span> raxGetData(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxGenericInsert</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> *data, <span class="keyword">void</span> **old, <span class="keyword">int</span> overwrite)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    raxNode *h, **parentlink;</span><br><span class="line"></span><br><span class="line">    debugf(<span class="string">&quot;### Insert %.*s with value %p\n&quot;</span>, (<span class="keyword">int</span>)len, s, data);</span><br><span class="line">    i = raxLowWalk(rax,s,len,&amp;h,&amp;parentlink,&amp;j,<span class="literal">NULL</span>); <span class="comment">// 确定插入的节点位置，如果是压缩节点，确定分割位置j</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果s已经存在于rax中</span></span><br><span class="line">    <span class="keyword">if</span> (i == len &amp;&amp; (!h-&gt;iscompr || j == <span class="number">0</span>)) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;### Insert: node representing key exists\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!h-&gt;iskey || (h-&gt;isnull &amp;&amp; overwrite)) &#123;</span><br><span class="line">            h = raxReallocForData(h,data); <span class="comment">// 为值指针分配空间</span></span><br><span class="line">            <span class="keyword">if</span> (h) <span class="built_in">memcpy</span>(parentlink,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            errno = ENOMEM;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the existing key if there is already one. */</span></span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iskey) &#123;</span><br><span class="line">            <span class="comment">// 如果该key以存在，则根据需要是否重写value</span></span><br><span class="line">            <span class="keyword">if</span> (old) *old = raxGetData(h);</span><br><span class="line">            <span class="keyword">if</span> (overwrite) raxSetData(h,data);</span><br><span class="line">            errno = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Element already exists. */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Otherwise set the node as a key. Note that raxSetData()</span></span><br><span class="line"><span class="comment">         * will set h-&gt;iskey. */</span></span><br><span class="line">        <span class="comment">// 插入value</span></span><br><span class="line">        raxSetData(h,data);</span><br><span class="line">        rax-&gt;numele++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Element inserted. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------- ALGORITHM 1 --------------------------- */</span></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;iscompr &amp;&amp; i != len) &#123;</span><br><span class="line">        <span class="comment">// 如果遍历后停在压缩节点上</span></span><br><span class="line">        debugf(<span class="string">&quot;ALGO 1: Stopped at compressed node %.*s (%p)\n&quot;</span>,</span><br><span class="line">            h-&gt;size, h-&gt;data, (<span class="keyword">void</span>*)h);</span><br><span class="line">        debugf(<span class="string">&quot;Still to insert: %.*s\n&quot;</span>, (<span class="keyword">int</span>)(len-i), s+i);</span><br><span class="line">        debugf(<span class="string">&quot;Splitting at %d: &#x27;%c&#x27;\n&quot;</span>, j, ((<span class="keyword">char</span>*)h-&gt;data)[j]);</span><br><span class="line">        debugf(<span class="string">&quot;Other (key) letter is &#x27;%c&#x27;\n&quot;</span>, s[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1: Save next pointer. */</span></span><br><span class="line">        raxNode **childfield = raxNodeLastChildPtr(h);</span><br><span class="line">        raxNode *next;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;next,childfield,<span class="keyword">sizeof</span>(next));</span><br><span class="line">        debugf(<span class="string">&quot;Next is %p\n&quot;</span>, (<span class="keyword">void</span>*)next);</span><br><span class="line">        debugf(<span class="string">&quot;iskey %d\n&quot;</span>, h-&gt;iskey);</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iskey) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;key value is %p\n&quot;</span>, raxGetData(h));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set the length of the additional nodes we will need. */</span></span><br><span class="line">        <span class="keyword">size_t</span> trimmedlen = j;</span><br><span class="line">        <span class="keyword">size_t</span> postfixlen = h-&gt;size - j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> split_node_is_key = !trimmedlen &amp;&amp; h-&gt;iskey &amp;&amp; !h-&gt;isnull;</span><br><span class="line">        <span class="keyword">size_t</span> nodesize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2: Create the split node. Also allocate the other nodes we&#x27;ll need</span></span><br><span class="line"><span class="comment">         *    ASAP, so that it will be simpler to handle OOM. */</span></span><br><span class="line">        raxNode *splitnode = raxNewNode(<span class="number">1</span>, split_node_is_key);</span><br><span class="line">        raxNode *trimmed = <span class="literal">NULL</span>;</span><br><span class="line">        raxNode *postfix = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (trimmedlen) &#123;</span><br><span class="line">            nodesize = <span class="keyword">sizeof</span>(raxNode)+trimmedlen+raxPadding(trimmedlen)+</span><br><span class="line">                       <span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey &amp;&amp; !h-&gt;isnull) nodesize += <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">            trimmed = rax_malloc(nodesize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postfixlen) &#123;</span><br><span class="line">            nodesize = <span class="keyword">sizeof</span>(raxNode)+postfixlen+raxPadding(postfixlen)+</span><br><span class="line">                       <span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">            postfix = rax_malloc(nodesize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* OOM? Abort now that the tree is untouched. */</span></span><br><span class="line">        <span class="keyword">if</span> (splitnode == <span class="literal">NULL</span> ||</span><br><span class="line">            (trimmedlen &amp;&amp; trimmed == <span class="literal">NULL</span>) ||</span><br><span class="line">            (postfixlen &amp;&amp; postfix == <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            rax_free(splitnode);</span><br><span class="line">            rax_free(trimmed);</span><br><span class="line">            rax_free(postfix);</span><br><span class="line">            errno = ENOMEM;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        splitnode-&gt;data[<span class="number">0</span>] = h-&gt;data[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 3a: Replace the old node with the split node. */</span></span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey) &#123;</span><br><span class="line">                <span class="keyword">void</span> *ndata = raxGetData(h);</span><br><span class="line">                raxSetData(splitnode,ndata);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(parentlink,&amp;splitnode,<span class="keyword">sizeof</span>(splitnode));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 3b: Trim the compressed node. */</span></span><br><span class="line">            trimmed-&gt;size = j;</span><br><span class="line">            <span class="built_in">memcpy</span>(trimmed-&gt;data,h-&gt;data,j);</span><br><span class="line">            trimmed-&gt;iscompr = j &gt; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            trimmed-&gt;iskey = h-&gt;iskey;</span><br><span class="line">            trimmed-&gt;isnull = h-&gt;isnull;</span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey &amp;&amp; !h-&gt;isnull) &#123;</span><br><span class="line">                <span class="keyword">void</span> *ndata = raxGetData(h);</span><br><span class="line">                raxSetData(trimmed,ndata);</span><br><span class="line">            &#125;</span><br><span class="line">            raxNode **cp = raxNodeLastChildPtr(trimmed);</span><br><span class="line">            <span class="built_in">memcpy</span>(cp,&amp;splitnode,<span class="keyword">sizeof</span>(splitnode));</span><br><span class="line">            <span class="built_in">memcpy</span>(parentlink,&amp;trimmed,<span class="keyword">sizeof</span>(trimmed));</span><br><span class="line">            parentlink = cp; <span class="comment">/* Set parentlink to splitnode parent. */</span></span><br><span class="line">            rax-&gt;numnodes++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 4: Create the postfix node: what remains of the original</span></span><br><span class="line"><span class="comment">         * compressed node after the split. */</span></span><br><span class="line">        <span class="keyword">if</span> (postfixlen) &#123;</span><br><span class="line">            <span class="comment">/* 4a: create a postfix node. */</span></span><br><span class="line">            postfix-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">            postfix-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">            postfix-&gt;size = postfixlen;</span><br><span class="line">            postfix-&gt;iscompr = postfixlen &gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(postfix-&gt;data,h-&gt;data+j+<span class="number">1</span>,postfixlen);</span><br><span class="line">            raxNode **cp = raxNodeLastChildPtr(postfix);</span><br><span class="line">            <span class="built_in">memcpy</span>(cp,&amp;next,<span class="keyword">sizeof</span>(next));</span><br><span class="line">            rax-&gt;numnodes++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 4b: just use next as postfix node. */</span></span><br><span class="line">            postfix = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 5: Set splitnode first child as the postfix node. */</span></span><br><span class="line">        raxNode **splitchild = raxNodeLastChildPtr(splitnode);</span><br><span class="line">        <span class="built_in">memcpy</span>(splitchild,&amp;postfix,<span class="keyword">sizeof</span>(postfix));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 6. Continue insertion: this will cause the splitnode to</span></span><br><span class="line"><span class="comment">         * get a new child (the non common character at the currently</span></span><br><span class="line"><span class="comment">         * inserted key). */</span></span><br><span class="line">        rax_free(h);</span><br><span class="line">        h = splitnode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h-&gt;iscompr &amp;&amp; i == len) &#123;</span><br><span class="line">    <span class="comment">/* ------------------------- ALGORITHM 2 --------------------------- */</span></span><br><span class="line">        <span class="comment">// 如果在压缩节点h中找到了所有的字符，则创建一个子节点插入</span></span><br><span class="line">        debugf(<span class="string">&quot;ALGO 2: Stopped at compressed node %.*s (%p) j = %d\n&quot;</span>,</span><br><span class="line">            h-&gt;size, h-&gt;data, (<span class="keyword">void</span>*)h, j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate postfix &amp; trimmed nodes ASAP to fail for OOM gracefully. */</span></span><br><span class="line">        <span class="keyword">size_t</span> postfixlen = h-&gt;size - j;</span><br><span class="line">        <span class="keyword">size_t</span> nodesize = <span class="keyword">sizeof</span>(raxNode)+postfixlen+raxPadding(postfixlen)+</span><br><span class="line">                          <span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">NULL</span>) nodesize += <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">        raxNode *postfix = rax_malloc(nodesize);</span><br><span class="line"></span><br><span class="line">        nodesize = <span class="keyword">sizeof</span>(raxNode)+j+raxPadding(j)+<span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iskey &amp;&amp; !h-&gt;isnull) nodesize += <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">        raxNode *trimmed = rax_malloc(nodesize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postfix == <span class="literal">NULL</span> || trimmed == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rax_free(postfix);</span><br><span class="line">            rax_free(trimmed);</span><br><span class="line">            errno = ENOMEM;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1: Save next pointer. */</span></span><br><span class="line">        raxNode **childfield = raxNodeLastChildPtr(h);</span><br><span class="line">        raxNode *next;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;next,childfield,<span class="keyword">sizeof</span>(next));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2: Create the postfix node. */</span></span><br><span class="line">        postfix-&gt;size = postfixlen;</span><br><span class="line">        postfix-&gt;iscompr = postfixlen &gt; <span class="number">1</span>;</span><br><span class="line">        postfix-&gt;iskey = <span class="number">1</span>;</span><br><span class="line">        postfix-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(postfix-&gt;data,h-&gt;data+j,postfixlen);</span><br><span class="line">        raxSetData(postfix,data);</span><br><span class="line">        raxNode **cp = raxNodeLastChildPtr(postfix);</span><br><span class="line">        <span class="built_in">memcpy</span>(cp,&amp;next,<span class="keyword">sizeof</span>(next));</span><br><span class="line">        rax-&gt;numnodes++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3: Trim the compressed node. */</span></span><br><span class="line">        trimmed-&gt;size = j;</span><br><span class="line">        trimmed-&gt;iscompr = j &gt; <span class="number">1</span>;</span><br><span class="line">        trimmed-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">        trimmed-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(trimmed-&gt;data,h-&gt;data,j);</span><br><span class="line">        <span class="built_in">memcpy</span>(parentlink,&amp;trimmed,<span class="keyword">sizeof</span>(trimmed));</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iskey) &#123;</span><br><span class="line">            <span class="keyword">void</span> *aux = raxGetData(h);</span><br><span class="line">            raxSetData(trimmed,aux);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Fix the trimmed node child pointer to point to</span></span><br><span class="line"><span class="comment">         * the postfix node. */</span></span><br><span class="line">        cp = raxNodeLastChildPtr(trimmed);</span><br><span class="line">        <span class="built_in">memcpy</span>(cp,&amp;postfix,<span class="keyword">sizeof</span>(postfix));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Finish! We don&#x27;t need to continue with the insertion</span></span><br><span class="line"><span class="comment">         * algorithm for ALGO 2. The key is already inserted. */</span></span><br><span class="line">        rax-&gt;numele++;</span><br><span class="line">        rax_free(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Key inserted. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We walked the radix tree as far as we could, but still there are left</span></span><br><span class="line"><span class="comment">     * chars in our string. We need to insert the missing nodes. */</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">        raxNode *child;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this node is going to have a single child, and there</span></span><br><span class="line"><span class="comment">         * are other characters, so that that would result in a chain</span></span><br><span class="line"><span class="comment">         * of single-childed nodes, turn it into a compressed node. */</span></span><br><span class="line">        <span class="keyword">if</span> (h-&gt;size == <span class="number">0</span> &amp;&amp; len-i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Inserting compressed node\n&quot;</span>);</span><br><span class="line">            <span class="keyword">size_t</span> comprsize = len-i;</span><br><span class="line">            <span class="keyword">if</span> (comprsize &gt; RAX_NODE_MAX_SIZE)</span><br><span class="line">                comprsize = RAX_NODE_MAX_SIZE;</span><br><span class="line">            raxNode *newh = raxCompressNode(h,s+i,comprsize,&amp;child);</span><br><span class="line">            <span class="keyword">if</span> (newh == <span class="literal">NULL</span>) <span class="keyword">goto</span> oom;</span><br><span class="line">            h = newh;</span><br><span class="line">            <span class="built_in">memcpy</span>(parentlink,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line">            parentlink = raxNodeLastChildPtr(h);</span><br><span class="line">            i += comprsize;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Inserting normal node\n&quot;</span>);</span><br><span class="line">            raxNode **new_parentlink;</span><br><span class="line">            raxNode *newh = raxAddChild(h,s[i],&amp;child,&amp;new_parentlink);</span><br><span class="line">            <span class="keyword">if</span> (newh == <span class="literal">NULL</span>) <span class="keyword">goto</span> oom;</span><br><span class="line">            h = newh;</span><br><span class="line">            <span class="built_in">memcpy</span>(parentlink,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line">            parentlink = new_parentlink;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        rax-&gt;numnodes++;</span><br><span class="line">        h = child;</span><br><span class="line">    &#125;</span><br><span class="line">    raxNode *newh = raxReallocForData(h,data);</span><br><span class="line">    <span class="keyword">if</span> (newh == <span class="literal">NULL</span>) <span class="keyword">goto</span> oom;</span><br><span class="line">    h = newh;</span><br><span class="line">    <span class="keyword">if</span> (!h-&gt;iskey) rax-&gt;numele++;</span><br><span class="line">    raxSetData(h,data);</span><br><span class="line">    <span class="built_in">memcpy</span>(parentlink,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Element inserted. */</span></span><br><span class="line"></span><br><span class="line">oom:</span><br><span class="line">    <span class="comment">/* This code path handles out of memory after part of the sub-tree was</span></span><br><span class="line"><span class="comment">     * already modified. Set the node as a key, and then remove it. However we</span></span><br><span class="line"><span class="comment">     * do that only if the node is a terminal node, otherwise if the OOM</span></span><br><span class="line"><span class="comment">     * happened reallocating a node in the middle, we don&#x27;t need to free</span></span><br><span class="line"><span class="comment">     * anything. */</span></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">        h-&gt;isnull = <span class="number">1</span>;</span><br><span class="line">        h-&gt;iskey = <span class="number">1</span>;</span><br><span class="line">        rax-&gt;numele++; <span class="comment">/* Compensate the next remove. */</span></span><br><span class="line">        assert(raxRemove(rax,s,i,<span class="literal">NULL</span>) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxRemove</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> **old)</span> </span>&#123;</span><br><span class="line">    raxNode *h;</span><br><span class="line">    raxStack ts;</span><br><span class="line"></span><br><span class="line">    debugf(<span class="string">&quot;### Delete: %.*s\n&quot;</span>, (<span class="keyword">int</span>)len, s);</span><br><span class="line">    raxStackInit(&amp;ts);</span><br><span class="line">    <span class="keyword">int</span> splitpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> i = raxLowWalk(rax,s,len,&amp;h,<span class="literal">NULL</span>,&amp;splitpos,&amp;ts); <span class="comment">// 将基数树路径上的节点压入ts栈中</span></span><br><span class="line">    <span class="keyword">if</span> (i != len || (h-&gt;iscompr &amp;&amp; splitpos != <span class="number">0</span>) || !h-&gt;iskey) &#123;</span><br><span class="line">        raxStackFree(&amp;ts);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old) *old = raxGetData(h); <span class="comment">// 如果需要旧数据，则获取旧数据</span></span><br><span class="line">    h-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">    rax-&gt;numele--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this node has no children, the deletion needs to reclaim the</span></span><br><span class="line"><span class="comment">     * no longer used nodes. This is an iterative process that needs to</span></span><br><span class="line"><span class="comment">     * walk the three upward, deleting all the nodes with just one child</span></span><br><span class="line"><span class="comment">     * that are not keys, until the head of the rax is reached or the first</span></span><br><span class="line"><span class="comment">     * node with more than one child is found. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> trycompress = <span class="number">0</span>; <span class="comment">/* Will be set to 1 if we should try to optimize the</span></span><br><span class="line"><span class="comment">                            tree resulting from the deletion. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;Key deleted in node without children. Cleanup needed.\n&quot;</span>);</span><br><span class="line">        raxNode *child = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(h != rax-&gt;head) &#123;</span><br><span class="line">            child = h;</span><br><span class="line">            debugf(<span class="string">&quot;Freeing child %p [%.*s] key:%d\n&quot;</span>, (<span class="keyword">void</span>*)child,</span><br><span class="line">                (<span class="keyword">int</span>)child-&gt;size, (<span class="keyword">char</span>*)child-&gt;data, child-&gt;iskey);</span><br><span class="line">            rax_free(child);</span><br><span class="line">            rax-&gt;numnodes--;</span><br><span class="line">            h = raxStackPop(&amp;ts);</span><br><span class="line">             <span class="comment">/* If this node has more then one child, or actually holds</span></span><br><span class="line"><span class="comment">              * a key, stop here. */</span></span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey || (!h-&gt;iscompr &amp;&amp; h-&gt;size != <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (child) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Unlinking child %p from parent %p\n&quot;</span>,</span><br><span class="line">                (<span class="keyword">void</span>*)child, (<span class="keyword">void</span>*)h);</span><br><span class="line">            raxNode *<span class="keyword">new</span> = raxRemoveChild(h,child); <span class="comment">// 删除子节点和父节点相关的信息（data和子节点指针）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> != h) &#123;</span><br><span class="line">                raxNode *parent = raxStackPeek(&amp;ts);</span><br><span class="line">                raxNode **parentlink;</span><br><span class="line">                <span class="keyword">if</span> (parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    parentlink = &amp;rax-&gt;head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parentlink = raxFindParentLink(parent,h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(parentlink,&amp;<span class="keyword">new</span>,<span class="keyword">sizeof</span>(<span class="keyword">new</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If after the removal the node has just a single child</span></span><br><span class="line"><span class="comment">             * and is not a key, we need to try to compress it. */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;size == <span class="number">1</span> &amp;&amp; <span class="keyword">new</span>-&gt;iskey == <span class="number">0</span>) &#123; <span class="comment">// 删除后，如果符合压缩节点结构，则压缩该节点</span></span><br><span class="line">                trycompress = <span class="number">1</span>;</span><br><span class="line">                h = <span class="keyword">new</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h-&gt;size == <span class="number">1</span>) &#123; <span class="comment">//</span></span><br><span class="line">        <span class="comment">/* 如果该节点只有一个子节点，则进行压缩 */</span></span><br><span class="line">        trycompress = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是oom错误，则不进行压缩节点操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (trycompress &amp;&amp; ts.oom) trycompress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trycompress) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;After removing %.*s:\n&quot;</span>, (<span class="keyword">int</span>)len, s);</span><br><span class="line">        debugnode(<span class="string">&quot;Compression may be needed&quot;</span>,h);</span><br><span class="line">        debugf(<span class="string">&quot;Seek start node\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从栈中弹出节点，用来判断最高可到达的能进行压缩的节点上。循环结束时，h指向可以尝试压缩的第一个节点，parent表示h的父节点 */</span></span><br><span class="line">        raxNode *parent;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            parent = raxStackPop(&amp;ts); <span class="comment">// 从栈中弹出节点</span></span><br><span class="line">            <span class="keyword">if</span> (!parent || parent-&gt;iskey ||</span><br><span class="line">                (!parent-&gt;iscompr &amp;&amp; parent-&gt;size != <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            h = parent;</span><br><span class="line">            debugnode(<span class="string">&quot;Going up to&quot;</span>,h);</span><br><span class="line">        &#125;</span><br><span class="line">        raxNode *start = h; <span class="comment">/* Compression starting node. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 扫描可以压缩的节点链路 */</span></span><br><span class="line">        <span class="keyword">size_t</span> comprsize = h-&gt;size;</span><br><span class="line">        <span class="keyword">int</span> nodes = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h-&gt;size != <span class="number">0</span>) &#123;</span><br><span class="line">            raxNode **cp = raxNodeLastChildPtr(h);</span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;h,cp,<span class="keyword">sizeof</span>(h));</span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey || (!h-&gt;iscompr &amp;&amp; h-&gt;size != <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* 判断节点中size是否超出最大限制 */</span></span><br><span class="line">            <span class="keyword">if</span> (comprsize + h-&gt;size &gt; RAX_NODE_MAX_SIZE) <span class="keyword">break</span>;</span><br><span class="line">            nodes++;</span><br><span class="line">            comprsize += h-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nodes &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果可以压缩收敛，则创建新的节点进行合并 */</span></span><br><span class="line">            <span class="keyword">size_t</span> nodesize =</span><br><span class="line">                <span class="keyword">sizeof</span>(raxNode)+comprsize+raxPadding(comprsize)+<span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">            raxNode *<span class="keyword">new</span> = rax_malloc(nodesize);</span><br><span class="line">            <span class="comment">/* An out of memory here just means we cannot optimize this</span></span><br><span class="line"><span class="comment">             * node, but the tree is left in a consistent state. */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                raxStackFree(&amp;ts);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">new</span>-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">new</span>-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">new</span>-&gt;iscompr = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span>-&gt;size = comprsize;</span><br><span class="line">            rax-&gt;numnodes++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 再次扫描，以进行新节点的内容填充并修复新节点指针，同时释放所有不再使用的节点 */</span></span><br><span class="line">            comprsize = <span class="number">0</span>;</span><br><span class="line">            h = start;</span><br><span class="line">            <span class="keyword">while</span>(h-&gt;size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(<span class="keyword">new</span>-&gt;data+comprsize,h-&gt;data,h-&gt;size);</span><br><span class="line">                comprsize += h-&gt;size;</span><br><span class="line">                raxNode **cp = raxNodeLastChildPtr(h);</span><br><span class="line">                raxNode *tofree = h;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;h,cp,<span class="keyword">sizeof</span>(h));</span><br><span class="line">                rax_free(tofree); rax-&gt;numnodes--;</span><br><span class="line">                <span class="keyword">if</span> (h-&gt;iskey || (!h-&gt;iscompr &amp;&amp; h-&gt;size != <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            debugnode(<span class="string">&quot;New node&quot;</span>,<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 此时h指向的是不参与压缩的节点，将新节点的指针指向它 */</span></span><br><span class="line">            raxNode **cp = raxNodeLastChildPtr(<span class="keyword">new</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(cp,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 父节点指针重新链接到新节点上 */</span></span><br><span class="line">            <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">                raxNode **parentlink = raxFindParentLink(parent,start);</span><br><span class="line">                <span class="built_in">memcpy</span>(parentlink,&amp;<span class="keyword">new</span>,<span class="keyword">sizeof</span>(<span class="keyword">new</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rax-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            debugf(<span class="string">&quot;Compressed %d nodes, %d total bytes\n&quot;</span>,</span><br><span class="line">                nodes, (<span class="keyword">int</span>)comprsize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    raxStackFree(&amp;ts);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">raxNode *<span class="title">raxRemoveChild</span><span class="params">(raxNode *parent, raxNode *child)</span> </span>&#123;</span><br><span class="line">    debugnode(<span class="string">&quot;raxRemoveChild before&quot;</span>, parent);</span><br><span class="line">    <span class="comment">/* 如果父节点是一个压缩节点（即只有一个子节点），那么删除子节点就意味着将其变成一个没有子节点的普通节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;iscompr) &#123;</span><br><span class="line">        <span class="keyword">void</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;iskey) data = raxGetData(parent);</span><br><span class="line">        parent-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">        parent-&gt;iscompr = <span class="number">0</span>;</span><br><span class="line">        parent-&gt;size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;iskey) raxSetData(parent,data);</span><br><span class="line">        debugnode(<span class="string">&quot;raxRemoveChild after&quot;</span>, parent);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise we need to scan for the child pointer and memmove()</span></span><br><span class="line"><span class="comment">     * accordingly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. To start we seek the first element in both the children</span></span><br><span class="line"><span class="comment">     *    pointers and edge bytes in the node. */</span></span><br><span class="line">    raxNode **cp = raxNodeFirstChildPtr(parent);</span><br><span class="line">    raxNode **c = cp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *e = parent-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 确定子节点的指针 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        raxNode *aux;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;aux,c,<span class="keyword">sizeof</span>(aux));</span><br><span class="line">        <span class="keyword">if</span> (aux == child) <span class="keyword">break</span>;</span><br><span class="line">        c++;</span><br><span class="line">        e++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 删除节点上的数据，和相应的子节点指针 */</span></span><br><span class="line">    <span class="keyword">int</span> taillen = parent-&gt;size - (e - parent-&gt;data) - <span class="number">1</span>;</span><br><span class="line">    debugf(<span class="string">&quot;raxRemoveChild tail len: %d\n&quot;</span>, taillen);</span><br><span class="line">    memmove(e,e+<span class="number">1</span>,taillen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 因为删除一个节点，需要删除父节点上关于子节点的data信息和指针信息，所以需要计算父节点上的偏移量，即节点上的数据向左偏移的字节数 */</span></span><br><span class="line">    <span class="keyword">size_t</span> shift = ((parent-&gt;size+<span class="number">4</span>) % <span class="keyword">sizeof</span>(<span class="keyword">void</span>*)) == <span class="number">1</span> ? <span class="keyword">sizeof</span>(<span class="keyword">void</span>*) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在删除之前移动子指针 */</span></span><br><span class="line">    <span class="keyword">if</span> (shift)</span><br><span class="line">        memmove(((<span class="keyword">char</span>*)cp)-shift,cp,(parent-&gt;size-taillen<span class="number">-1</span>)*<span class="keyword">sizeof</span>(raxNode**));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将剩余的尾部指针移动到指定位置 */</span></span><br><span class="line">    <span class="keyword">size_t</span> valuelen = (parent-&gt;iskey &amp;&amp; !parent-&gt;isnull) ? <span class="keyword">sizeof</span>(<span class="keyword">void</span>*) : <span class="number">0</span>;</span><br><span class="line">    memmove(((<span class="keyword">char</span>*)c)-shift,c+<span class="number">1</span>,taillen*<span class="keyword">sizeof</span>(raxNode**)+valuelen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 更新节点size. */</span></span><br><span class="line">    parent-&gt;size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重新分配父节点的空间 */</span></span><br><span class="line">    raxNode *newnode = rax_realloc(parent,raxNodeCurrentLength(parent));</span><br><span class="line">    <span class="keyword">if</span> (newnode) &#123;</span><br><span class="line">        debugnode(<span class="string">&quot;raxRemoveChild after&quot;</span>, newnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Note: if rax_realloc() fails we just return the old address, which</span></span><br><span class="line"><span class="comment">     * is valid. */</span></span><br><span class="line">    <span class="keyword">return</span> newnode ? newnode : parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-RDB持久化</title>
    <url>/Redis/3-database/redis-parse-rdb/</url>
    <content><![CDATA[<p>源码位置：rdb.c/rdb.h/rio.c/rio.h</p>
<p><strong>1. 前言</strong><br>Redis是内存数据库，所有的数据都是存在内存中，这样就会存在一个问题，就是当服务进程退出，所有数据都将会丢失，所以Redis提供了两种数据持久化的机制，分别是RDB(Redis DataBase)和AOF(Append Only File)。这两种机制的区别将在后面介绍AOF持久化中介绍。  </p>
<p>RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。<br>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为<code>dump.rdb</code>。</p>
<a id="more"></a>
<p><strong>2. RDB持久化的方式</strong><br>RDB持久化有三种方式，分别是：SAVE、BGSAVE、根据配置定期执行。<br>①.SAVE触发<br>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。<br>②.BGSAVE触发<br>执行该命令时，Redis会派生出一个子进程，然后由子进程负责创建 RDB 文件，父进程继续处理命令请求。<br>③.定期执行<br>定期执行的触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p>
<ul>
<li><strong>save</strong>：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如”save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li>
<li><strong>stop-writes-on-bgsave-error</strong>：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了。</li>
<li><strong>rdbcompression</strong>：默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li>
<li><strong>rdbchecksum</strong>：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li>
<li><strong>dbfilename</strong>：设置快照的文件名，默认是 dump.rdb。</li>
<li><strong>dir</strong>:设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>SAVE</th>
<th>BGSAVE</th>
</tr>
</thead>
<tbody>
<tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞状态</td>
<td>是</td>
<td>是（阻塞发生在fork）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fork，消耗内存</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3. RDB的优势和劣势</strong><br><strong>优势：</strong></p>
<ul>
<li>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li>
<li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
<p><strong>劣势：</strong><br>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p>
<p><strong>4. RDB文件结构</strong><br>一个rdb可以分为以下几个部分：</p>
<ul>
<li>REDIS：5字节，保存着 “REDIS” 五个字符</li>
<li>db_version：4字节，RDB文件的版本号</li>
<li>databases：数据库中的键值对<ul>
<li>SELECTDB：1字节常量</li>
<li>db_number：数据库号码</li>
<li>key_value_pairs：键值对（含过期时间的键值对会带有 EXPIRETIME_MS 和过期时间 ms）<ul>
<li>EXPIRETIME_MS：标识符，对应的值是该key的过期时间戳，含过期时间的键值对才有该数据</li>
<li>ms：过期时间戳，含过期时间的键值对才有该数据</li>
<li>TYPE：该key的数据类型</li>
<li>key：key对应的字符串</li>
<li>value：key对应的值</li>
</ul>
</li>
</ul>
</li>
<li><p>EOF：标志着数据库内容的结尾（不是文件的结尾）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_OPCODE_EOF        255</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>check_sum：校验和（CRC64），用来检查RDB文件是否出错</p>
</li>
</ul>
<p>图示如下：<br><img src="https://i.loli.net/2020/10/29/K5OtPgSx2keF46U.png" alt="rdb1.png"></p>
<p><strong>4.1 TYPE编码</strong><br><code>TYPE</code>常量记录了值对象的类型和编码，规则如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_LIST   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_SET    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_ZSET   3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_HASH   4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_ZSET_2 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_MODULE 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_MODULE_2 7</span></span><br><span class="line"><span class="comment">/* Object types for encoded objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_HASH_ZIPMAP    9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_LIST_ZIPLIST  10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_SET_INTSET    11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_ZSET_ZIPLIST  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_HASH_ZIPLIST  13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_LIST_QUICKLIST 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_STREAM_LISTPACKS 15</span></span><br></pre></td></tr></table></figure>
<p><strong>4.2 key</strong><br>在RDB文件中有很多地方需要存储长度信息，如字符串长度、list长度等等。如果使用固定的int或long类型来存储该信息，在长度值比较小的时候会造成较大的空间浪费。为了节省空间，Redis也是无所不用其极，设计了一套特殊的方法对长度进行编码后再存储。</p>
<p>RDB文件中的长度编码主要通过读取第一字节的最高 2 位来决定接下来如何解析长度信息，在 <code>rdbSaveLen()</code> 函数中，我们可以看到有以下四种方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编码方式</th>
<th>占用字节数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>00\</td>
<td>000000</td>
<td>1byte</td>
<td>这一字节的其余 6 位表示长度，可以保存的最大长度是 63 （包括在内）</td>
</tr>
<tr>
<td>01\</td>
<td>000000 00000000</td>
<td>2byte</td>
<td>长度为 14 位，当前字节 6 位，加上下个字节 8 位</td>
</tr>
<tr>
<td>10\</td>
<td>000000 [32 bit integer]</td>
<td>5byte</td>
<td>长度由随后的 32 位整数保存</td>
</tr>
<tr>
<td>11\</td>
<td>000000</td>
<td></td>
<td>后跟一个特殊编码的对象。字节中的 6 位（实际上只用到两个bit）指定对象的类型，用来确定怎样读取和解析接下来的数据</td>
</tr>
</tbody>
</table>
</div>
<p><code>rdbSaveLen()</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveLen</span><span class="params">(rio *rdb, <span class="keyword">uint64_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">size_t</span> nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) &#123;</span><br><span class="line">        <span class="comment">/* Save a 6 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = (len&amp;<span class="number">0xFF</span>)|(RDB_6BITLEN&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) &#123;</span><br><span class="line">        <span class="comment">/* Save a 14 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = ((len&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>)|(RDB_14BITLEN&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        buf[<span class="number">1</span>] = len&amp;<span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">2</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt;= UINT32_MAX) &#123;</span><br><span class="line">        <span class="comment">/* Save a 32 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = RDB_32BITLEN;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> len32 = htonl(len);</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,&amp;len32,<span class="number">4</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">1</span>+<span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Save a 64 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = RDB_64BITLEN;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        len = htonu64(len);</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,&amp;len,<span class="number">8</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">1</span>+<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nwritten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数主要功能"><a href="#函数主要功能" class="headerlink" title="函数主要功能"></a>函数主要功能</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span></span>; <span class="comment">// 保存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi, <span class="keyword">int</span> rdbflags)</span></span>; <span class="comment">// 加载</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoadRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<p><strong>数据保存到rdb文件中：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> cwd[MAXPATHLEN]; <span class="comment">/* Current working dir path for error messages. */</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建rdb文件</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-%d.rdb&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed opening the RDB file %s (in server root dir %s) &quot;</span></span><br><span class="line">            <span class="string">&quot;for saving: %s&quot;</span>,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化rio</span></span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    startSaving(RDBFLAGS_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_save_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将db中的数据存入到rio中</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveRio(&amp;rdb,&amp;error,RDBFLAGS_NONE,rsi) == C_ERR) &#123;</span><br><span class="line">        errno = error;</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure data will not remain on the OS&#x27;s output buffers */</span></span><br><span class="line">    <span class="comment">// 同步数据到磁盘文件中</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></span><br><span class="line"><span class="comment">     * if the generate DB file is ok. */</span></span><br><span class="line">    <span class="comment">// 重命名rdb文件</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Error moving temp DB file %s on the final &quot;</span></span><br><span class="line">            <span class="string">&quot;destination %s (in server root dir %s): %s&quot;</span>,</span><br><span class="line">            tmpfile,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        stopSaving(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;DB saved on disk&quot;</span>);</span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line">    server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    stopSaving(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error saving DB on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    stopSaving(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">uint64_t</span> cksum;</span><br><span class="line">    <span class="keyword">size_t</span> processed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">&quot;REDIS%04d&quot;</span>,RDB_VERSION);</span><br><span class="line">    <span class="comment">// 保存REDIS RDB_VERSION</span></span><br><span class="line">    <span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 保存一些生产rdb文件的默认字段信息</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存数据库信息</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the SELECT DB opcode */</span></span><br><span class="line">        <span class="comment">// 保存SELECTDB常量和dbid</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the RESIZE DB opcode. We trim the size to UINT32_MAX, which</span></span><br><span class="line"><span class="comment">         * is currently the largest type we are able to represent in RDB sizes.</span></span><br><span class="line"><span class="comment">         * However this does not limit the actual size of the DB to load since</span></span><br><span class="line"><span class="comment">         * these sizes are just hints to resize the hash tables. */</span></span><br><span class="line">        <span class="keyword">uint64_t</span> db_size, expires_size;</span><br><span class="line">        db_size = dictSize(db-&gt;dict);</span><br><span class="line">        expires_size = dictSize(db-&gt;expires);</span><br><span class="line">        <span class="comment">// 保存RESIZEDB常量，数据库size和设置expire的key-value的size</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,db_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,expires_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line">        <span class="comment">// 遍历数据库的键空间，将数据库中的key-value存到rdb文件</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr = dictGetKey(de);</span><br><span class="line">            robj key, *o = dictGetVal(de);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            expire = getExpire(db,&amp;key);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When this RDB is produced as part of an AOF rewrite, move</span></span><br><span class="line"><span class="comment">             * accumulated diff from parent to child while rewriting in</span></span><br><span class="line"><span class="comment">             * order to have a smaller final write. */</span></span><br><span class="line">            <span class="keyword">if</span> (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">                rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">            &#123;</span><br><span class="line">                processed = rdb-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don&#x27;t release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are storing the replication information on disk, persist</span></span><br><span class="line"><span class="comment">     * the script cache as well: on successful PSYNC after a restart, we need</span></span><br><span class="line"><span class="comment">     * to be able to process any EVALSHA inside the replication backlog the</span></span><br><span class="line"><span class="comment">     * master will send us. */</span></span><br><span class="line">    <span class="keyword">if</span> (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123;</span><br><span class="line">        di = dictGetIterator(server.lua_scripts);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            robj *body = dictGetVal(de);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveAuxField(rdb,<span class="string">&quot;lua&quot;</span>,<span class="number">3</span>,body-&gt;ptr,sdslen(body-&gt;ptr)) == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don&#x27;t release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF opcode */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></span><br><span class="line"><span class="comment">     * loading code skips the check in this case. */</span></span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="keyword">if</span> (error) *error = errno;</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从rdb文件中加载数据：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi, <span class="keyword">int</span> rdbflags)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 获取文件状态写入server结构体中（如加载的文件大小、加载时间等）</span></span><br><span class="line">    startLoadingFile(fp, filename,rdbflags);</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp); <span class="comment">// 初始化rio</span></span><br><span class="line">    retval = rdbLoadRio(&amp;rdb,rdbflags,rsi);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    stopLoading(retval==C_OK);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoadRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> dbid;</span><br><span class="line">    <span class="keyword">int</span> type, rdbver;</span><br><span class="line">    redisDb *db = server.db+<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    rdb-&gt;update_cksum = rdbLoadProgressCallback;</span><br><span class="line">    rdb-&gt;max_processing_chunk = server.loading_process_events_interval_bytes;</span><br><span class="line">    <span class="comment">// 读取REDIS RDB_VERSION</span></span><br><span class="line">    <span class="keyword">if</span> (rioRead(rdb,buf,<span class="number">9</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">    buf[<span class="number">9</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 检查REDIS RDB_VERSION</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(buf,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Wrong signature trying to load DB from file&quot;</span>);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    rdbver = atoi(buf+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (rdbver &lt; <span class="number">1</span> || rdbver &gt; RDB_VERSION) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t handle RDB format version %d&quot;</span>,rdbver);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Key-specific attributes, set by opcodes before the key type. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lru_idle = <span class="number">-1</span>, lfu_freq = <span class="number">-1</span>, expiretime = <span class="number">-1</span>, now = mstime();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lru_clock = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始读取数据写入到数据库中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        robj *key, *val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read type. */</span></span><br><span class="line">        <span class="comment">// 读取数据的类型</span></span><br><span class="line">        <span class="keyword">if</span> ((type = rdbLoadType(rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle special types. */</span></span><br><span class="line">        <span class="comment">// 根据不同的类型进行相应的处理</span></span><br><span class="line">        <span class="keyword">if</span> (type == RDB_OPCODE_EXPIRETIME) &#123;</span><br><span class="line">            <span class="comment">/* EXPIRETIME: load an expire associated with the next key</span></span><br><span class="line"><span class="comment">             * to load. Note that after loading an expire we need to</span></span><br><span class="line"><span class="comment">             * load the actual type, and continue. */</span></span><br><span class="line">            expiretime = rdbLoadTime(rdb);</span><br><span class="line">            expiretime *= <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (rioGetReadError(rdb)) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_EXPIRETIME_MS) &#123;</span><br><span class="line">            <span class="comment">/* EXPIRETIME_MS: milliseconds precision expire times introduced</span></span><br><span class="line"><span class="comment">             * with RDB v3. Like EXPIRETIME but no with more precision. */</span></span><br><span class="line">            expiretime = rdbLoadMillisecondTime(rdb,rdbver);</span><br><span class="line">            <span class="keyword">if</span> (rioGetReadError(rdb)) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_FREQ) &#123;</span><br><span class="line">            <span class="comment">/* FREQ: LFU frequency. */</span></span><br><span class="line">            <span class="keyword">uint8_t</span> byte;</span><br><span class="line">            <span class="keyword">if</span> (rioRead(rdb,&amp;byte,<span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            lfu_freq = byte;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_IDLE) &#123;</span><br><span class="line">            <span class="comment">/* IDLE: LRU idle time. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> qword;</span><br><span class="line">            <span class="keyword">if</span> ((qword = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            lru_idle = qword;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_EOF) &#123;</span><br><span class="line">            <span class="comment">/* EOF: End of file, exit the main loop. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_SELECTDB) &#123;</span><br><span class="line">            <span class="comment">/* SELECTDB: Select the specified database. */</span></span><br><span class="line">            <span class="keyword">if</span> ((dbid = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> (dbid &gt;= (<span class="keyword">unsigned</span>)server.dbnum) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;FATAL: Data file was created with a Redis &quot;</span></span><br><span class="line">                    <span class="string">&quot;server configured to handle more than %d &quot;</span></span><br><span class="line">                    <span class="string">&quot;databases. Exiting\n&quot;</span>, server.dbnum);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            db = server.db+dbid;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_RESIZEDB) &#123;</span><br><span class="line">            <span class="comment">/* RESIZEDB: Hint about the size of the keys in the currently</span></span><br><span class="line"><span class="comment">             * selected data base, in order to avoid useless rehashing. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> db_size, expires_size;</span><br><span class="line">            <span class="keyword">if</span> ((db_size = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR)</span><br><span class="line">                <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> ((expires_size = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR)</span><br><span class="line">                <span class="keyword">goto</span> eoferr;</span><br><span class="line">            dictExpand(db-&gt;dict,db_size);</span><br><span class="line">            dictExpand(db-&gt;expires,expires_size);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_AUX) &#123;</span><br><span class="line">            <span class="comment">/* AUX: generic string-string fields. Use to add state to RDB</span></span><br><span class="line"><span class="comment">             * which is backward compatible. Implementations of RDB loading</span></span><br><span class="line"><span class="comment">             * are requierd to skip AUX fields they don&#x27;t understand.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * An AUX field is composed of two strings: key and value. */</span></span><br><span class="line">            robj *auxkey, *auxval;</span><br><span class="line">            <span class="keyword">if</span> ((auxkey = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> ((auxval = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((<span class="keyword">char</span>*)auxkey-&gt;ptr)[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">/* All the fields with a name staring with &#x27;%&#x27; are considered</span></span><br><span class="line"><span class="comment">                 * information fields and are logged at startup with a log</span></span><br><span class="line"><span class="comment">                 * level of NOTICE. */</span></span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;RDB &#x27;%s&#x27;: %s&quot;</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxkey-&gt;ptr,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;repl-stream-db&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi) rsi-&gt;repl_stream_db = atoi(auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;repl-id&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi &amp;&amp; sdslen(auxval-&gt;ptr) == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(rsi-&gt;repl_id,auxval-&gt;ptr,CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">                    rsi-&gt;repl_id_is_set = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;repl-offset&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi) rsi-&gt;repl_offset = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;lua&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Load the script back in memory. */</span></span><br><span class="line">                <span class="keyword">if</span> (luaCreateFunction(<span class="literal">NULL</span>,server.lua,auxval) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    rdbExitReportCorruptRDB(</span><br><span class="line">                        <span class="string">&quot;Can&#x27;t load Lua script from RDB file! &quot;</span></span><br><span class="line">                        <span class="string">&quot;BODY: %s&quot;</span>, auxval-&gt;ptr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;redis-ver&quot;</span>)) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;Loading RDB produced by version %s&quot;</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;ctime&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">time_t</span> age = time(<span class="literal">NULL</span>)-strtol(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (age &lt; <span class="number">0</span>) age = <span class="number">0</span>;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;RDB age %ld seconds&quot;</span>,</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) age);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;used-mem&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> usedmem = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;RDB memory usage when created %.2f Mb&quot;</span>,</span><br><span class="line">                    (<span class="keyword">double</span>) usedmem / (<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;aof-preamble&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> haspreamble = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (haspreamble) serverLog(LL_NOTICE,<span class="string">&quot;RDB has an AOF tail&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;redis-bits&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Just ignored. */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* We ignore fields we don&#x27;t understand, as by AUX field</span></span><br><span class="line"><span class="comment">                 * contract. */</span></span><br><span class="line">                serverLog(LL_DEBUG,<span class="string">&quot;Unrecognized RDB AUX field: &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxkey-&gt;ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            decrRefCount(auxkey);</span><br><span class="line">            decrRefCount(auxval);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read type again. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_MODULE_AUX) &#123;</span><br><span class="line">            <span class="comment">/* Load module data that is not related to the Redis key space.</span></span><br><span class="line"><span class="comment">             * Such data can be potentially be stored both before and after the</span></span><br><span class="line"><span class="comment">             * RDB keys-values section. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> moduleid = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">int</span> when_opcode = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">int</span> when = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (rioGetReadError(rdb)) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> (when_opcode != RDB_MODULE_OPCODE_UINT)</span><br><span class="line">                rdbReportReadError(<span class="string">&quot;bad when_opcode&quot;</span>);</span><br><span class="line">            moduleType *mt = moduleTypeLookupModuleByID(moduleid);</span><br><span class="line">            <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">            moduleTypeNameByID(name,moduleid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!rdbCheckMode &amp;&amp; mt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Unknown module. */</span></span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains AUX module data I can&#x27;t load: no matching module &#x27;%s&#x27;&quot;</span>, name);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rdbCheckMode &amp;&amp; mt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mt-&gt;aux_load) &#123;</span><br><span class="line">                    <span class="comment">/* Module doesn&#x27;t support AUX. */</span></span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains module AUX data, but the module &#x27;%s&#x27; doesn&#x27;t seem to support it.&quot;</span>, name);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                RedisModuleIO io;</span><br><span class="line">                moduleInitIOContext(io,mt,rdb,<span class="literal">NULL</span>);</span><br><span class="line">                io.ver = <span class="number">2</span>;</span><br><span class="line">                <span class="comment">/* Call the rdb_load method of the module providing the 10 bit</span></span><br><span class="line"><span class="comment">                 * encoding version in the lower 10 bits of the module ID. */</span></span><br><span class="line">                <span class="keyword">if</span> (mt-&gt;aux_load(&amp;io,moduleid&amp;<span class="number">1023</span>, when) != REDISMODULE_OK || io.error) &#123;</span><br><span class="line">                    moduleTypeNameByID(name,moduleid);</span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains module AUX data for the module type &#x27;%s&#x27;, that the responsible module is not able to load. Check for modules log above for additional clues.&quot;</span>, name);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (io.ctx) &#123;</span><br><span class="line">                    moduleFreeContext(io.ctx);</span><br><span class="line">                    zfree(io.ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">uint64_t</span> eof = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (eof != RDB_MODULE_OPCODE_EOF) &#123;</span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains module AUX data for the module &#x27;%s&#x27; that is not terminated by the proper module value EOF marker&quot;</span>, name);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* RDB check mode. */</span></span><br><span class="line">                robj *aux = rdbLoadCheckModuleValue(rdb,name);</span><br><span class="line">                decrRefCount(aux);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read key */</span></span><br><span class="line">        <span class="keyword">if</span> ((key = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">        <span class="comment">/* Read value */</span></span><br><span class="line">        <span class="keyword">if</span> ((val = rdbLoadObject(type,rdb,key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            <span class="keyword">goto</span> eoferr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the key already expired. This function is used when loading</span></span><br><span class="line"><span class="comment">         * an RDB file from disk, either at startup, or when an RDB was</span></span><br><span class="line"><span class="comment">         * received from the master. In the latter case, the master is</span></span><br><span class="line"><span class="comment">         * responsible for key expiry. If we would expire keys here, the</span></span><br><span class="line"><span class="comment">         * snapshot taken by the master may not be reflected on the slave. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; !(rdbflags&amp;RDBFLAGS_AOF_PREAMBLE) &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            decrRefCount(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Add the new object in the hash table */</span></span><br><span class="line">            dbAdd(db,key,val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Set the expire time if needed */</span></span><br><span class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) setExpire(<span class="literal">NULL</span>,db,key,expiretime);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Set usage information (for eviction). */</span></span><br><span class="line">            objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Decrement the key refcount since dbAdd() will take its</span></span><br><span class="line"><span class="comment">             * own reference. */</span></span><br><span class="line">            decrRefCount(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server.key_load_delay)</span><br><span class="line">            usleep(server.key_load_delay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Reset the state that is key-specified and is populated by</span></span><br><span class="line"><span class="comment">         * opcodes before the key, so that we start from scratch again. */</span></span><br><span class="line">        expiretime = <span class="number">-1</span>;</span><br><span class="line">        lfu_freq = <span class="number">-1</span>;</span><br><span class="line">        lru_idle = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Verify the checksum if RDB version is &gt;= 5 */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbver &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> cksum, expected = rdb-&gt;cksum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rioRead(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">        <span class="keyword">if</span> (server.rdb_checksum) &#123;</span><br><span class="line">            memrev64ifbe(&amp;cksum);</span><br><span class="line">            <span class="keyword">if</span> (cksum == <span class="number">0</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;RDB file was saved with checksum disabled: no check performed.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != expected) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Wrong RDB checksum. Aborting now.&quot;</span>);</span><br><span class="line">                rdbExitReportCorruptRDB(<span class="string">&quot;RDB CRC error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unexpected end of file is handled here calling rdbReportReadError():</span></span><br><span class="line"><span class="comment">     * this will in turn either abort Redis in most cases, or if we are loading</span></span><br><span class="line"><span class="comment">     * the RDB file from a socket during initial SYNC (diskless replica mode),</span></span><br><span class="line"><span class="comment">     * we&#x27;ll report the error to the caller, so that we can retry. */</span></span><br><span class="line">eoferr:</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">&quot;Short read or OOM loading DB. Unrecoverable error, aborting now.&quot;</span>);</span><br><span class="line">    rdbReportReadError(<span class="string">&quot;Unexpected EOF reading RDB file&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>3-database</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-集合对象set</title>
    <url>/Redis/2-object/redis-parse-set/</url>
    <content><![CDATA[<p>源码位置：t_set.c/server.h</p>
<p>set对象底层编码方式有两种，<code>intset</code>或<code>hashtable</code>。<br>使用intset编码的条件：  </p>
<ul>
<li>集合对象中所有元素都是整数值。</li>
<li>集合对象保存的元素个数不超过512个。（可通过redis.conf配置：set_max_intset_entries）</li>
</ul>
<a id="more"></a>
<p>下面让我们测试一下：<br>例1：<br><img src="https://i.loli.net/2020/10/29/vnkPheCN7RUdKSj.png" alt="t_set_intset1.png"><br>当添加非整数的字符串时，则会转为hashtable编码<br><img src="https://i.loli.net/2020/10/29/WaIGyVSbJtMu4HE.png" alt="t_set_intset2.png"></p>
<p>例2：<br>插入512个整数，使用的是intset编码<br><img src="https://i.loli.net/2020/10/29/8r4QGNk6LVvTxbu.png" alt="t_set_intset3.png"><br>当插入第513个整数时，将会转为hashtable编码<br><img src="https://i.loli.net/2020/10/29/AISc4z7bOYN9pmF.png" alt="t_set_intset4.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td>添加一个或多个元素到集合里</td>
<td>O(N)，N为添加的元素个数</td>
</tr>
<tr>
<td>SCARD</td>
<td>返回集合存储的key的基数 (集合元素的数量)</td>
<td>O(1)</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>返回成员member是否是存储的集合key的成员</td>
<td>O(1)</td>
</tr>
<tr>
<td>SINTER</td>
<td>返回指定所有的集合的成员的交集</td>
<td>O(N*M)，其中N是最小集合的基数，M是集合的数目</td>
</tr>
<tr>
<td>SINTERSTORE</td>
<td>类似SINTER，将结果存放到destination集合中，如果destination存在，则覆盖重写</td>
<td>O(N*M)，其中N是最小集合的基数，M是集合的数目</td>
</tr>
<tr>
<td>SDIFF</td>
<td>返回一个集合与给定集合的差集的元素</td>
<td>O(N)，N为所有集合的元素总数</td>
</tr>
<tr>
<td>SDIFFSTORE</td>
<td>类似SDIFF，将结果存放到destination集合中，如果destination存在，则覆盖重写</td>
<td>O(N)，N为所有集合的元素总数</td>
</tr>
<tr>
<td>SUNION</td>
<td>返回给定的多个集合的并集中的所有成员</td>
<td>O(N)</td>
</tr>
<tr>
<td>SUNIONSTORE</td>
<td>类似SUNION，将结果存放到destination集合中，如果destination存在，则覆盖重写</td>
<td>平均O(N)</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>返回key集合所有的元素，由SINTER实现</td>
<td>O(N)，N为该集合元素总数</td>
</tr>
<tr>
<td>SMOVE</td>
<td>将member从source集合移动到destination集合中</td>
<td>O(1)</td>
</tr>
<tr>
<td>SPOP</td>
<td>从存储在key的集合中移除并返回一个或多个随机元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>SRANDMEMBER</td>
<td>类似SPOP，区别是该命令不删除元素</td>
<td>O(N)，N为指定count的值</td>
</tr>
<tr>
<td>SREM</td>
<td>在key集合中移除指定的元素</td>
<td>O(N)，N为指定的元素个数</td>
</tr>
<tr>
<td>SSCAN</td>
<td>用于迭代集合类型中的集合成员</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sadd命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scardCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// scard命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sdiff命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffstoreCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sdiffstore命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sinter和smembers命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterstoreCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sinterstore命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sismemberCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sismember命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoveCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// smove命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// spop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srandmemberCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// srandmember命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sremCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// srem命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sscanCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sscan命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sunion命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionstoreCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sunionstore命令</span></span><br></pre></td></tr></table></figure>
<h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr>
<p>插入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure>
<p>代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">int</span> j, added = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果db中不存在该key，则根据元素类型选择使用intset编码或者hashtable编码创建set集合</span></span><br><span class="line">        <span class="built_in">set</span> = setTypeCreate(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="built_in">set</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;type != OBJ_SET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeAdd(<span class="built_in">set</span>,c-&gt;argv[j]-&gt;ptr)) added++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (added) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_SET,<span class="string">&quot;sadd&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += added;</span><br><span class="line">    addReplyLongLong(c,added);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">/* Convert to regular set when the intset contains</span></span><br><span class="line"><span class="comment">                 * too many entries. */</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Failed to get integer from object, convert to regular set. */</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The set *was* an intset and this value is not integer</span></span><br><span class="line"><span class="comment">             * encodable, so dictAdd should always work. */</span></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>交集命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SINTER key [key ...]</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line">SMEMBERS key <span class="comment">// 该命令是通过SINTER命令实现的</span></span><br></pre></td></tr></table></figure>
<p>代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setkeys：集合数组指针</span></span><br><span class="line"><span class="comment">// setnum：集合数量（命令中key的个数）</span></span><br><span class="line"><span class="comment">// dstkey：结果集是否添加到新的集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterGenericCommand</span><span class="params">(client *c, robj **setkeys,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">unsigned</span> <span class="keyword">long</span> setnum, robj *dstkey)</span> </span>&#123;</span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    sds elesds;</span><br><span class="line">    <span class="keyword">int64_t</span> intobj;</span><br><span class="line">    <span class="keyword">void</span> *replylen = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dbDelete(c-&gt;db,dstkey)) &#123;</span><br><span class="line">                    signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">                    server.dirty++;</span><br><span class="line">                &#125;</span><br><span class="line">                addReply(c,shared.czero);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReply(c,shared.emptyset[c-&gt;resp]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[j] = setobj; <span class="comment">// 从db中获取的集合对象存入到临时数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据集合的大小从小到大进行排序</span></span><br><span class="line">    qsort(sets,setnum,<span class="keyword">sizeof</span>(robj*),qsortCompareSetsByCardinality);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        replylen = addReplyDeferredLen(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dstset = createIntsetObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    si = setTypeInitIterator(sets[<span class="number">0</span>]); <span class="comment">// 从第一个集合开始遍历</span></span><br><span class="line">    <span class="comment">// 此处是while+for循环，所有时间复杂度是O(N*M)</span></span><br><span class="line">    <span class="keyword">while</span>((encoding = setTypeNext(si,&amp;elesds,&amp;intobj)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="comment">// 判断第一个集合的元素是否在集合j中</span></span><br><span class="line">            <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_INTSET &amp;&amp;</span><br><span class="line">                    !intsetFind((intset*)sets[j]-&gt;ptr,intobj))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                    elesds = sdsfromlonglong(intobj);</span><br><span class="line">                    <span class="keyword">if</span> (!setTypeIsMember(sets[j],elesds)) &#123;</span><br><span class="line">                        sdsfree(elesds);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sdsfree(elesds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!setTypeIsMember(sets[j],elesds)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT)</span><br><span class="line">                    addReplyBulkCBuffer(c,elesds,sdslen(elesds));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    addReplyBulkLongLong(c,intobj);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                    elesds = sdsfromlonglong(intobj);</span><br><span class="line">                    setTypeAdd(dstset,elesds);</span><br><span class="line">                    sdsfree(elesds);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setTypeAdd(dstset,elesds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setTypeReleaseIterator(si);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">        <span class="keyword">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,<span class="string">&quot;sinterstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setDeferredSetLen(c,replylen,cardinality);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>并集&amp;差集命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">并集：</span><br><span class="line">SUNION key [key ...]</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line">差集：</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_UNION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_UNION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_DIFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_DIFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionDiffGenericCommand</span><span class="params">(client *c, robj **setkeys, <span class="keyword">int</span> setnum,</span></span></span><br><span class="line"><span class="function"><span class="params">                              robj *dstkey, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">int</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> diff_algo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            sets[j] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[j] = setobj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 差集算法有两种：</span></span><br><span class="line"><span class="comment">     * 算法1： 时间复杂度为O(N*M)，N是第一个集合的大小，M是集合的总数</span></span><br><span class="line"><span class="comment">     * 算法2： 时间复杂度为O(N)，N是所有集合的元素总数</span></span><br><span class="line"><span class="comment">     * 根据输入条件计算选择使用哪种算法 */</span></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> algo_one_work = <span class="number">0</span>, algo_two_work = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sets[j] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            algo_one_work += setTypeSize(sets[<span class="number">0</span>]);</span><br><span class="line">            algo_two_work += setTypeSize(sets[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 算法1 具有更好的常数时间，并且如果有共同的元素，则执行的操作更少。 */</span></span><br><span class="line">        algo_one_work /= <span class="number">2</span>;</span><br><span class="line">        diff_algo = (algo_one_work &lt;= algo_two_work) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff_algo == <span class="number">1</span> &amp;&amp; setnum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            qsort(sets+<span class="number">1</span>,setnum<span class="number">-1</span>,<span class="keyword">sizeof</span>(robj*),</span><br><span class="line">                qsortCompareSetsByRevCardinality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个临时的set进行存储元素，如果是store模式，则存储该临时集合 */</span></span><br><span class="line">    dstset = createIntsetObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_UNION) &#123;</span><br><span class="line">        <span class="comment">/* 并集很简单，只需要把所有集合的元素放入到临时集合中就能得出 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* non existing keys are like empty sets */</span></span><br><span class="line"></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                sdsfree(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 差集算法1:</span></span><br><span class="line"><span class="comment">         * 通过迭代第一个集合的所有元素来进行差集判断，</span></span><br><span class="line"><span class="comment">         * 当第一个集合的元素不存在于其他所有的集合中时，</span></span><br><span class="line"><span class="comment">         * 才将元素插入到临时集合中。*/</span></span><br><span class="line">        si = setTypeInitIterator(sets[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* no key is an empty set. */</span></span><br><span class="line">                <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">break</span>; <span class="comment">/* same set! */</span></span><br><span class="line">                <span class="keyword">if</span> (setTypeIsMember(sets[j],ele)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">                <span class="comment">/* 当前元素不存在与其他集合中时，添加到临时集合dstset中 */</span></span><br><span class="line">                setTypeAdd(dstset,ele);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125;</span><br><span class="line">            sdsfree(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* 差集算法2:</span></span><br><span class="line"><span class="comment">         * 首先将第一个集合的元素插入到临时集合中，</span></span><br><span class="line"><span class="comment">         * 然后从中移除其他集合的所有元素。 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把第一个集合的元素添加到dstset中</span></span><br><span class="line">                    <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 从dstset中移除其他集合的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (setTypeRemove(dstset,ele)) cardinality--;</span><br><span class="line">                &#125;</span><br><span class="line">                sdsfree(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果临时集合dstset为空，则表示第一个集合的元素在其他集合中都存在，</span></span><br><span class="line"><span class="comment">             * 没有差集，直接退出循环 */</span></span><br><span class="line">            <span class="keyword">if</span> (cardinality == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        addReplySetLen(c,cardinality);</span><br><span class="line">        si = setTypeInitIterator(dstset);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyBulkCBuffer(c,ele,sdslen(ele));</span><br><span class="line">            sdsfree(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">        server.lazyfree_lazy_server_del ? freeObjAsync(dstset) :</span><br><span class="line">                                          decrRefCount(dstset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we have a target key where to store the resulting set</span></span><br><span class="line"><span class="comment">         * create this key with the result set inside */</span></span><br><span class="line">        <span class="keyword">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,</span><br><span class="line">                op == SET_OP_UNION ? <span class="string">&quot;sunionstore&quot;</span> : <span class="string">&quot;sdiffstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>其他命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SISMEMBER key member</span><br><span class="line">SCARD key</span><br><span class="line">SMOVE source destination member</span><br><span class="line">SPOP key [count]</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line">SREM key member [member ...]</span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>2-object</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-字符串对象string</title>
    <url>/Redis/2-object/redis-parse-string/</url>
    <content><![CDATA[<p>源码位置：t_string.c/server.h</p>
<p>字符串是redis中最常用的数据结构，在对象系统object一文中我们提到，字符串数据结构根据场景会有三种编码类型：<code>OBJ_ENCODING_RAW</code>、<code>OBJ_ENCODING_INT</code>、<code>OBJ_ENCODING_EMBSTR</code>，分别对应底层数据结构：sds、int、sds。下面说说这三种编码类型的使用场景。<br><a id="more"></a><br>根据redisObject数据结构可以得知，一般创建object对象时，object和数据本身在内存中是分开的，要进行两次内存分配。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS;</span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>而OBJ_ENCODING_EMBSTR的做法是，创建object之前，先计算object和数据的大小总和，然后一次性申请足够的内存空间，数据直接跟在object对象后面。这种编码是有大小限制的，因为redis采用jemalloc内存分配器，可以分配8，16，32，64字节大小的内存空间，所以申请内存时，redisObject占用16字节，sdshdr8占用3字节，数据结尾’\0’占用1字节，那么实际数据的长度限制为：64-16-8-1=44字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br></pre></td></tr></table></figure>
<p>所以当数据长度小于44时，用EMBSTR编码，否则使用OBJ_ENCODING_RAW编码。如果一个字符串对象保存的是整数值，并且可以用long类型来表示，则将字符串对象转为long，设置编码类型为OBJ_ENCODING_INT。  </p>
<p>下面让我们看看实例：<br><img src="https://i.loli.net/2020/10/29/FGenSOc6ahzXitD.png" alt="t_string.png"></p>
<p>INT和EMBSTR编码的字符串对象在条件满足的情况下，会转换为RAW编码。<br>比如INT编码对象在执行APPEND命令追加一段字符串时，将会转换为RAW编码，因为追加操作只支持字符串值，所以会把之前保存的整数值转为字符串后，再执行追加操作，这时就会转为RAW编码。<br><img src="https://i.loli.net/2020/10/29/QrxyXTWqIAVBw68.png" alt="t_string_int_to_raw.png"></p>
<p>而redis没有提供对EMBSTR编码的字符串对象的修改操作，所以当进行追加操作时，也会先转为RAW编码，然后再进行追加。<br><img src="https://i.loli.net/2020/10/29/o6jMV3wTs8alZdv.png" alt="t_string_embstr_to_raw.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取key对应的value</td>
<td>O(1)</td>
</tr>
<tr>
<td>MGET</td>
<td>获取多个keys对应的values</td>
<td>O(N)，N为key的数量</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>返回key对应的字符串value的子串，由start和end位移决定</td>
<td>O(N)，N为字符串长度</td>
</tr>
<tr>
<td>SET</td>
<td>设置一个key的value值</td>
<td>O(1)</td>
</tr>
<tr>
<td>MSET</td>
<td>设置多个keys的values值</td>
<td>O(1)</td>
</tr>
<tr>
<td>SETNX</td>
<td>key不存在时才设置value值（可通过set命令+NX参数实现）</td>
<td>O(1)</td>
</tr>
<tr>
<td>MSETNX</td>
<td>keys不存在时才设置values值</td>
<td>O(1)</td>
</tr>
<tr>
<td>SETEX</td>
<td>key存在时才设置值，到期时间以秒为单位（可通过set命令+XX参数实现）</td>
<td>O(1)</td>
</tr>
<tr>
<td>PSETEX</td>
<td>和setex唯一的区别是到期时间以毫秒为单位（可通过set命令+XX+PX参数实现）</td>
<td>O(1)</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>覆盖key对应的string的一部分，从指定长度offset处开始，覆盖value的长度</td>
<td>O(1)</td>
</tr>
<tr>
<td>APPEND</td>
<td>指定key的值结尾追加字符串</td>
<td>O(1)</td>
</tr>
<tr>
<td>GETSET</td>
<td>自动将key对应到value并且返回原来key对应的value</td>
<td>O(1)</td>
</tr>
<tr>
<td>INCR</td>
<td>对存储在指定key的数值执行原子的加1操作</td>
<td>O(1)</td>
</tr>
<tr>
<td>INCRBY</td>
<td>将key对应的数字加上指定的整数值</td>
<td>O(1)</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>将key对应的数字加上指定的浮点数值</td>
<td>O(1)</td>
</tr>
<tr>
<td>DECR</td>
<td>对key对应的数字做减1操作</td>
<td>O(1)</td>
</tr>
<tr>
<td>DECRBY</td>
<td>将key对应的数字减去指定的整数值</td>
<td>O(1)</td>
</tr>
<tr>
<td>STRLEN</td>
<td>获取指定key对应value的长度</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// set命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// setnx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setexCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// setex命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psetexCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// psetex命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// mset命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetnxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// msetnx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setrangeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// setrange命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrangeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// getrange命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// get命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mgetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// mget命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// getset命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// incr命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// decr命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// incrby命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrbyCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// decrby命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyfloatCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// incrbyfloat命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// append命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strlenCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// strlen命令</span></span><br></pre></td></tr></table></figure>
<h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr>
<p>插入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET key value [NX] [XX] [KEEPTTL] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;]</span><br></pre></td></tr></table></figure>
<p>参数含义：</p>
<ul>
<li>EX seconds – 设置键key的过期时间，单位时秒  </li>
<li>PX milliseconds – 设置键key的过期时间，单位时毫秒  </li>
<li>NX – 只有键key不存在的时候才会设置key的值  </li>
<li>XX – 只有键key存在的时候才会设置key的值  </li>
</ul>
<p>代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj *expire = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</span><br><span class="line">    <span class="keyword">int</span> flags = OBJ_SET_NO_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析命令中的参数</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> *a = c-&gt;argv[j]-&gt;ptr;</span><br><span class="line">        robj *next = (j == c-&gt;argc<span class="number">-1</span>) ? <span class="literal">NULL</span> : c-&gt;argv[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>) &amp;&amp;</span><br><span class="line">            (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">            !(flags &amp; OBJ_SET_XX))</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_NX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_NX))</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_XX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">&quot;KEEPTTL&quot;</span>) &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_EX) &amp;&amp; !(flags &amp; OBJ_SET_PX))</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_KEEPTTL;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_KEEPTTL) &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_PX) &amp;&amp; next)</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_EX;</span><br><span class="line">            unit = UNIT_SECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_KEEPTTL) &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_EX) &amp;&amp; next)</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_PX;</span><br><span class="line">            unit = UNIT_MILLISECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断value是否可以进行整数编码，如果可以则使用INT编码</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 开始执行插入操作</span></span><br><span class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags, robj *key, robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply, robj *abort_reply)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> milliseconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123; <span class="comment">// 如果设定了过期时间，则将时间格式化为毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyErrorFormat(c,<span class="string">&quot;invalid expire time in %s&quot;</span>,c-&gt;cmd-&gt;name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断key是否存在，并根据NX/XX参数来决定是否插入value</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>) ||</span><br><span class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        addReply(c, abort_reply ? abort_reply : shared.null[c-&gt;resp]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将键值对插入到db中</span></span><br><span class="line">    genericSetKey(c-&gt;db,key,val,flags &amp; OBJ_SET_KEEPTTL);</span><br><span class="line">    server.dirty++; <span class="comment">// 存储上次保存前所有数据变动的长度+1</span></span><br><span class="line">    <span class="keyword">if</span> (expire) setExpire(c,c-&gt;db,key,mstime()+milliseconds); <span class="comment">// 设定过期时间</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">&quot;set&quot;</span>,key,c-&gt;db-&gt;id); <span class="comment">// 发送set事件通知</span></span><br><span class="line">    <span class="keyword">if</span> (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">        <span class="string">&quot;expire&quot;</span>,key,c-&gt;db-&gt;id); <span class="comment">// 发送定期事件通知</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok); <span class="comment">// 向客户端返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他与set相关的命令不做代码解析了，可以自行查看源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SETNX key value</span><br><span class="line">SETEX key value</span><br><span class="line">PSETEX key milliseconds value</span><br><span class="line">MSET key value [key value ...]</span><br><span class="line">MSETNX key value [key value ...]</span><br><span class="line">APPEND key value</span><br></pre></td></tr></table></figure>
<hr>
<p>获取命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure>
<p>代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    getGenericCommand(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGenericCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断key是否存在，存在则返回value，不存在则返回对应错误</span></span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.null[c-&gt;resp])) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != OBJ_STRING) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,o);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他与set相关的命令不做代码解析了，可以自行查看源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MGET key [key ...]</span><br><span class="line">GETRANGE key start end</span><br><span class="line">GETSET key value</span><br></pre></td></tr></table></figure>
<hr>
<p>自增自减命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INCR key</span><br><span class="line">DECR key</span><br></pre></td></tr></table></figure>
<p>代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INCR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DECR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrDecrCommand</span><span class="params">(client *c, <span class="keyword">long</span> <span class="keyword">long</span> incr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value, oldvalue;</span><br><span class="line">    robj *o, *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取db中的键值对</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>; <span class="comment">// 类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;value,<span class="literal">NULL</span>) != C_OK) <span class="keyword">return</span>; <span class="comment">// 是否能转为整数型，不能则返回</span></span><br><span class="line"></span><br><span class="line">    oldvalue = value;</span><br><span class="line">    <span class="comment">// 值范围检查</span></span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span> &amp;&amp; oldvalue &lt; <span class="number">0</span> &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</span><br><span class="line">        (incr &gt; <span class="number">0</span> &amp;&amp; oldvalue &gt; <span class="number">0</span> &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;increment or decrement would overflow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value += incr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp; o-&gt;refcount == <span class="number">1</span> &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</span><br><span class="line">        (value &lt; <span class="number">0</span> || value &gt;= OBJ_SHARED_INTEGERS) &amp;&amp;</span><br><span class="line">        value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> = o;</span><br><span class="line">        o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> = createStringObjectFromLongLongForValue(value); <span class="comment">// 通过value的类型创建新的字符串对象</span></span><br><span class="line">        <span class="keyword">if</span> (o) &#123;</span><br><span class="line">            dbOverwrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="keyword">new</span>); <span class="comment">// db中已存在，则覆盖</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="keyword">new</span>); <span class="comment">// 不存在则插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]); <span class="comment">// 发送修改key的信号</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">&quot;incrby&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id); <span class="comment">// 事件通知</span></span><br><span class="line">    server.dirty++; <span class="comment">// 存储上次保存前所有数据变动的长度+1</span></span><br><span class="line">    <span class="comment">// 客户端回复</span></span><br><span class="line">    addReply(c,shared.colon);</span><br><span class="line">    addReply(c,<span class="keyword">new</span>);</span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他与INCR和DECR相关的命令不做代码解析了，可以自行查看源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INCRBY key increment</span><br><span class="line">DECRBY key increment</span><br><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure>
<p>&lt;/br&gt;</p>
<hr>
<p>获取字符串长度命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure>
<p>代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strlenCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 从DB中获取键值对</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 返回给客户端字符串长度</span></span><br><span class="line">    addReplyLongLong(c,stringObjectLen(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>2-object</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-跳跃表zskiplist</title>
    <url>/Redis/1-data-structure/redis-parse-zskiplist/</url>
    <content><![CDATA[<p>源码位置：t_zset.c/server.h</p>
<p>跳跃表是zset有序集合的底层实现之一。<br><a id="more"></a><br><strong>节点插入：</strong> 跳跃表中，一个节点的插入，分为三个步骤。  </p>
<ol>
<li>根据新增节点的score值，从最高层开始往下对比查找到新增节点每一层（这里的“每一层”是指以当前跳跃表最高层为准，并不是新增节点的层数，因为此时新增节点还没有随机出层数）的前驱层的节点指针，redis使用update[ZSKIPLIST_MAXLEVEL]数组来记录。计算出从header的每一层到新增节点所经过的节点数，使用rank[ZSKIPLIST_MAXLEVEL]数组来记录。  </li>
<li>使用redis的随机算法，随机出新增节点的层数，如果高于当前层数，则更新跳跃表的最高层数、update数组对应的指向和rank数组对应的值（高出那部分的层数rank值为0）。  </li>
<li>进行跳跃表的插入，就是对新增节点插入位置相邻的节点间，根据update数组进行更改指针指向的操作，根据rank来计算出对应span的值。  </li>
</ol>
<p><strong>节点删除：</strong> 和节点插入的原理差不多，也需要用到update数组。根据score找到对应节点后，将节点抽离出来（根据update数组进行指针的重新指向，对应的span值减1），进行删除操作即可。</p>
<p><strong>节点更新：</strong> 和节点删除的原理差不多，如果跳跃表中没有该数据，则进行插入操作。  </p>
<p>跳跃表的结构如下：<br><img src="https://i.loli.net/2020/10/29/ita6M2wrNWv4Ufm.png" alt="zskiplist.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>zslCreate</td>
<td>创建跳跃表</td>
<td>O(1)</td>
</tr>
<tr>
<td>zslFree</td>
<td>释放跳跃表</td>
<td>O(n)</td>
</tr>
<tr>
<td>zslInsert</td>
<td>插入节点</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
<tr>
<td>zslDelete</td>
<td>删除节点</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
<tr>
<td>zslGetRank</td>
<td>返回指定分值和成员在跳跃表中的排位</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
<tr>
<td>zslGetElementByRank</td>
<td>返回跳跃表在给定排位的节点</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<p><strong>server.h:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score; <span class="comment">// 分值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 后继指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 前驱指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span; <span class="comment">// 跨度</span></span><br><span class="line">    &#125; level[]; <span class="comment">// 跳跃表的层</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// header为跳跃表的表头节点， tail为表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length; <span class="comment">// 跳跃表的长度</span></span><br><span class="line">    <span class="keyword">int</span> level; <span class="comment">// 跳跃表当前的层数</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32 <span class="comment">/* Should be enough for 2^64 elements */</span> <span class="comment">// 跳跃表层数，最大为32层，理论上当数据达到2^64时，才会能达到最顶层，所以完全足够</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span> <span class="comment">// 用于计算上层被分配到的概率</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Input flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_INCR (1&lt;&lt;0)    <span class="comment">/* Increment the score instead of setting it. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NX (1&lt;&lt;1)      <span class="comment">/* Don&#x27;t touch elements not already existing. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_XX (1&lt;&lt;2)      <span class="comment">/* Only touch elements already existing. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NOP (1&lt;&lt;3)     <span class="comment">/* Operation not performed because of conditionals.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NAN (1&lt;&lt;4)     <span class="comment">/* Only touch elements already existing. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_ADDED (1&lt;&lt;5)   <span class="comment">/* The element was new and was added. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_UPDATED (1&lt;&lt;6) <span class="comment">/* The element already existed, score updated. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Flags only used by the ZADD command but not by zsetAdd() API: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_CH (1&lt;&lt;16)      <span class="comment">/* Return num of elements added or updated. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec by score comparison. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> min, max;</span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zrangespec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    sds min, max;     <span class="comment">/* May be set to shared.(minstring|maxstring) */</span></span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zlexrangespec;</span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<p><strong>server.h:</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建跳跃表，分配指定级别数的跳跃表节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span></span>; <span class="comment">// 释放跳跃表</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span></span>; <span class="comment">// 跳跃表插入新节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele, zskiplistNode **node)</span></span>; <span class="comment">// 删除节点</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslFirstInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span></span>; <span class="comment">// 查找指定范围中的第一个节点</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslLastInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span></span>; <span class="comment">// 查找指定范围中的最后一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslValueGteMin</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslValueLteMax</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFreeLexRange</span><span class="params">(zlexrangespec *spec)</span></span>; <span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslParseLexRange</span><span class="params">(robj *min, robj *max, zlexrangespec *spec)</span></span>;</span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslFirstInLexRange</span><span class="params">(zskiplist *zsl, zlexrangespec *range)</span></span>;</span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslLastInLexRange</span><span class="params">(zskiplist *zsl, zlexrangespec *range)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslLexValueGteMin</span><span class="params">(sds value, zlexrangespec *spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslLexValueLteMax</span><span class="params">(sds value, zlexrangespec *spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds o)</span></span>; <span class="comment">// 返回指定分值和成员在跳跃表中的排位（位置）</span></span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Insert a new node in the skiplist. Assumes the element does not already</span></span><br><span class="line"><span class="comment"> * exist (up to the caller to enforce that). The skiplist takes ownership</span></span><br><span class="line"><span class="comment"> * of the passed SDS string &#x27;ele&#x27;. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; <span class="comment">// update数组用来记录新增节点的每一层的前驱节点指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL]; <span class="comment">// rank数组用来记录从header的每一层到新增节点所经过的节点数</span></span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层开始往下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 判断新增节点在跳跃表中所处的位置</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the element is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, reinserting the same element should never happen since the</span></span><br><span class="line"><span class="comment">     * caller of zslInsert() should test in the hash table if the element is</span></span><br><span class="line"><span class="comment">     * already inside or not. */</span></span><br><span class="line">    <span class="comment">// 随机生成新增节点的层数</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">// 如果随机生成的层数比当前跳跃表的层数高，则初始化高于跳跃表的最高层数的所有层</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新增节点</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="comment">// 根据update数组来进行新增节点的插入操作，根据rank数组来计算新增节点的跨度</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="comment">// 如果新增节点的层数低于跳跃表的层数，则高于新增节点的层数的跨度增加1</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新增节点的前置节点</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete an element with matching score/element from the skiplist.</span></span><br><span class="line"><span class="comment"> * The function returns 1 if the node was found and deleted, otherwise</span></span><br><span class="line"><span class="comment"> * 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If &#x27;node&#x27; is NULL the deleted node is freed by zslFreeNode(), otherwise</span></span><br><span class="line"><span class="comment"> * it is not freed (but just unlinked) and *node is set to the node pointer,</span></span><br><span class="line"><span class="comment"> * so that it is possible for the caller to reuse the node (including the</span></span><br><span class="line"><span class="comment"> * referenced SDS string at node-&gt;ele). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele, zskiplistNode **node)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层开始遍历，查找所要删除节点在跳跃表中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            zslFreeNode(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *node = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Update the score of an elmenent inside the sorted set skiplist.</span></span><br><span class="line"><span class="comment"> * Note that the element must exist and must match &#x27;score&#x27;.</span></span><br><span class="line"><span class="comment"> * This function does not update the score in the hash table side, the</span></span><br><span class="line"><span class="comment"> * caller should take care of it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function attempts to just update the node, in case after</span></span><br><span class="line"><span class="comment"> * the score update, the node would be exactly at the same position.</span></span><br><span class="line"><span class="comment"> * Otherwise the skiplist is modified by removing and re-adding a new</span></span><br><span class="line"><span class="comment"> * element, which is more costly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the updated element skiplist node pointer. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslUpdateScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> curscore, sds ele, <span class="keyword">double</span> newscore)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to seek to element to update to start: this is useful anyway,</span></span><br><span class="line"><span class="comment">     * we&#x27;ll have to update or remove it. */</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; curscore ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Jump to our element: note that this function assumes that the</span></span><br><span class="line"><span class="comment">     * element with the matching score exists. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    serverAssert(x &amp;&amp; curscore == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the node, after the score update, would be still exactly</span></span><br><span class="line"><span class="comment">     * at the same position, we can just update the score without</span></span><br><span class="line"><span class="comment">     * actually removing and re-inserting the element in the skiplist. */</span></span><br><span class="line">    <span class="keyword">if</span> ((x-&gt;backward == <span class="literal">NULL</span> || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;</span><br><span class="line">        (x-&gt;level[<span class="number">0</span>].forward == <span class="literal">NULL</span> || x-&gt;level[<span class="number">0</span>].forward-&gt;score &gt; newscore))</span><br><span class="line">    &#123;</span><br><span class="line">        x-&gt;score = newscore;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No way to reuse the old node: we need to remove and insert a new</span></span><br><span class="line"><span class="comment">     * one at a different place. */</span></span><br><span class="line">    zslDeleteNode(zsl, x, update);</span><br><span class="line">    zskiplistNode *newnode = zslInsert(zsl,newscore,x-&gt;ele);</span><br><span class="line">    <span class="comment">/* We reused the old node x-&gt;ele SDS string, free the node now</span></span><br><span class="line"><span class="comment">     * since zslInsert created a new one. */</span></span><br><span class="line">    x-&gt;ele = <span class="literal">NULL</span>;</span><br><span class="line">    zslFreeNode(x);</span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机层数算法</span></span><br><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Free a whole skiplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next;</span><br><span class="line"></span><br><span class="line">    zfree(zsl-&gt;header);</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslFreeNode(node);</span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(zsl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据rank（排位）来查找跳跃表中指定的节点</span></span><br><span class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></span><br><span class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7 vim个人配置</title>
    <url>/vim/vim-configuration/</url>
    <content><![CDATA[<p>因为最终想要安装YCM插件，而最新的YCM插件只支持 python3.6 和 vim8.1 以上的版本，所以需要更新系统自带的 python 和 vim（如果以安装最新的环境，则可忽略）。<br><a id="more"></a></p>
<p>全文最底下添加了vimrc配置的信息可自行下载。</p>
<h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><p>安装相关编译环境：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make</span><br></pre></td></tr></table></figure>
<p>下载 python 安装包，此处我下载的是 3.7.4 版本的 python，可自行选择最新的版本下载安装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mkdir ~/download</span><br><span class="line">cd ~/download</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz</span><br></pre></td></tr></table></figure>
<p>解压：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tar -vxzf Python-3.7.4.tgz</span><br></pre></td></tr></table></figure>
<p>编译安装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd Python-3.7.4</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/python3 --with-ssl --enable-shared --enable-optimizations</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>此处的添加 —enable-shared 参数是因为YCM插件需要。<br>安装完毕后，添加软链接：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line">ln -sf /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure>
<p>执行命令验证 python 版本：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">python --version</span><br><span class="line">Python 2.7.12</span><br><span class="line"></span><br><span class="line">python3 --version</span><br><span class="line">Python 3.7.4</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="安装vim8"><a href="#安装vim8" class="headerlink" title="安装vim8"></a>安装vim8</h2><p>下载vim：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd ~/download</span><br><span class="line">git clone https://github.com/vim/vim.git</span><br></pre></td></tr></table></figure>
<p>编译安装支持 python3 的 vim8：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd vim</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--with-features=huge \</span><br><span class="line">--enable-multibyte \</span><br><span class="line">--enable-rubyinterp=yes \</span><br><span class="line">--enable-python3interp=yes \</span><br><span class="line">--with-python-config-dir=/usr/local/python3/lib/python3.7/config-3.7m-x86_64-linux-gnu \</span><br><span class="line">--enable-perlinterp=yes \</span><br><span class="line">--enable-luainterp=yes \</span><br><span class="line">--enable-gui=gtk2 \</span><br><span class="line">--enable-cscope \</span><br><span class="line">--prefix=/usr/local/vim8</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>安装完毕后，添加软链接：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/local/vim8/bin/vim /usr/bin/vim # 覆盖旧版本的vim</span><br></pre></td></tr></table></figure>
<p>验证vim：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vim --version</span><br></pre></td></tr></table></figure>
<p>查看结果：<br><img src="/vim/vim-configuration/vim-version.png" alt="vim-version"></p>
<p>如果红框中 python3 前面显示 <code>+</code> ，则表示 vim 成功支持 python3。<br>至此以安装完毕python3 + vim8。<br>接下来对 vim 进行相关配置。</p>
<h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><h3 id="vim基础配置"><a href="#vim基础配置" class="headerlink" title="vim基础配置"></a>vim基础配置</h3><p>首先对 vim 进行一个基础配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">set number          &quot; 显示行号</span><br><span class="line">syntax on           &quot; 语法高亮</span><br><span class="line">set showcmd         &quot; 输入的命令显示出来，看的清楚些</span><br><span class="line">set cursorline      &quot; 当前行显示</span><br><span class="line">set autoindent      &quot; 自动缩进</span><br><span class="line">set cindent</span><br><span class="line">set tabstop=4       &quot; tab缩进4个空格</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set expandtab</span><br><span class="line">set incsearch       &quot; 开启实时搜索功能</span><br><span class="line">set ignorecase      &quot; 搜索时大小写不敏感</span><br><span class="line">set hlsearch        &quot; 高亮显示搜索结果</span><br><span class="line">set foldenable      &quot; 允许折叠</span><br><span class="line">set foldmethod=manual   &quot; 手动折叠</span><br><span class="line">set nocompatible    &quot; 去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限</span><br><span class="line">set clipboard+=unnamed  &quot; 共享剪贴板</span><br><span class="line">set autowrite       &quot; 自动保存</span><br><span class="line">set confirm         &quot; 在处理未保存或只读文件的时候，弹出确认</span><br><span class="line">set ruler           &quot; 打开状态栏标尺</span><br><span class="line">set langmenu=zh_CN.UTF-8    &quot; 语言设置</span><br><span class="line">set helplang=cn</span><br><span class="line">set laststatus=2    &quot; 总是显示状态行</span><br><span class="line">set linespace=0     &quot; 字符间插入的像素行数目</span><br><span class="line">set backspace=2     &quot; 使回格键（backspace）正常处理indent, eol, start等</span><br><span class="line">set showmatch       &quot; 高亮显示匹配的括号</span><br><span class="line">set scrolloff=3     &quot; 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line">set completeopt=menu</span><br><span class="line">&quot; 相关颜色替换</span><br><span class="line">hi Search term=standout cterm=bold ctermfg=7 ctermbg=1</span><br><span class="line">hi SpellBad term=reverse ctermfg=15 ctermbg=9 guifg=White guibg=Red</span><br><span class="line">let mapleader=&#x27;,&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="vim插件安装"><a href="#vim插件安装" class="headerlink" title="vim插件安装"></a>vim插件安装</h3><h4 id="安装vim插件管理器-vim-plug"><a href="#安装vim插件管理器-vim-plug" class="headerlink" title="安装vim插件管理器(vim-plug)"></a>安装vim插件管理器(vim-plug)</h4><p>因为需要安装的 vim 插件很多，所以需要有一个管理工具来对这些插件进行统一管理。目前主流使用的是 <a href="https://github.com/junegunn/vim-plug">vim-plug</a> 插件管理器，该插件能够异步并行进行快速安装、更新和卸载插件。</p>
<p>下载 plug.vim 文件到 <code>~/.vim/autoload/</code> 文件夹中：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>
<p>执行命令的时候，发现 raw.githubusercontent.com 地址可能访问不了，需要配置 hosts 才能进行访问，配置的方法网上很多，可自行查询解决。<br>下载完成后，在 vim 的配置文件( <code>~/.vimrc</code> )中添加以下代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot; Specify a directory for plugins</span><br><span class="line">&quot; - For Neovim: stdpath(&#x27;data&#x27;) . &#x27;/plugged&#x27;</span><br><span class="line">&quot; - Avoid using standard Vim directory names like &#x27;plugin&#x27;</span><br><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line">&quot; 以下添加需要安装的插件</span><br><span class="line">&quot; 可在github上查找需要安装的插件，以 Plug &#x27;xxx/xxx&#x27; 的形式来添加，如下：</span><br><span class="line"></span><br><span class="line">&quot; YCM插件</span><br><span class="line">Plug &#x27;Valloric/YouCompleteMe&#x27;</span><br><span class="line"></span><br><span class="line">&quot; Initialize plugin system</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure>
<p>配置完成后，打开vim，输入<code>:PlugInstall</code>进行安装。</p>
<p>vim-plug操作命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PlugInstall [name …] [#threads]</td>
<td>安装插件</td>
</tr>
<tr>
<td>PlugUpdate [name …] [#threads]</td>
<td>更新插件</td>
</tr>
<tr>
<td>PlugClean[!]</td>
<td>卸载插件</td>
</tr>
<tr>
<td>PlugUpgrade</td>
<td>更新vim-plug</td>
</tr>
<tr>
<td>PlugStatus</td>
<td>查看插件状态</td>
</tr>
<tr>
<td>PlugDiff</td>
<td>审查插件</td>
</tr>
<tr>
<td>PlugSnapshot[!] [output path]</td>
<td>生成用于恢复插件当前快照的脚本</td>
</tr>
</tbody>
</table>
</div>
<p>下面安装vim实用的插件。</p>
<hr>
<h4 id="NERDTree文件树目录"><a href="#NERDTree文件树目录" class="headerlink" title="NERDTree文件树目录"></a>NERDTree文件树目录</h4><p><a href="https://github.com/preservim/nerdtree">NERDTree</a>是一款可以提供树形目录的插件，方便浏览目录结构和进行文件跳转等。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Plug &#x27;preservim/nerdtree&#x27;</span><br></pre></td></tr></table></figure>
<p>相关配置如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot; nerdtree</span><br><span class="line">autocmd vimenter * NERDTree  &quot;自动开启Nerdtree</span><br><span class="line">&quot; 关闭所有文本窗口时自动退出vim,否则需要两次退出才可</span><br><span class="line">autocmd BufEnter * if 0 == len(filter(range(1, winnr(&#x27;$&#x27;)), &#x27;empty(getbufvar(winbufnr(v:val), &quot;&amp;bt&quot;))&#x27;)) | qa! | endif</span><br><span class="line">let NERDTreeShowHidden=1    &quot; 是否显示隐藏文件</span><br><span class="line">let NERDTreeIgnore=[&#x27;\.pyc&#x27;,&#x27;\~$&#x27;,&#x27;\.swp&#x27;]  &quot; 忽略文件的显示</span><br><span class="line"></span><br><span class="line">&quot; 设置NerdTree 按f2打开或关闭NERDTree</span><br><span class="line">map &lt;F2&gt; :NERDTreeMirror&lt;CR&gt;</span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<h4 id="nerdtree-git-plugin目录树git文件状态"><a href="#nerdtree-git-plugin目录树git文件状态" class="headerlink" title="nerdtree-git-plugin目录树git文件状态"></a>nerdtree-git-plugin目录树git文件状态</h4><p><a href="https://github.com/Xuyuanp/nerdtree-git-plugin">nerdtree-git-plugin</a>能显示git管理的项目文件的变更状态。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Plug &#x27;Xuyuanp/nerdtree-git-plugin&#x27;</span><br></pre></td></tr></table></figure>
<p>相关配置如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let g:NERDTreeIndicatorMapCustom = &#123;</span><br><span class="line">            \ &quot;Modified&quot;  : &quot;✹&quot;,</span><br><span class="line">            \ &quot;Staged&quot;    : &quot;✚&quot;,</span><br><span class="line">            \ &quot;Untracked&quot; : &quot;✭&quot;,</span><br><span class="line">            \ &quot;Renamed&quot;   : &quot;➜&quot;,</span><br><span class="line">            \ &quot;Unmerged&quot;  : &quot;═&quot;,</span><br><span class="line">            \ &quot;Deleted&quot;   : &quot;✖&quot;,</span><br><span class="line">            \ &quot;Dirty&quot;     : &quot;✗&quot;,</span><br><span class="line">            \ &quot;Clean&quot;     : &quot;✔︎&quot;,</span><br><span class="line">            \ &#x27;Ignored&#x27;   : &#x27;☒&#x27;,</span><br><span class="line">            \ &quot;Unknown&quot;   : &quot;?&quot;</span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure>
<h4 id="tagbar函数列表"><a href="#tagbar函数列表" class="headerlink" title="tagbar函数列表"></a>tagbar函数列表</h4><p><a href="https://github.com/preservim/tagbar">tagbar</a>能显示出所写代码的函数、变量、类等等。<br>安装 taglist 之前，需要先安装 ctags。<br>ctags 的功能：扫描指定的源文件，找出其中所包含的语法元素，并将找到的相关内容记录下来。<br>安装ctags：</p>
<blockquote>
<p>到 <a href="http://ctags.sourceforge.net/">http://ctags.sourceforge.net/</a> 下载最新的ctags源码(当前最新版本为 ctags-5.8.tar.gz)<br>解压并安装：<br>tar vxzf ctags-5.8.tar.gz<br>cd ctags-5.8<br>./configure &amp;&amp; make &amp;&amp; make install</p>
</blockquote>
<p>ctags的使用方法可以自行百度查询。</p>
<p>接下来安装tagbar：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Plug &#x27;preservim/tagbar&#x27;</span><br></pre></td></tr></table></figure>
<p>相关配置如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot; [tagbar]</span><br><span class="line">&quot; 设置tagbar使用的ctags的插件,必须要设置对</span><br><span class="line">let g:tagbar_ctags_bin=&#x27;/usr/bin/ctags&#x27;</span><br><span class="line">&quot; 设置tagbar的窗口宽度</span><br><span class="line">let g:tagbar_width=35</span><br><span class="line">&quot; 设置tagbar的窗口显示的位置,默认右边</span><br><span class="line">let g:tagbar_right=1</span><br><span class="line">&quot; 打开文件自动 打开tagbar</span><br><span class="line">&quot; autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()</span><br><span class="line">&quot; 这是tagbar一打开，光标即在tagbar页面内，默认在vim打开的文件内</span><br><span class="line">let g:tagbar_autofocus = 1</span><br><span class="line">&quot;设置标签不排序，默认排序</span><br><span class="line">let g:tagbar_sort = 0</span><br><span class="line">&quot; 映射tagbar的快捷键</span><br><span class="line">nnoremap &lt;silent&gt; &lt;F3&gt; :TagbarToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<h4 id="vim-airline状态栏美化"><a href="#vim-airline状态栏美化" class="headerlink" title="vim-airline状态栏美化"></a>vim-airline状态栏美化</h4><p><a href="https://github.com/vim-airline/vim-airline">vim-airline</a> 和 <a href="https://github.com/vim-airline/vim-airline-themes">vim-airline-themes</a> 搭配能将vim的底部状态增强/美化。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Plug &#x27;vim-airline/vim-airline&#x27;</span><br><span class="line">Plug &#x27;vim-airline/vim-airline-themes&#x27;</span><br></pre></td></tr></table></figure>
<p>相关配置如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">set t_Co=256      &quot;在windows中用xshell连接打开vim可以显示色彩</span><br><span class="line">let g:airline#extensions#tabline#enabled = 1   &quot; 是否打开tabline</span><br><span class="line">&quot;这个是安装字体后 必须设置此项</span><br><span class="line">let g:airline_powerline_fonts = 1</span><br><span class="line">set laststatus=2  &quot;永远显示状态栏</span><br><span class="line">let g:airline_theme=&#x27;bubblegum&#x27; &quot;选择主题</span><br><span class="line">let g:airline#extensions#tabline#enabled=1    &quot;Smarter tab line:显示窗口tab和buffer</span><br><span class="line">&quot;let g:airline#extensions#tabline#left_sep = &#x27; &#x27;  &quot;separater</span><br><span class="line">&quot;let g:airline#extensions#tabline#left_alt_sep = &#x27;|&#x27;  &quot;separater</span><br><span class="line">&quot;let g:airline#extensions#tabline#formatter = &#x27;default&#x27;  &quot;formater</span><br><span class="line">let g:airline_left_sep = &#x27;▶&#x27;</span><br><span class="line">let g:airline_left_alt_sep = &#x27;❯&#x27;</span><br><span class="line">let g:airline_right_sep = &#x27;◀&#x27;</span><br><span class="line">let g:airline_right_alt_sep = &#x27;❮&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="nerdcommenter批量注释"><a href="#nerdcommenter批量注释" class="headerlink" title="nerdcommenter批量注释"></a>nerdcommenter批量注释</h4><p><a href="https://github.com/preservim/nerdcommenter">nerdcommenter</a>是一款对代码进行批量注释的插件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Plug &#x27;preservim/nerdcommenter&#x27;</span><br></pre></td></tr></table></figure>
<p>相关配置如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let g:NERDSpaceDelims = 1   &quot; 注释中间加一个空格  </span><br><span class="line">let g:NERDDefaultAlign = &#x27;left&#x27; &quot; 多行注释向左对齐</span><br></pre></td></tr></table></figure>
<p>使用方法：<br>在 Normal 和 Visual 模式下：</p>
<ul>
<li>\<leader>ca在可选的注释方式之间切换，比如C/C++ 的块注释/<em> </em>/和行注释//  </leader></li>
<li>\<leader>cc注释当前行</leader></li>
<li>\<leader>c\<space> 切换注释/非注释状态</space></leader></li>
<li>\<leader>cs 以”性感”的方式注释</leader></li>
<li>\<leader>cA 在当前行尾添加注释符，并进入Insert模式</leader></li>
<li>\<leader>cu 取消注释</leader></li>
<li>\<leader>c$ 从光标开始到行尾注释  ，这个要说说因为c$也是从光标到行尾的快捷键，这个按过逗号（，）要快一点按c$</leader></li>
<li>2\<leader>cc 光标以下count行添加注释</leader></li>
<li>2\<leader>cu 光标以下count行取消注释</leader></li>
<li>2\<leader>cm:光标以下count行添加块注释(2,cm)</leader></li>
<li>Normal模式下，几乎所有命令前面都可以指定行数</li>
<li>Visual模式下执行命令，会对选中的特定区块进行注释/反注释</li>
</ul>
<h4 id="golang相关插件"><a href="#golang相关插件" class="headerlink" title="golang相关插件"></a>golang相关插件</h4><p><a href="https://github.com/fatih/vim-go">vim-go</a> 是一款go代码高亮和语法检查的插件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Plug &#x27;fatih/vim-go&#x27;, &#123; &#x27;do&#x27;: &#x27;:GoUpdateBinaries&#x27; &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/nsf/gocode">gocode</a> 是一款go的代码提示插件。<br>首先要正确设置GOROOT、GOPATH、GOBIN等几个环境变量。<br>下载gocode：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mkdir -p $GOPATH/src/github.com/nsf</span><br><span class="line"></span><br><span class="line">cd $GOPATH/src/github.com/nsf</span><br><span class="line"></span><br><span class="line">git clone https://github.com/nsf/gocode.git</span><br></pre></td></tr></table></figure>
<p>编译安装gocode：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd gocode</span><br><span class="line"></span><br><span class="line">go build</span><br><span class="line"></span><br><span class="line">go install</span><br></pre></td></tr></table></figure>
<p>编译完成后生成一个 gocode 的可执行文件，并被放到 $GOBIN 目录下。<br>接下来安装vim-gocode插件:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Plug &#x27;nsf/gocode&#x27;, &#123; &#x27;rtp&#x27;: &#x27;vim&#x27;, &#x27;do&#x27;: &#x27;~/.vim/plugged/gocode/vim/symlink.sh&#x27; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="YouCompleteMe代码补全插件"><a href="#YouCompleteMe代码补全插件" class="headerlink" title="YouCompleteMe代码补全插件"></a>YouCompleteMe代码补全插件</h4><p><a href="https://github.com/ycm-core/YouCompleteMe">YouCompleteMe</a> 是一款非常强大的异步代码自动补全，支持非常多的编程语言，如：C/C++, Golang, Python, Rust, Java等。</p>
<p>准备依赖环境：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">yum install cmake</span><br><span class="line"></span><br><span class="line">yum install python-devel libffi-devel graphviz-devel elfutils-libelf-devel readline-devel libedit-devel libxml2-devel protobuf-devel gtext-devel doxygen swig</span><br></pre></td></tr></table></figure>
<p>下载安装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/ycm-core/YouCompleteMe.git ~/.vim/plugged/YouCompleteMe</span><br><span class="line"></span><br><span class="line">cd ~/.vim/plugged/YouCompleteMe</span><br><span class="line"></span><br><span class="line">python3 install.py --all</span><br></pre></td></tr></table></figure>
<p>相关配置如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let g:ycm_confirm_extra_conf=0      &quot; 关闭加载.ycm_extra_conf.py提示</span><br><span class="line">let g:ycm_complete_in_comments = 1  &quot;在注释输入中也能补全</span><br><span class="line">let g:ycm_complete_in_strings = 1   &quot;在字符串输入中也能补全</span><br><span class="line">let g:ycm_collect_identifiers_from_tags_files=1                 &quot; 开启 YCM 基于标签引擎</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 1   &quot;注释和字符串中的文字也会被收入补全</span><br><span class="line">let g:ycm_seed_identifiers_with_syntax=1   &quot;语言关键字补全, 不过python关键字都很短，所以，需要的自己打开</span><br><span class="line">let g:ycm_min_num_of_chars_for_completion=2                     &quot; 从第2个键入字符就开始罗列匹配项</span><br><span class="line">&quot; 引入，可以补全系统，以及python的第三方包 针对新老版本YCM做了兼容</span><br><span class="line">if !empty(glob(&quot;~/..vim/plugged/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py&quot;))</span><br><span class="line">    let g:ycm_global_ycm_extra_conf = &quot;~/..vim/plugged/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py&quot;</span><br><span class="line">endif</span><br><span class="line">&quot;mapping</span><br><span class="line">nmap &lt;leader&gt;gd :YcmDiags&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;gl :YcmCompleter GoToDeclaration&lt;CR&gt;           &quot; 跳转到申明处</span><br><span class="line">nnoremap &lt;leader&gt;gf :YcmCompleter GoToDefinition&lt;CR&gt;            &quot; 跳转到定义处</span><br><span class="line">nnoremap &lt;leader&gt;gg :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">&quot; 直接触发自动补全</span><br><span class="line">let g:ycm_key_invoke_completion = &#x27;&lt;C-Space&gt;&#x27;</span><br><span class="line">&quot; 黑名单,不启用</span><br><span class="line">      \ &#x27;tagbar&#x27; : 1,</span><br><span class="line">      \ &#x27;gitcommit&#x27; : 1,</span><br><span class="line">      \&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>此处还没有结束，未来如果碰到好用的插件，会继续更新。。。<br>以上所有的配置我将它上传到了github上，有需要的可自行下载 <a href="https://github.com/Grizzly1127/vim-config">vimrc</a>。</p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-有序集合对象zset</title>
    <url>/Redis/2-object/redis-parse-zset/</url>
    <content><![CDATA[<p>源码位置：t_zset.c/server.h</p>
<p>zset对象底层编码方式有两种，<code>ziplist</code>或<code>skiplist</code>。<br>使用ziplist编码需要同时满足以下两个条件：  </p>
<ul>
<li>有序集合对象中所有元素的大小都小于64字节。（可通过redis.conf配置：zset_max_ziplist_value）</li>
<li>有序集合对象保存的元素个数不超过128个。（可通过redis.conf配置：zset_max_ziplist_entries）</li>
</ul>
<a id="more"></a>
<p>ziplist的结构如下：<br><img src="https://i.loli.net/2020/10/29/LZnqe3lM8a5zS6R.png" alt="t_zset_ziplist.png"><br>如上图，集合的元素由两个紧挨着的节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。压缩列表内的元素按照分值从小到大排序，分值小的靠近表头，分值大的靠近表尾。  </p>
<p>zset编码底层实际上是由skiplist和dict构成的：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p>为什么会使用两种数据结构呢？其实，使用单一的数据结构也是可以实现有序集合对象的，比如单独使用字典，查找时间复杂度为O(1)，因为字典是无序的，所以当执行范围型操作时，首先要对所有元素进行排序，这里就会增加时间复杂度和空间复杂度了。当单独使用跳跃表时，查找的时间复杂度将会是O(logN)。所以，将两者的优势结合，将会很大的提高性能。另外，两种数据结构都会通过指针来共享相同的元素和分值，所以不会对内存造成不必要的浪费。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZCARD</td>
<td>返回key的有序集元素个数</td>
<td>O(1)</td>
</tr>
<tr>
<td>ZCOUNT</td>
<td>返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员</td>
<td>O(log(N))</td>
</tr>
<tr>
<td>ZINCRBY</td>
<td>为有序集key的成员member的score值加上增量increment</td>
<td>O(log(N))</td>
</tr>
<tr>
<td>ZINTERSTORE</td>
<td>计算给定的numkeys个有序集合的交集，并且把结果放到destination中</td>
<td>O(N<em>K)+O(M</em>log(M))，最坏的情况，N是最小的输入排序集，K是输入排序集的数量，M是结果排序集中的元素的数量</td>
</tr>
<tr>
<td>ZLEXCOUNT</td>
<td>用于计算有序集合中指定成员之间的成员数量</td>
<td>O(log(N))</td>
</tr>
<tr>
<td>ZPOPMAX</td>
<td>删除并返回有序集合key中的最多count个具有最高得分的成员</td>
<td>O(log(N)*M)</td>
</tr>
<tr>
<td>ZPOPMIN</td>
<td>删除并返回有序集合key中的最多count个具有最低得分的成员</td>
<td>O(log(N)*M)</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>返回存储在有序集合key中的指定范围的元素</td>
<td>O(log(N)+M)</td>
</tr>
<tr>
<td>ZRANGEBYLEX</td>
<td>返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同</td>
<td>O(log(N)+M)</td>
</tr>
<tr>
<td>ZREVRANGEBYLEX</td>
<td>返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同</td>
<td>O(log(N)+M)</td>
</tr>
<tr>
<td>ZRANGEBYSCORE</td>
<td>返回指定分数范围的元素列表</td>
<td>O(log(N)+M)</td>
</tr>
<tr>
<td>ZRANK</td>
<td>返回有序集key中成员member的排名</td>
<td>O(log(N))</td>
</tr>
<tr>
<td>ZREM</td>
<td>在key集合中移除指定的元素</td>
<td>O(M*log(N))</td>
</tr>
<tr>
<td>ZREMRANGEBYLEX</td>
<td>删除名称按字典由低到高排序成员之间所有成员</td>
<td>O(log(N)+M)</td>
</tr>
<tr>
<td>ZREMRANGEBYRANK</td>
<td>移除有序集key中，指定排名(rank)区间内的所有成员</td>
<td>O(log(N)+M)</td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE</td>
<td>移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员</td>
<td>O(log(N)+M)</td>
</tr>
<tr>
<td>ZREVRANGE</td>
<td>返回有序集key中，指定区间内的成员</td>
<td>O(log(N)+M)</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE</td>
<td>返回有序集合中指定分数区间内的成员，分数由高到低排序</td>
<td>O(log(N)+M)</td>
</tr>
<tr>
<td>ZREVRANK</td>
<td>返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列</td>
<td>O(log(N))</td>
</tr>
<tr>
<td>ZSCORE</td>
<td>返回有序集key中，成员member的score值</td>
<td>O(1)</td>
</tr>
<tr>
<td>ZUNIONSTORE</td>
<td>计算给定的numkeys个有序集合的并集，并且把结果放到destination中</td>
<td>O(N)+O(M log(M))</td>
</tr>
<tr>
<td>ZSCAN</td>
<td>用于迭代集合类型中的集合成员</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcardCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcountCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincrbyCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zinterstoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlexcountCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zpopmaxCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zpopminCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangeCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebylexCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebylexCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebyscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrankCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebylexCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyrankCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangeCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebyscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrankCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zunionstoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscanCommand</span><span class="params">(client *c)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr>
<p>添加命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数含义：  </span></span><br><span class="line"><span class="comment">* XX: 仅仅更新存在的成员，不添加新成员。</span></span><br><span class="line"><span class="comment">* NX: 不更新存在的成员。只添加新成员。</span></span><br><span class="line"><span class="comment">* CH: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 changed 的意思)。</span></span><br><span class="line"><span class="comment">*     更改的元素是新添加的成员，已经存在的成员更新分数。 所以在命令中指定的成员有相同的分数将不</span></span><br><span class="line"><span class="comment">*     被计算在内。注：在通常情况下，ZADD返回值只计算新添加成员的数量。</span></span><br><span class="line"><span class="comment">* INCR: 当ZADD指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作。 */</span></span><br><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure>
<p>代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    zaddGenericCommand(c,ZADD_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincrbyCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    zaddGenericCommand(c,ZADD_INCR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nanerr = <span class="string">&quot;resulting score is not a number (NaN)&quot;</span>;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">0</span>, *scores = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> j, elements;</span><br><span class="line">    <span class="keyword">int</span> scoreidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> added = <span class="number">0</span>;      <span class="comment">/* Number of new elements added. */</span></span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>;    <span class="comment">/* Number of elements with updated score. */</span></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;  <span class="comment">/* Number of elements processed, may remain zero with</span></span><br><span class="line"><span class="comment">                           options like XX. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析命令参数 */</span></span><br><span class="line">    scoreidx = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class="line">        <span class="keyword">char</span> *opt = c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;nx&quot;</span>)) flags |= ZADD_NX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;xx&quot;</span>)) flags |= ZADD_XX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;ch&quot;</span>)) flags |= ZADD_CH;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;incr&quot;</span>)) flags |= ZADD_INCR;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        scoreidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> incr = (flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nx = (flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx = (flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch = (flags &amp; ZADD_CH) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断参数合法性（元素-分值对） */</span></span><br><span class="line">    elements = c-&gt;argc-scoreidx;</span><br><span class="line">    <span class="keyword">if</span> (elements % <span class="number">2</span> || !elements) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查不兼容的选项 */</span></span><br><span class="line">    <span class="keyword">if</span> (nx &amp;&amp; xx) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;XX and NX options at the same time are not compatible&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (incr &amp;&amp; elements &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;INCR option supports a single increment-element pair&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查分数参数是否合格 */</span></span><br><span class="line">    scores = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*elements);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class="number">2</span>],&amp;scores[j],<span class="literal">NULL</span>)</span><br><span class="line">            != C_OK) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* db中查找集合 */</span></span><br><span class="line">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    <span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) <span class="keyword">goto</span> reply_to_client; <span class="comment">/* 没有找到key，并且设置了 XX 参数，则什么都不做 */</span></span><br><span class="line">        <span class="comment">// 如果db中没有key，则创建zset对象</span></span><br><span class="line">        <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">        &#123;</span><br><span class="line">            zobj = createZsetObject();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zobj = createZsetZiplistObject();</span><br><span class="line">        &#125;</span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zobj-&gt;type != OBJ_ZSET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> newscore;</span><br><span class="line">        score = scores[j];</span><br><span class="line">        <span class="keyword">int</span> retflags = flags;</span><br><span class="line"></span><br><span class="line">        ele = c-&gt;argv[scoreidx+<span class="number">1</span>+j*<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        <span class="keyword">int</span> retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,nanerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_ADDED) added++;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class="line">        <span class="keyword">if</span> (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class="line">        score = newscore;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (added+updated);</span><br><span class="line"></span><br><span class="line">reply_to_client:</span><br><span class="line">    <span class="keyword">if</span> (incr) &#123; <span class="comment">/* ZINCRBY or INCR option. */</span></span><br><span class="line">        <span class="keyword">if</span> (processed)</span><br><span class="line">            addReplyDouble(c,score);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyNull(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ZADD. */</span></span><br><span class="line">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    <span class="keyword">if</span> (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class="line">            incr ? <span class="string">&quot;zincr&quot;</span> : <span class="string">&quot;zadd&quot;</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>其他命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ZCARD key</span><br><span class="line">ZCOUNT key min max</span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX]</span><br><span class="line">ZLEXCOUNT key min max</span><br><span class="line">ZPOPMAX key [count]</span><br><span class="line">ZPOPMIN key [count]</span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">ZRANK key member</span><br><span class="line">ZREM key member [member ...]</span><br><span class="line">ZREMRANGEBYLEX key min max</span><br><span class="line">ZREMRANGEBYRANK key start stop</span><br><span class="line">ZREMRANGEBYSCORE key min max</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">ZREVRANK key member</span><br><span class="line">ZSCORE key member</span><br><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX]</span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>2-object</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码-压缩列表ziplist</title>
    <url>/Redis/1-data-structure/redis-parse-ziplist/</url>
    <content><![CDATA[<p>源码位置：ziplist.c/ziplist.h</p>
<p>ziplist在redis中主要用于Hash与List数据结构的底层实现之一，ziplist没有定义专门的结构体，其在内存块中的表示如下图所示：<br><a id="more"></a><br><strong>ziplist结构：</strong><br><img src="https://i.loli.net/2020/10/29/N3HWQIg91pRl4Ok.png" alt="ziplist.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint_32t</td>
<td>4B</td>
<td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend的位置时使用</td>
</tr>
<tr>
<td>zltail</td>
<td>uint_32t</td>
<td>4B</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint_16t</td>
<td>2B</td>
<td>记录了压缩列表包含的节点数量： 当这个属性的值小于UINT16_ MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td>entry</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint_8t</td>
<td>1B</td>
<td>0xFF（255），用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>entry结构：</strong><br><img src="https://i.loli.net/2020/10/29/AB5S3XYTweykGzI.png" alt="ziplist_entry.png"><br><strong>prevrawlen：</strong> 前置节点的长度</p>
<ol>
<li>如果长度小于254个字节，则使用1字节（uint8_t）来存储prevrawlen。</li>
<li>如果长度大于或等于254字节，则使用5字节(uint32_t)来存储prevrawlen。  </li>
</ol>
<p><strong>len/encoding：</strong> 当前节点的长度（编码类型）<br><img src="https://i.loli.net/2020/10/29/7wuK5qsF9LXiNDV.png" alt="ziplist_encoding.png"></p>
<p><strong>data：</strong> 数据  </p>
<p>实际上，源码里有定义zlentry的结构体，但是这个结构体并不是实际上存储的节点结构，它仅做中间结构操作使用。  </p>
<p><strong>时间复杂度：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>ziplistNew</td>
<td>创建跳跃表</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistInsert</td>
<td>插入节点</td>
<td>平均O(N)（耗时在连锁更新）</td>
</tr>
<tr>
<td>ziplistDelete</td>
<td>删除节点</td>
<td>平均O(N)（耗时在连锁更新）</td>
</tr>
<tr>
<td>ziplistFind</td>
<td>查找节点</td>
<td>平均O(N)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ziplist.h:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ziplist.c:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_END 255         <span class="comment">/* Special &quot;end of ziplist&quot; entry. */</span> <span class="comment">// 列表末尾值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_BIG_PREVLEN 254 <span class="comment">/* Max number of bytes of the previous entry, for</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               the &quot;prevlen&quot; field prefixing each entry, to be</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               represented with just a single byte. Otherwise</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               it is represented as FF AA BB CC DD, where</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               AA BB CC DD are a 4 bytes unsigned integer</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               representing the previous entry len. */</span> <span class="comment">// 列表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Different encoding/length possibilities */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_MASK 0xc0           <span class="comment">// 11000000 : 如果encoding小于ZIP_STR_MASK，则为字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_MASK 0x30           <span class="comment">// 00110000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)        <span class="comment">// 00aaaaaa : 高位2个bit00表示len只有一个字节，后面6个bit表示数据长度值，最高可以表示63字节（2^6-1）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)        <span class="comment">// 01aaaaaa aaaaaaaa : 高位2个bit01表示len有两个字节，剩余的14个bit表示数据长度值，最高可以表示16383字节（2^14-1）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)        <span class="comment">// 10______ aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa : 高位2个bit10表示len有五个字节，接下来的6个bit不使用，剩余的bit表示数据长度值，最高可以表示16383字节（2^14-1）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)   <span class="comment">// 11000000 ：int16_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)   <span class="comment">// 11010000 ：int32_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)   <span class="comment">// 11100000 ：int64_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)   <span class="comment">// 11110000 ：24位有符号整数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_8B 0xfe             <span class="comment">// 11111110 ：8位有符号整数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 bit integer immediate encoding |1111xxxx| with xxxx between</span></span><br><span class="line"><span class="comment"> * 0001 and 1101. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MASK 0x0f   <span class="comment">/* Mask to extract the 4 bits value. To add</span></span></span><br><span class="line"><span class="meta"><span class="comment">                                   one is needed to reconstruct the value. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MIN 0xf1    <span class="comment">/* 11110001 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MAX 0xfd    <span class="comment">/* 11111101 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT24_MAX 0x7fffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT24_MIN (-INT24_MAX - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro to determine if the entry is a string. String entries never start</span></span><br><span class="line"><span class="comment"> * with &quot;11&quot; as most significant bits of the first byte. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK) <span class="comment">// 判断是不是字符串</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Utility macros.*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return total bytes a ziplist is composed of. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the offset of the last item inside the ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the length of a ziplist, or UINT16_MAX if the length cannot be</span></span><br><span class="line"><span class="comment"> * determined without scanning the whole ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The size of a ziplist header: two 32 bit integers for the total</span></span><br><span class="line"><span class="comment"> * bytes count and last item offset. One 16 bit integer for the number</span></span><br><span class="line"><span class="comment"> * of items field. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the &quot;end of ziplist&quot; entry. Just one byte. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the pointer to the first entry of a ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the pointer to the last entry of a ziplist, using the</span></span><br><span class="line"><span class="comment"> * last entry offset inside the ziplist header. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the pointer to the last byte of a ziplist, which is, the</span></span><br><span class="line"><span class="comment"> * end of ziplist FF entry. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Increment the number of items field in the ziplist header. Note that this</span></span><br><span class="line"><span class="comment"> * macro should never overflow the unsigned 16 bit integer, since entries are</span></span><br><span class="line"><span class="comment"> * always pushed one at a time. When UINT16_MAX is reached we want the count</span></span><br><span class="line"><span class="comment"> * to stay there to signal that a full scan is needed to get the number of</span></span><br><span class="line"><span class="comment"> * items inside the ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_INCR_LENGTH(zl,incr) &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> (ZIPLIST_LENGTH(zl) &lt; UINT16_MAX) \</span><br><span class="line">        ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩列表的节点</span></span><br><span class="line"><span class="comment">/* We use this function to receive information about a ziplist entry.</span></span><br><span class="line"><span class="comment"> * Note that this is not how the data is actually encoded, is just what we</span></span><br><span class="line"><span class="comment"> * get filled by a function in order to operate more easily. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码 prevrawlen 所需的字节大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="comment">// 前置节点的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="comment">// 编码 len 所需的字节大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="comment">// 当前节点的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="comment">// 当前节点 header 的大小，prevrawlensize + lensize</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="comment">// 类型编码:3种字符编码+6种整数编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_ZERO(zle) &#123; \</span></span><br><span class="line">    (zle)-&gt;prevrawlensize = (zle)-&gt;prevrawlen = <span class="number">0</span>; \</span><br><span class="line">    (zle)-&gt;lensize = (zle)-&gt;len = (zle)-&gt;headersize = <span class="number">0</span>; \</span><br><span class="line">    (zle)-&gt;encoding = <span class="number">0</span>; \</span><br><span class="line">    (zle)-&gt;p = <span class="literal">NULL</span>; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extract the encoding from the byte pointed by &#x27;ptr&#x27; and set it into</span></span><br><span class="line"><span class="comment"> * &#x27;encoding&#x27; field of the zlentry structure. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_ENTRY_ENCODING(ptr, encoding) do &#123;  \</span></span><br><span class="line">    (encoding) = (ptr[<span class="number">0</span>]); \</span><br><span class="line">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistMerge</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> **first, <span class="keyword">unsigned</span> <span class="keyword">char</span> **second)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistIndex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **sval, <span class="keyword">unsigned</span> <span class="keyword">int</span> *slen, <span class="keyword">long</span> <span class="keyword">long</span> *lval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDeleteRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistCompare</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistFind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">unsigned</span> <span class="keyword">int</span> skip)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ziplistBlobLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ziplistRepr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr>
<p><strong>创建：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建新的压缩列表</span></span><br><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes); <span class="comment">// 大端模式转小端模式</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新分配ziplist内存大小</span></span><br><span class="line"><span class="comment">/* Resize the ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    zl = zrealloc(zl,len);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(len);</span><br><span class="line">    zl[len<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert an entry at &quot;p&quot;. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert item at &quot;p&quot;. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen; <span class="comment">// reqlen用于计算存储当前节点需要的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value</span></span><br><span class="line"><span class="comment">                                    that is easy to see if for some reason</span></span><br><span class="line"><span class="comment">                                    we use it uninitialized. */</span></span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></span><br><span class="line">    <span class="comment">// 以下步骤是为了获取前一个节点的长度</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if the entry can be encoded */</span></span><br><span class="line">    <span class="comment">// 尝试进行整数字符串编码</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is set to the appropriate integer encoding */</span></span><br><span class="line">        reqlen = zipIntSize(encoding); <span class="comment">// 获取数据存储需要的字节数（data部分）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is untouched, however zipStoreEntryEncoding will use the</span></span><br><span class="line"><span class="comment">         * string length to figure out how to encode it. */</span></span><br><span class="line">        reqlen = slen; <span class="comment">// 字符串长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We need space for both the length of the previous entry and</span></span><br><span class="line"><span class="comment">     * the length of the payload. */</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen); <span class="comment">// 存储前节点长度需要的字节数</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen); <span class="comment">// 存储当前节点encoding需要的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the insert position is not equal to the tail, we need to</span></span><br><span class="line"><span class="comment">     * make sure that the next entry can hold this entry&#x27;s length in</span></span><br><span class="line"><span class="comment">     * its prevlen field. */</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>; <span class="comment">// 看是否会引起后面节点的长度变化，如果有变化，需要进行联锁更新</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff); <span class="comment">// 重新分配ziplist的大小，为插入节点做准备，给新的尾部节点赋值FF，更新头部节点zlbyte的值</span></span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class="line">    <span class="comment">// 更新zltail信息</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff); <span class="comment">// 数据往后移动，并根据nextdiff进行调整</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Encode this entry&#x27;s raw length in the next entry. */</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update offset for tail */</span></span><br><span class="line">        <span class="comment">// 更新zltail的值</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">         * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */</span></span><br><span class="line">        zipEntry(p+reqlen, &amp;tail); <span class="comment">// 构造节点</span></span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">// 尾结点的值也需要根据nextdiff进行微调</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This element will be the new tail. */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果后面节点有长度变化，需要更新之后的所有节点的变化</span></span><br><span class="line">        offset = p-zl; <span class="comment">// 记录新节点的偏移量</span></span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen); <span class="comment">// 连锁更新</span></span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the entry */</span></span><br><span class="line">    <span class="comment">// 编辑新节点的值</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编码encoding字段相关：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是不是整数字符串，如果是，确定其编码类型</span></span><br><span class="line"><span class="comment">/* Check if string pointed to by &#x27;entry&#x27; can be encoded as an integer.</span></span><br><span class="line"><span class="comment"> * Stores the integer value in &#x27;v&#x27; and its encoding in &#x27;encoding&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipTryEncoding</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *entry, <span class="keyword">unsigned</span> <span class="keyword">int</span> entrylen, <span class="keyword">long</span> <span class="keyword">long</span> *v, <span class="keyword">unsigned</span> <span class="keyword">char</span> *encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entrylen &gt;= <span class="number">32</span> || entrylen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (string2ll((<span class="keyword">char</span>*)entry,entrylen,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* Great, the string can be encoded. Check what&#x27;s the smallest</span></span><br><span class="line"><span class="comment">         * of our encoding types that can hold this value. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">            *encoding = ZIP_INT_IMM_MIN+value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_8B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_16B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_24B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_32B;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *encoding = ZIP_INT_64B;</span><br><span class="line">        &#125;</span><br><span class="line">        *v = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store integer &#x27;value&#x27; at &#x27;p&#x27;, encoded as &#x27;encoding&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zipSaveInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int64_t</span> value, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_8B) &#123;</span><br><span class="line">        ((<span class="keyword">int8_t</span>*)p)[<span class="number">0</span>] = (<span class="keyword">int8_t</span>)value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        i16 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i16,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">        memrev16ifbe(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_24B) &#123;</span><br><span class="line">        i32 = value&lt;&lt;<span class="number">8</span>;</span><br><span class="line">        memrev32ifbe(&amp;i32);</span><br><span class="line">        <span class="built_in">memcpy</span>(p,((<span class="keyword">uint8_t</span>*)&amp;i32)+<span class="number">1</span>,<span class="keyword">sizeof</span>(i32)-<span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        i32 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i32,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">        memrev32ifbe(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        i64 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i64,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">        memrev64ifbe(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) &#123;</span><br><span class="line">        <span class="comment">/* Nothing to do, the value is stored in the encoding itself. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read integer encoded as &#x27;encoding&#x27; from &#x27;p&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">zipLoadInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_8B) &#123;</span><br><span class="line">        ret = ((<span class="keyword">int8_t</span>*)p)[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i16,p,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">        memrev16ifbe(&amp;i16);</span><br><span class="line">        ret = i16;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i32,p,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">        memrev32ifbe(&amp;i32);</span><br><span class="line">        ret = i32;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_24B) &#123;</span><br><span class="line">        i32 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(((<span class="keyword">uint8_t</span>*)&amp;i32)+<span class="number">1</span>,p,<span class="keyword">sizeof</span>(i32)-<span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        memrev32ifbe(&amp;i32);</span><br><span class="line">        ret = i32&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i64,p,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">        memrev64ifbe(&amp;i64);</span><br><span class="line">        ret = i64;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) &#123;</span><br><span class="line">        ret = (encoding &amp; ZIP_INT_IMM_MASK)<span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Find pointer to the entry equal to the specified entry. Skip &#x27;skip&#x27; entries</span></span><br><span class="line"><span class="comment"> * between every comparison. Returns NULL when the field could not be found. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistFind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">unsigned</span> <span class="keyword">int</span> skip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> skipcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> vencoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vll = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, encoding, lensize, len;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *q;</span><br><span class="line"></span><br><span class="line">        ZIP_DECODE_PREVLENSIZE(p, prevlensize); <span class="comment">// 获取当前节点prelen的size，为了P往后偏移取出encoding</span></span><br><span class="line">        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len); <span class="comment">// 获取当前节点encoding的size和数据size</span></span><br><span class="line">        q = p + prevlensize + lensize; <span class="comment">// q指向该节点存储的数据地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipcnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Compare current entry with specified entry */</span></span><br><span class="line">            <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == vlen &amp;&amp; <span class="built_in">memcmp</span>(q, vstr, vlen) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Find out if the searched field can be encoded. Note that</span></span><br><span class="line"><span class="comment">                 * we do it only the first time, once done vencoding is set</span></span><br><span class="line"><span class="comment">                 * to non-zero and vll is set to the integer value. */</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) &#123;</span><br><span class="line">                        <span class="comment">/* If the entry can&#x27;t be encoded we set it to</span></span><br><span class="line"><span class="comment">                         * UCHAR_MAX so that we don&#x27;t retry again the next</span></span><br><span class="line"><span class="comment">                         * time. */</span></span><br><span class="line">                        vencoding = UCHAR_MAX;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* Must be non-zero by now */</span></span><br><span class="line">                    assert(vencoding);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Compare current entry with specified entry, do it only</span></span><br><span class="line"><span class="comment">                 * if vencoding != UCHAR_MAX because if there is no encoding</span></span><br><span class="line"><span class="comment">                 * possible for the field it can&#x27;t be a valid integer. */</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding != UCHAR_MAX) &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> ll = zipLoadInteger(q, encoding);</span><br><span class="line">                    <span class="keyword">if</span> (ll == vll) &#123;</span><br><span class="line">                        <span class="keyword">return</span> p;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Reset skip count */</span></span><br><span class="line">            skipcnt = skip;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Skip entry */</span></span><br><span class="line">            skipcnt--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Move to next entry */</span></span><br><span class="line">        p = q + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>遍历相关：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回下一个节点的位置</span></span><br><span class="line"><span class="comment">/* Return pointer to next entry in ziplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zl is the pointer to the ziplist</span></span><br><span class="line"><span class="comment"> * p is the pointer to the current element</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The element after &#x27;p&#x27; is returned, otherwise NULL if we are at the end. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>) zl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &quot;p&quot; could be equal to ZIP_END, caused by ziplistDelete,</span></span><br><span class="line"><span class="comment">     * and we should return NULL. Otherwise, we should return NULL</span></span><br><span class="line"><span class="comment">     * when the *next* element is ZIP_END (there is no next entry). */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p += zipRawEntryLength(p);  <span class="comment">// 返回当前节点的长度，然后指针偏移到下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回上一个节点的位置</span></span><br><span class="line"><span class="comment">/* Return pointer to previous entry in ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterating backwards from ZIP_END should return the tail. When &quot;p&quot; is</span></span><br><span class="line"><span class="comment">     * equal to the first element of the list, we&#x27;re already at the head,</span></span><br><span class="line"><span class="comment">     * and should return NULL. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl); <span class="comment">// 获取根据zltail获取末尾节点的指针</span></span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END) ? <span class="literal">NULL</span> : p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == ZIPLIST_ENTRY_HEAD(zl)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果p是头节点，则不存在上一个节点了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); <span class="comment">// 获取前置节点的长度</span></span><br><span class="line">        assert(prevlen &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> p-prevlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点p的数据，如果是字符串，则填充到sstr和slen中，如果是整数，则填充到sval中</span></span><br><span class="line"><span class="comment">/* Get entry pointed to by &#x27;p&#x27; and store in either &#x27;*sstr&#x27; or &#x27;sval&#x27; depending</span></span><br><span class="line"><span class="comment"> * on the encoding of the entry. &#x27;*sstr&#x27; is always set to NULL to be able</span></span><br><span class="line"><span class="comment"> * to find out whether the string pointer or the integer value was set.</span></span><br><span class="line"><span class="comment"> * Return 0 if &#x27;p&#x27; points to the end of the ziplist, 1 otherwise. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **sstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> *slen, <span class="keyword">long</span> <span class="keyword">long</span> *sval)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p[<span class="number">0</span>] == ZIP_END) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sstr) *sstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    zipEntry(p, &amp;entry); <span class="comment">// 将内存中该节点的信息构造成中间结构zlentry，便于操作</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sstr) &#123;</span><br><span class="line">            *slen = entry.len;</span><br><span class="line">            *sstr = p+entry.headersize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sval) &#123;</span><br><span class="line">            *sval = zipLoadInteger(p+entry.headersize,entry.encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete a single entry from the ziplist, pointed to by *p.</span></span><br><span class="line"><span class="comment"> * Also update *p in place, to be able to iterate over the</span></span><br><span class="line"><span class="comment"> * ziplist, while deleting entries. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> offset = *p-zl; <span class="comment">// 获取当前节点的偏移量</span></span><br><span class="line">    zl = __ziplistDelete(zl,*p,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store pointer to current element in p, because ziplistDelete will</span></span><br><span class="line"><span class="comment">     * do a realloc which might result in a different &quot;zl&quot;-pointer.</span></span><br><span class="line"><span class="comment">     * When the delete direction is back to front, we might delete the last</span></span><br><span class="line"><span class="comment">     * entry and end up with &quot;p&quot; pointing to ZIP_END, so check this. */</span></span><br><span class="line">    *p = zl+offset;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a range of entries from the ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDeleteRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(zl,index);</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">NULL</span>) ? zl : __ziplistDelete(zl,p,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete &quot;num&quot; entries, starting at &quot;p&quot;. Returns pointer to the ziplist. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistDelete(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, totlen, deleted = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    zlentry first, tail;</span><br><span class="line"></span><br><span class="line">    zipEntry(p, &amp;first); <span class="comment">// 构造中间结构</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; p[<span class="number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</span><br><span class="line">        p += zipRawEntryLength(p); <span class="comment">// 偏移到下一个节点</span></span><br><span class="line">        deleted++; <span class="comment">// 统计删除的节点数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totlen = p-first.p; <span class="comment">/* Bytes taken by the element(s) to delete. */</span> <span class="comment">// 计算需要删除的字节数</span></span><br><span class="line">    <span class="keyword">if</span> (totlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">/* Storing `prevrawlen` in this entry may increase or decrease the</span></span><br><span class="line"><span class="comment">             * number of bytes required compare to the current `prevrawlen`.</span></span><br><span class="line"><span class="comment">             * There always is room to store this, because it was previously</span></span><br><span class="line"><span class="comment">             * stored by an entry that is now being deleted. */</span></span><br><span class="line">            <span class="comment">// 计算</span></span><br><span class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note that there is always space when p jumps backward: if</span></span><br><span class="line"><span class="comment">             * the new previous entry is large, one of the deleted elements</span></span><br><span class="line"><span class="comment">             * had a 5 bytes prevlen header, so there is for sure at least</span></span><br><span class="line"><span class="comment">             * 5 bytes free and we need just 4. */</span></span><br><span class="line">            p -= nextdiff;</span><br><span class="line">            zipStorePrevEntryLength(p,first.prevrawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update offset for tail */</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">             * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">             * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */</span></span><br><span class="line">            zipEntry(p, &amp;tail);</span><br><span class="line">            <span class="keyword">if</span> (p[tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move tail to the front of the ziplist */</span></span><br><span class="line">            memmove(first.p,p,</span><br><span class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The entire tail was deleted. No need to move memory. */</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Resize and update length */</span></span><br><span class="line">        offset = first.p-zl;</span><br><span class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</span><br><span class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</span><br><span class="line">        p = zl+offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">         * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">        <span class="keyword">if</span> (nextdiff != <span class="number">0</span>)</span><br><span class="line">            zl = __ziplistCascadeUpdate(zl,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
        <category>1-data-structure</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
