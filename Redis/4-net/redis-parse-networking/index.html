<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="源码位置：anet.c&#x2F;anet.h&#x2F;networking.c 1. 简介Redis在anet.c中对TCP&#x2F;IP网络中socket api接口和状态设置进行了封装。状态设置主要包括socket连接的阻塞性、tcp的保活定时器的设置、设置发送缓冲区、tcp的nagle算法设置、设置发送&#x2F;接收超时时间、地址重用的设置和IPv6&#x2F;IPv4的设置等。Redis网络通讯的具体实现在networking.c">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码-网络通信">
<meta property="og:url" content="http://example.com/Redis/4-net/redis-parse-networking/index.html">
<meta property="og:site_name" content="Grizzly">
<meta property="og:description" content="源码位置：anet.c&#x2F;anet.h&#x2F;networking.c 1. 简介Redis在anet.c中对TCP&#x2F;IP网络中socket api接口和状态设置进行了封装。状态设置主要包括socket连接的阻塞性、tcp的保活定时器的设置、设置发送缓冲区、tcp的nagle算法设置、设置发送&#x2F;接收超时时间、地址重用的设置和IPv6&#x2F;IPv4的设置等。Redis网络通讯的具体实现在networking.c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/Redis/4-net/redis-parse-networking/socket.png">
<meta property="og:image" content="http://example.com/Redis/4-net/redis-parse-networking/tcp_handshake.png">
<meta property="og:image" content="http://example.com/Redis/4-net/redis-parse-networking/tcp_close.png">
<meta property="og:image" content="http://example.com/Redis/4-net/redis-parse-networking/thread-io.png">
<meta property="article:published_time" content="2020-09-22T03:21:08.000Z">
<meta property="article:modified_time" content="2020-09-22T03:30:51.494Z">
<meta property="article:author" content="李辉雄">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Redis/4-net/redis-parse-networking/socket.png">

<link rel="canonical" href="http://example.com/Redis/4-net/redis-parse-networking/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis源码-网络通信 | Grizzly</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9a8d6781d509714e86bffed13a6f0b71";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Grizzly" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Grizzly</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Grizzly1127" class="github-corner" title="Grizzly1127 GitHub" aria-label="Grizzly1127 GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/Redis/4-net/redis-parse-networking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李辉雄">
      <meta itemprop="description" content="C++、Go、Python、shell、Redis、Mysql">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Grizzly">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis源码-网络通信
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-22 11:21:08 / 修改时间：11:30:51" itemprop="dateCreated datePublished" datetime="2020-09-22T11:21:08+08:00">2020-09-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/4-net/" itemprop="url" rel="index"><span itemprop="name">4-net</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>源码位置：anet.c/anet.h/networking.c</p>
<p><strong>1. 简介</strong><br>Redis在<code>anet.c</code>中对TCP/IP网络中socket api接口和状态设置进行了封装。状态设置主要包括socket连接的阻塞性、tcp的保活定时器的设置、设置发送缓冲区、tcp的nagle算法设置、设置发送/接收超时时间、地址重用的设置和IPv6/IPv4的设置等。<br>Redis网络通讯的具体实现在<code>networking.c</code>中，主要包括如何建立和客户端的连接，并且接收其命令，返回给客户端。</p>
<a id="more"></a>
<p><strong>2. 回顾tcp socket编程</strong><br>2.1 TCP客户/服务器程序socket编程流程如下：<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/Redis/4-net/redis-parse-networking/socket.png" alt="socket"></p>
<p>2.2 TCP的三次握手<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/Redis/4-net/redis-parse-networking/tcp_handshake.png" alt="handshake"></p>
<p>2.3 TCP的四次挥手<br>TCP的断开连接操作可由<strong>任意一端发起</strong><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/Redis/4-net/redis-parse-networking/tcp_close.png" alt="close"></p>
<p><strong>3. anet解析</strong><br>anet.h中定义的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port)</span></span>; <span class="comment">// tcp连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port)</span></span>; <span class="comment">// TCP非阻塞连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockBindConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *source_addr)</span></span>; <span class="comment">// TCP非阻塞绑定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockBestEffortBindConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *source_addr)</span></span>; <span class="comment">// TCP非阻塞绑定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">// unix socket连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixNonBlockConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">// unix socket非阻塞连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetRead</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span>; <span class="comment">// socket读数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetResolve</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *host, <span class="keyword">char</span> *ipbuf, <span class="keyword">size_t</span> ipbuf_len)</span></span>; <span class="comment">// 解析所有的东西</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetResolveIP</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *host, <span class="keyword">char</span> *ipbuf, <span class="keyword">size_t</span> ipbuf_len)</span></span>; <span class="comment">// 解析IP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// IPv4下创建socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcp6Server</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// IPv6下创建socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> perm, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// unix创建socket和bind</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> serversock, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// tcp socket接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> serversock)</span></span>; <span class="comment">// unix tcp socket接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetWrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span>; <span class="comment">// socket写数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetNonBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置socket为非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置socket为阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetEnableTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 启用tcp_nodelay选项（关闭Nagle算法）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetDisableTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 禁用tcp_nodelay选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置tcp keepalive选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetSendTimeout</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> ms)</span></span>; <span class="comment">// 设置发送超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetRecvTimeout</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> ms)</span></span>; <span class="comment">// 设置接收超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetPeerToString</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// 获取客户端的ip、port</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">int</span> interval)</span></span>; <span class="comment">// 设置tcp keepalive选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetSockName</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// 获取套接字的名字</span></span><br><span class="line"><span class="comment">/* 格式化操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatAddr</span><span class="params">(<span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len, <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatPeer</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatSock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Redis服务启动后会调用<code>server.c/listenToPort()</code>进行socket相关的设置和端口监听。如果服务器配置不包含要绑定的特定地址，则该函数会尝试IPv6（调用<code>anetTcp6Server()</code>）和IPv4（调用<code>anetTcpServer()</code>）协议进行绑定。<br>不管是使用IPv6还是IPv4协议，最终调用的都是<code>_anetTcpServer()</code>来创建socket并进行绑定监听，以下是该函数的实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _anetTcpServer(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> af, <span class="keyword">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">-1</span>, rv;</span><br><span class="line">    <span class="keyword">char</span> _port[<span class="number">6</span>];  <span class="comment">/* strlen(&quot;65535&quot;) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">servinfo</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(_port,<span class="number">6</span>,<span class="string">&quot;%d&quot;</span>,port);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = af;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE;    <span class="comment">/* No effect if bindaddr != NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将域名解析成ip地址</span></span><br><span class="line">    <span class="keyword">if</span> ((rv = getaddrinfo(bindaddr,_port,&amp;hints,&amp;servinfo)) != <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;%s&quot;</span>, gai_strerror(rv));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = servinfo; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = socket(p-&gt;ai_family,p-&gt;ai_socktype,p-&gt;ai_protocol)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (af == AF_INET6 &amp;&amp; anetV6Only(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// 设置SO_REUSEADDR允许我们重复bind相同的本地地址</span></span><br><span class="line">        <span class="keyword">if</span> (anetSetReuseAddr(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// bind &amp;&amp; listen</span></span><br><span class="line">        <span class="keyword">if</span> (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;unable to bind socket, errno: %d&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">-1</span>) close(s);</span><br><span class="line">    s = ANET_ERR;</span><br><span class="line">end:</span><br><span class="line">    freeaddrinfo(servinfo);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. networking解析</strong><br>新版本Redis增加了多线程I/O来改进读写缓冲区的性能，而不是改进命令执行的性能主要原因是：</p>
<ol>
<li>读写缓冲区在命令执行的生命周期中是占了比较大的比重</li>
<li>Redis更倾向于保持简单的设计，如果在命令执行部分改用多线程会不得不处理各种问题，例如并发写入、加锁等</li>
</ol>
<p>那么将读写缓冲区改为多线程后整个模型大致如下：<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/Redis/4-net/redis-parse-networking/thread-io.png" alt="thread-io"></p>
<p>4.1 线程初始化<br>首先，如果用户没有开启多线程IO，也就是io_threads_num == 1时直接按照单线程模型处理，如果超过线程数IO_THREADS_MAX_NUM上限则异常退出。</p>
<p>紧接着Redis使用listCreate()创建io_threads_num个线程，并且对主线程（id=0）以外的线程进行处理：</p>
<ul>
<li>初始化线程的等待任务数为0</li>
<li>获取锁，使得线程不能进行操作</li>
<li>将线程tid与Redis中的线程id（for循环生成）进行映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    io_threads_active = <span class="number">0</span>; <span class="comment">/* We start with threads not active. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果io_threads_num为1，则按照单线程模型处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程数设置超过上限</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num &gt; IO_THREADS_MAX_NUM) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal: too many I/O threads configured. &quot;</span></span><br><span class="line">                             <span class="string">&quot;The maximum number is %d.&quot;</span>, IO_THREADS_MAX_NUM);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 生成并初始化对应 io_threads_num 个I/O线程 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; server.io_threads_num; i++) &#123;</span><br><span class="line">        io_threads_list[i] = listCreate();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* 0为主线程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 非主线程则需要以下处理 */</span></span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">// 为线程初始化对应的锁</span></span><br><span class="line">        pthread_mutex_init(&amp;io_threads_mutex[i],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 线程等待状态初始化为0</span></span><br><span class="line">        io_threads_pending[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化后将线程暂时锁住</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[i]); <span class="comment">/* Thread will be stopped. */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid,<span class="literal">NULL</span>,IOThreadMain,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Fatal: Can&#x27;t initialize IO thread.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将index和对应线程ID加以映射</span></span><br><span class="line">        io_threads[i] = tid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.2 建立连接<br>Redis服务端会初始化一个socket端口来监听客户端的连接，当一个连接建立后，服务端会对客户端的socket进行设置：</p>
<ol>
<li>客户端socket设置为非阻塞模式，因为Redis采用的是非阻塞I/O多路复用模型。</li>
<li>客户端socket设置为 TCP_NODELAY 属性，禁用 Nagle 算法。</li>
<li>将该socket绑定读事件到时间loop，用于监听这个客户端socket的数据发送。</li>
<li>建立连接后如果发现已经超过最大连接数，则关闭连接，删除该客户端socket。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当conn为NULL时，创建无网络连接的伪客户端</span></span><br><span class="line"><span class="comment">     * 当conn不为NULL时，创建带网络连接的客户端</span></span><br><span class="line"><span class="comment">     * 因为 Redis 的命令必须在客户端的上下文中使用，所以在执行 Lua 环境中的命令时</span></span><br><span class="line"><span class="comment">     * 需要用到这种伪终端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (conn) &#123;</span><br><span class="line">        <span class="comment">// 设置非阻塞</span></span><br><span class="line">        connNonBlock(conn);</span><br><span class="line">        <span class="comment">// 禁用tcp_nodelay</span></span><br><span class="line">        connEnableTcpNoDelay(conn);</span><br><span class="line">        <span class="comment">// 设置 keep alive</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            connKeepAlive(conn,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 绑定读事件和处理函数到事件loop（开始接收命令请求）</span></span><br><span class="line">        connSetReadHandler(conn, readQueryFromClient);</span><br><span class="line">        <span class="comment">// 将私有数据指针与连接相关联</span></span><br><span class="line">        connSetPrivateData(conn, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化客户端参数</span></span><br><span class="line">    selectDb(c,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> client_id = ++server.next_client_id;</span><br><span class="line">    c-&gt;id = client_id;</span><br><span class="line">    c-&gt;resp = <span class="number">2</span>;</span><br><span class="line">    c-&gt;conn = conn;</span><br><span class="line">    c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">    c-&gt;qb_pos = <span class="number">0</span>;</span><br><span class="line">    c-&gt;querybuf = sdsempty();</span><br><span class="line">    c-&gt;pending_querybuf = sdsempty();</span><br><span class="line">    c-&gt;querybuf_peak = <span class="number">0</span>;</span><br><span class="line">    c-&gt;reqtype = <span class="number">0</span>;</span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    c-&gt;argv = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;user = DefaultUser;</span><br><span class="line">    c-&gt;multibulklen = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">    c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">    c-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">/* If the default user does not require authentication, the user is</span></span><br><span class="line"><span class="comment">     * directly authenticated. */</span></span><br><span class="line">    c-&gt;authenticated = (c-&gt;user-&gt;flags &amp; USER_FLAG_NOPASS) != <span class="number">0</span>;</span><br><span class="line">    c-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line">    c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    c-&gt;reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;read_reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_off = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_time = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_listening_port = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_ip[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    c-&gt;slave_capa = SLAVE_CAPA_NONE;</span><br><span class="line">    c-&gt;reply = listCreate();</span><br><span class="line">    c-&gt;reply_bytes = <span class="number">0</span>;</span><br><span class="line">    c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line">    listSetFreeMethod(c-&gt;reply,freeClientReplyValue);</span><br><span class="line">    listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span><br><span class="line">    c-&gt;btype = BLOCKED_NONE;</span><br><span class="line">    c-&gt;bpop.timeout = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.keys = dictCreate(&amp;objectKeyHeapPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_group = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_consumer = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_group_noack = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.numreplicas = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.reploffset = <span class="number">0</span>;</span><br><span class="line">    c-&gt;woff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;watched_keys = listCreate();</span><br><span class="line">    c-&gt;pubsub_channels = dictCreate(&amp;objectKeyPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    c-&gt;pubsub_patterns = listCreate();</span><br><span class="line">    c-&gt;peerid = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;client_list_node = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;client_tracking_redirection = <span class="number">0</span>;</span><br><span class="line">    c-&gt;client_tracking_prefixes = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_callback = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_callback_privdata = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_module = <span class="literal">NULL</span>;</span><br><span class="line">    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</span><br><span class="line">    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</span><br><span class="line">    <span class="keyword">if</span> (conn) linkClient(c); <span class="comment">// 如果不是伪客户端，那么添加到服务器的客户端链表中</span></span><br><span class="line">    initClientMultiState(c); <span class="comment">// 初始化客户端的事务状态</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.3 读事件到来<br>读事件到来，Redis需要判断是否满足Threaded IO条件。如果符合，则将client放到等待读取的队列中，并将client的flag设置为等待读取；如果不符合，则按照单线程模型往下继续处理。<br>等待读取队列由server维护，包含了所有处于读事件pending的客户端列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取客户端结构体</span></span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果启动了 I/O 线程，则将客户端加到server.clients_pending_read列表中 */</span></span><br><span class="line">    <span class="keyword">if</span> (postponeClientRead(c)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    readlen = PROTO_IOBUF_LEN; <span class="comment">// 通用缓冲区大小 1024*16</span></span><br><span class="line">    <span class="comment">/* 如果是批量请求，则需要提高缓冲区的大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> remaining = (<span class="keyword">size_t</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在某些边缘情况下，“remaining”变量可能为零，例如，在客户端暂停后恢复被阻塞的客户端。 */</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &gt; <span class="number">0</span> &amp;&amp; remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取缓冲区内当前内容的长度</span></span><br><span class="line"><span class="comment">     * 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span></span><br><span class="line"><span class="comment">     * 这些滞留内容也许不能完整构成一个符合协议的命令 */</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen); <span class="comment">// 扩容querybuf的大小</span></span><br><span class="line">    nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen); <span class="comment">// 读取内容到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取错误</span></span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE, <span class="string">&quot;Reading from client: %s&quot;</span>,connGetLastError(c-&gt;conn));</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF</span></span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">&quot;Client closed connection&quot;</span>);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) &#123;</span><br><span class="line">        <span class="comment">/* 将缓冲区内的内容追加到pending缓冲区中，稍后将使用这个缓冲区，以便在执行最后一个命令时应用字符串的副本 */</span></span><br><span class="line">        c-&gt;pending_querybuf = sdscatlen(c-&gt;pending_querybuf,</span><br><span class="line">                                        c-&gt;querybuf+qblen,nread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据内容，更新查询缓冲区（SDS） free 和 len 属性</span></span><br><span class="line">    <span class="comment">// 并将 &#x27;\0&#x27; 正确地放到内容的最后</span></span><br><span class="line">    sdsIncrLen(c-&gt;querybuf,nread);</span><br><span class="line">    <span class="comment">// 记录服务器和客户端最后一次互动的时间</span></span><br><span class="line">    c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 如果客户端是 master 的话，更新它的复制偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) c-&gt;read_reploff += nread;</span><br><span class="line">    server.stat_net_input_bytes += nread;</span><br><span class="line">    <span class="comment">// 查询缓冲区长度超出服务器最大缓冲区长度</span></span><br><span class="line">    <span class="comment">// 清空缓冲区并释放客户端</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;</span>, ci, bytes);</span><br><span class="line">        sdsfree(ci);</span><br><span class="line">        sdsfree(bytes);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 客户端输入缓冲区中有更多数据，继续分析以防有完整的命令要执行. */</span></span><br><span class="line">     processInputBufferAndReplicate(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了Threaded-IO，如何分配读取pending的client给thread呢？<code>handleClientsWithPendingReadsUsingThreads()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingReadsUsingThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!io_threads_active || !server.io_threads_do_reads) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查有多少等待读的client</span></span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;%d TOTAL READ pending clients\n&quot;</span>, processed);</span><br><span class="line"></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将每个等待的client分配给线程，当等待长度超过线程数时，每个线程分配到的client可能会超过1个</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改每个线程需要完成的数量 */</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_READ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        io_threads_pending[j] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 也可以使用主线程来处理客户端的一部分 */</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        readQueryFromClient(c-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待线程处理直到没有剩余任务 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += io_threads_pending[j];</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;I/O READ All threads finshed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次运行客户端列表以处理新的缓冲区 */</span></span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) &#123;</span><br><span class="line">            c-&gt;flags &amp;= ~ CLIENT_PENDING_COMMAND;</span><br><span class="line">            processCommandAndResetClient(c);</span><br><span class="line">        &#125;</span><br><span class="line">        processInputBufferAndReplicate(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空client_pending_read</span></span><br><span class="line">    listEmpty(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何处理读请求？<br>在上面的过程中，当任务分发完毕后，每个线程按照正常流程将自己负责的Client的读取缓冲区的内容进行处理，和原来的单线程没有太大差异。</p>
<p>每轮处理中，需要将各个线程的锁开启，打开标志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) &#123; <span class="built_in">printf</span>(<span class="string">&quot;S&quot;</span>); fflush(<span class="built_in">stdout</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;--- STARTING THREADED IO ---\n&quot;</span>);</span><br><span class="line">    serverAssert(io_threads_active == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">        <span class="comment">// 解开线程的锁定状态</span></span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[j]);</span><br><span class="line">    <span class="comment">// 现在可以开始多线程IO执行对应读/写任务</span></span><br><span class="line">    io_threads_active = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样结束时，首先需要检查是否有剩余待读的IO，如果没有，将线程锁定，标志关闭：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要停止的时候可能还有等待读的Client 在停止前进行处理</span></span><br><span class="line">    handleClientsWithPendingReadsUsingThreads();</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) &#123; <span class="built_in">printf</span>(<span class="string">&quot;E&quot;</span>); fflush(<span class="built_in">stdout</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;--- STOPPING THREADED IO [R%d] [W%d] ---\n&quot;</span>,</span><br><span class="line">        (<span class="keyword">int</span>) listLength(server.clients_pending_read),</span><br><span class="line">        (<span class="keyword">int</span>) listLength(server.clients_pending_write));</span><br><span class="line">    serverAssert(io_threads_active == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">        <span class="comment">// 本轮IO结束 将所有线程上锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[j]);</span><br><span class="line">    <span class="comment">// IO状态设置为关闭</span></span><br><span class="line">    io_threads_active = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.3 写入返回缓冲区<br>众多的<code>addReply*()</code>方法最终会调用<code>_addReplyToBuffer()</code>函数在缓冲区中添加回复数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _addReplyToBuffer(client *c, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> available = <span class="keyword">sizeof</span>(c-&gt;buf)-c-&gt;bufpos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正准备关闭客户端，无需回复任何内容</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果回复列表中已经有内容，则无法向静态缓冲区添加更多内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;reply) &gt; <span class="number">0</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查缓冲区是否有足够的空间用于该字符串 */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; available) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内容追加到c-&gt;buf中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;buf+c-&gt;bufpos,s,len);</span><br><span class="line">    c-&gt;bufpos+=len;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用<code>_addReplyToBuffer()</code>函数失败，将会调用另一个函数<code>_addReplyProtoToList()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _addReplyProtoToList(client *c, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    listNode *ln = listLast(c-&gt;reply);</span><br><span class="line">    clientReplyBlock *tail = ln? listNodeValue(ln): <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that &#x27;tail&#x27; may be NULL even if we have a tail node, becuase when</span></span><br><span class="line"><span class="comment">     * addDeferredMultiBulkLength() is used, it sets a dummy node to NULL just</span></span><br><span class="line"><span class="comment">     * fo fill it later, when the size of the bulk length is set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Append to tail string when possible. */</span></span><br><span class="line">    <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">        <span class="comment">/* Copy the part we can fit into the tail, and leave the rest for a</span></span><br><span class="line"><span class="comment">         * new node */</span></span><br><span class="line">        <span class="keyword">size_t</span> avail = tail-&gt;size - tail-&gt;used;</span><br><span class="line">        <span class="keyword">size_t</span> copy = avail &gt;= len? len: avail;</span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf + tail-&gt;used, s, copy);</span><br><span class="line">        tail-&gt;used += copy;</span><br><span class="line">        s += copy;</span><br><span class="line">        len -= copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        <span class="comment">/* Create a new node, make sure it is allocated to at</span></span><br><span class="line"><span class="comment">         * least PROTO_REPLY_CHUNK_BYTES */</span></span><br><span class="line">        <span class="keyword">size_t</span> size = len &lt; PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;</span><br><span class="line">        tail = zmalloc(size + <span class="keyword">sizeof</span>(clientReplyBlock));</span><br><span class="line">        <span class="comment">/* take over the allocation&#x27;s internal fragmentation */</span></span><br><span class="line">        tail-&gt;size = zmalloc_usable(tail) - <span class="keyword">sizeof</span>(clientReplyBlock);</span><br><span class="line">        tail-&gt;used = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf, s, len);</span><br><span class="line">        listAddNodeTail(c-&gt;reply, tail);</span><br><span class="line">        c-&gt;reply_bytes += tail-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    asyncCloseClientOnOutputBufferLimitReached(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>李辉雄
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/Redis/4-net/redis-parse-networking/" title="Redis源码-网络通信">http://example.com/Redis/4-net/redis-parse-networking/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Redis/4-net/redis-parse-event/" rel="prev" title="Redis源码-事件驱动">
      <i class="fa fa-chevron-left"></i> Redis源码-事件驱动
    </a></div>
      <div class="post-nav-item">
    <a href="/c-c/cpp-STL-brief/" rel="next" title="C++ STL库底层数据结构">
      C++ STL库底层数据结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李辉雄"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">李辉雄</p>
  <div class="site-description" itemprop="description">C++、Go、Python、shell、Redis、Mysql</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李辉雄</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '83e621afbb975e7ae373',
      clientSecret: '51509442793886cbca7c0d7508b24c3ae0e38d28',
      repo        : 'blog_comments',
      owner       : 'Grizzly1127',
      admin       : ['Grizzly1127'],
      id          : 'b0312f3979b082b2d55b4e55c3447538',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
