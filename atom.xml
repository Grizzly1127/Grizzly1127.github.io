<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grizzly</title>
  
  <subtitle>记录点点滴滴</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-22T07:25:37.230Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>李辉雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>缓存淘汰算法LRU与LFU</title>
    <link href="http://example.com/c-c/cpp-lru-lfu/"/>
    <id>http://example.com/c-c/cpp-lru-lfu/</id>
    <published>2020-09-22T06:31:14.000Z</published>
    <updated>2020-09-22T07:25:37.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>常用的缓存过期淘汰策略有：LRU、LFU、FIFO等，因为FIFO（First in first out）算法是一种先进先出的队列，算法很简单，就不具体描述了，下面介绍LRU和LFU的算法策略。<br><a id="more"></a><br>LRU：最近最少使用淘汰算法（Least Recently Used）。如果一个数据在最近一段时间内没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此当空间满时，最久没有被访问的数据最先被淘汰。<br>LFU：最不经常使用淘汰算法（Least Frequently Used），如果一个数据在最近一段时间内很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此当空间满时，最小频率访问的数据最先被淘汰。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p><strong>LRU：</strong><br>最常见的算法是使用一个链表保存缓存数据，不考虑时间复杂度的基本算法思想如下：  </p><ol><li>新数据插入到链表头。</li><li>缓存命中的数据（被访问到的），将移到链表头。</li><li>当链表满时，将链表尾部数据淘汰（丢弃）。</li></ol><p>leetcode上关于LRU算法的题目：<a href="https://leetcode-cn.com/problems/lru-cache/">https://leetcode-cn.com/problems/lru-cache/</a>  </p><p>O(1)时间复杂度的解法：<br>【哈希表+双向链表】算法思想：  </p><p>定义一个哈希表ket_table，该哈希表的索引为key，每个索引存放链表里的内存地址，链表中存放着缓存数据。  </p><p>当执行get(key)操作时，如果该key存在于哈希表中，通过key可以直接得到缓存的内存地址，将值取出返回，如果不存在则返回-1。当查找到缓存时，需要将缓存数据置于链表头部，表示该缓存是最新被访问的。  </p><p>当执行put(key, value)操作时，如果key存在于哈希表中，删除链表中的数据，再将新数据插入到链表头部，并将头部的内存地址赋值给该key的哈希表中，如果不存在，则判断是否缓存已满，没有满则直接插入链表和哈希表中，满了则删除链表尾部的缓存数据，然后再进行插入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_capacity;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; lrus;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator&gt; m_key_table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        m_capacity = capacity;</span><br><span class="line">        m_key_table.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_key_table.count(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果key存在，则取出value，并把数据移到链表头</span></span><br><span class="line">            <span class="keyword">int</span> value = m_key_table[key]-&gt;second;</span><br><span class="line">            lrus.erase(m_key_table[key]);</span><br><span class="line">            lrus.push_front(&#123;key, value&#125;);</span><br><span class="line">            m_key_table[key] = lrus.begin();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_key_table.count(key)) &#123;</span><br><span class="line">             <span class="comment">// 如果存在，则删除链表里的数据</span></span><br><span class="line">            lrus.erase(m_key_table[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_key_table.size() == m_capacity) &#123;</span><br><span class="line">             <span class="comment">// 如果超出了缓存容量，则需要链表尾部删除</span></span><br><span class="line">            m_key_table.erase(lrus.back().first);</span><br><span class="line">            lrus.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新插入的数据放到链表头</span></span><br><span class="line">        lrus.push_front(&#123;key, value&#125;);</span><br><span class="line">        m_key_table[key] = lrus.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>LFU：</strong><br>leetcode上关于LFU算法的题目：<a href="https://leetcode-cn.com/problems/lfu-cache/">https://leetcode-cn.com/problems/lfu-cache/</a><br>O(1)时间复杂度解法：<br>【哈希表+双向链表】算法思想：  </p><p>该算法与LRU算法类似，不过LFU需要用到访问频率信息，所以该算法需要两个哈希表实现。  </p><p>第一个哈希表freq_table的索引为freq（访问频率），每个索引存放一个双向链表，第二个哈希表key_table的索引为key，每个索引存放该key在链表中的内存地址。还需要一个类变量m_min_freq用于保存最小的访问频率，当需要进行删除缓存的时候，可以用该变量定位缓存的位置进行删除。  </p><p>当执行get(key)操作时，通过key在key_table中获取缓存的内存地址，如果不存在，则返回-1，如果存在，则取出缓存数据，访问频率需要增加1，所以要将缓存放入freq_table[freq+1]的链表头部。  </p><p>当执行put(key, value)操作时，判断该key是否在key_table中，如果不存在，并且容量没有满，则直接插入到freq_table[1]的链表中，如果容量满了，则通过m_min_freq找到最小访问频率的链表，从尾部删除数据，然后将新数据直接插入到freq_table[1]的链表头部。如果key存在与key_table中，则取出链表中的缓存数据，更新新的value，并增加访问频率(freq+1)，将插入到freq_table[1]的链表头部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LFUStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value, freq;</span><br><span class="line">    LFUStruct (<span class="keyword">int</span> k, <span class="keyword">int</span> v, <span class="keyword">int</span> f) : key(k), value(v), freq(f) &#123;&#125;</span><br><span class="line">&#125; lfu;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_capacity;</span><br><span class="line">    <span class="keyword">int</span> m_min_freq;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;lfu&gt;::iterator&gt; m_key_table;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;lfu&gt;&gt; m_freq_table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        m_capacity = capacity;</span><br><span class="line">        m_min_freq = <span class="number">0</span>;</span><br><span class="line">        m_key_table.clear();</span><br><span class="line">        m_freq_table.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = m_key_table.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m_key_table.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存在key，则取出value并且freq+1，把节点移入到m_freq_table[freq+1]的链表顶部</span></span><br><span class="line">        <span class="keyword">auto</span> get_it = it-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> value = get_it-&gt;value;</span><br><span class="line">        <span class="keyword">int</span> freq = get_it-&gt;freq;</span><br><span class="line">        m_freq_table[freq].erase(get_it);</span><br><span class="line">        <span class="keyword">if</span> (m_freq_table[freq].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            m_freq_table.erase(freq);</span><br><span class="line">            <span class="keyword">if</span> (m_min_freq == freq) m_min_freq += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_freq_table[freq + <span class="number">1</span>].push_front(lfu(key, value, freq + <span class="number">1</span>));</span><br><span class="line">        m_key_table[key] = m_freq_table[freq + <span class="number">1</span>].begin();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = m_key_table.find(key);</span><br><span class="line">        <span class="comment">// 如果没有找到该key，表明不存在，则插入</span></span><br><span class="line">        <span class="keyword">if</span> (it == m_key_table.end()) &#123;</span><br><span class="line">            <span class="comment">// 当缓存达到最大容量时，需要删除访问频率最少的键</span></span><br><span class="line">            <span class="keyword">if</span> (m_key_table.size() &gt;= m_capacity) &#123;</span><br><span class="line">                <span class="keyword">auto</span> del = m_freq_table[m_min_freq].back(); <span class="comment">// 链表末尾弹出需要删除的节点</span></span><br><span class="line">                m_freq_table[m_min_freq].pop_back();</span><br><span class="line">                m_key_table.erase(del.key);</span><br><span class="line">                <span class="keyword">if</span>(m_freq_table[m_min_freq].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    m_freq_table.erase(m_min_freq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入新缓存</span></span><br><span class="line">            m_freq_table[<span class="number">1</span>].push_front(lfu(key, value, <span class="number">1</span>));</span><br><span class="line">            m_key_table[key] = m_freq_table[<span class="number">1</span>].begin();</span><br><span class="line">            m_min_freq = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果找到key，则更新</span></span><br><span class="line">            <span class="keyword">auto</span> update_it = it-&gt;second;</span><br><span class="line">            <span class="keyword">int</span> freq = update_it-&gt;freq;</span><br><span class="line">            m_freq_table[freq].erase(update_it); <span class="comment">// 删除freq_table里的缓存节点</span></span><br><span class="line">            <span class="keyword">if</span> (m_freq_table[freq].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                m_freq_table.erase(freq);</span><br><span class="line">                <span class="keyword">if</span> (m_min_freq == freq) &#123;</span><br><span class="line">                    m_min_freq += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m_freq_table[freq + <span class="number">1</span>].push_front(lfu(key, value, freq + <span class="number">1</span>));</span><br><span class="line">            m_key_table[key] = m_freq_table[freq + <span class="number">1</span>].begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;常用的缓存过期淘汰策略有：LRU、LFU、FIFO等，因为FIFO（First in first out）算法是一种先进先出的队列，算法很简单，就不具体描述了，下面介绍LRU和LFU的算法策略。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="lru" scheme="http://example.com/tags/lru/"/>
    
    <category term="lfu" scheme="http://example.com/tags/lfu/"/>
    
  </entry>
  
  <entry>
    <title>结构体中的位域</title>
    <link href="http://example.com/cpp/cpp-bit-field/"/>
    <id>http://example.com/cpp/cpp-bit-field/</id>
    <published>2020-09-22T06:28:39.000Z</published>
    <updated>2020-09-22T07:25:41.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有些信息存储时，并不需要占用一整个完整的字节，而只需要占几个或一个二进制位。例如存放一个开关变量时，只需要用到0或1两种状态，用一位二进制位即可。所以，为了节省空间，C语言提供了一种叫<strong>位域</strong>的数据结构。<br><a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    type [member_name] : width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>元素</th><th>描述</th></tr></thead><tbody><tr><td>type</td><td>只能为int, unsigned int, signed int三种类型</td></tr><tr><td>member_name</td><td>位域的名称</td></tr><tr><td>width</td><td>位域中位的数量。宽度必须小于或等于指定类型的位宽度</td></tr></tbody></table></div><p>位域的使用：</p><ol><li>位域成员的类型必须指定为unsigned或int类型。</li><li>一个位段必须存储在同一存储单元中，不能跨两个单元。如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段。</li><li>可以定义无名位域（形式：type :0;），无名位域用于填充内存布局，表示下一个位域从下一个内存边界开始。</li><li>位域的长度不能大于存储单元的长度，也不能定义位域数组。</li><li>位域可以用整型格式符输出。</li><li>位域可以在数值表达式中引用，它会被系统自动地转换成整型数。</li><li>位域定义的第一个位域长度不能为0。</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>             <span class="comment">// 64b</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>             <span class="comment">// 64b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;                      <span class="comment">// 64b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;                        <span class="comment">// 32b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;                <span class="comment">// 16b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;              <span class="comment">// 2b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;             <span class="comment">// 2b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>;            <span class="comment">// 1b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>;    <span class="comment">// 1b</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>;                <span class="comment">// 10b</span></span><br><span class="line">&#125; quicklistNode;                            <span class="comment">// = (256b / 8) = 32Byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;quicklistNode size: %d\n&quot;</span>, <span class="keyword">sizeof</span>(struct quicklistNode));</span><br><span class="line">    <span class="comment">// output :</span></span><br><span class="line">    <span class="comment">// quicklistNode size: 32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;有些信息存储时，并不需要占用一整个完整的字节，而只需要占几个或一个二进制位。例如存放一个开关变量时，只需要用到0或1两种状态，用一位二进制位即可。所以，为了节省空间，C语言提供了一种叫&lt;strong&gt;位域&lt;/strong&gt;的数据结构。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="位域" scheme="http://example.com/tags/%E4%BD%8D%E5%9F%9F/"/>
    
    <category term="bitfield" scheme="http://example.com/tags/bitfield/"/>
    
  </entry>
  
  <entry>
    <title>c/c++ 内存大小端模式</title>
    <link href="http://example.com/c-c/cpp-byte-endian/"/>
    <id>http://example.com/c-c/cpp-byte-endian/</id>
    <published>2020-09-22T06:24:41.000Z</published>
    <updated>2020-09-22T07:02:32.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>维基百科：</strong><br>字节顺序，又称端序或尾序（英语：<strong>Endianness</strong>），在计算机科学领域中，指存储器中或在数字通信链路中，组成多字节的字的字节的排列顺序。<br><a id="more"></a><br>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。</p><p>字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。</p><p>例如假设上述变量x类型为int，位于地址0x100处，它的值为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..。</p><p><strong>百度百科：</strong><br>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p><p>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p><h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><p>以unsigned int value = 0x12345678为例：</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>小端模式（Little-Endian）</th><th>大端模式（Big-Endian）</th></tr></thead><tbody><tr><td>0x100（低地址）</td><td>0x78</td><td>0x12</td></tr><tr><td>0x101</td><td>0x56</td><td>0x34</td></tr><tr><td>0x102</td><td>0x34</td><td>0x56</td></tr><tr><td>0x103（高地址）</td><td>0x12</td><td>0x78</td></tr></tbody></table></div><h2 id="redis中的大小端"><a href="#redis中的大小端" class="headerlink" title="redis中的大小端"></a>redis中的大小端</h2><p>为了兼容不同目标机的字节顺序，redis统一采用了小端字节序的方式存储。对于字节序的转码，redis提供了16byte、32byte、64byte字节的转换，代码在endianconv.c和endianconv.h中。代码很简单，看一下就能明白。<br>贴上代码：<br><strong>endianconv.h</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev16</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev32</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev64</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">intrev16</span><span class="params">(<span class="keyword">uint16_t</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">intrev32</span><span class="params">(<span class="keyword">uint32_t</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">intrev64</span><span class="params">(<span class="keyword">uint64_t</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (BYTE_ORDER == LITTLE_ENDIAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev16ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev32ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev64ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev16ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev32ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev64ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev16ifbe(p) memrev16(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev32ifbe(p) memrev32(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev64ifbe(p) memrev64(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev16ifbe(v) intrev16(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev32ifbe(v) intrev32(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev64ifbe(v) intrev64(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (BYTE_ORDER == BIG_ENDIAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> htonu64(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ntohu64(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> htonu64(v) intrev64(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ntohu64(v) intrev64(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endianconvTest</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>endianconv.c</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev16</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev32</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">3</span>];</span><br><span class="line">    x[<span class="number">3</span>] = t;</span><br><span class="line">    t = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = x[<span class="number">2</span>];</span><br><span class="line">    x[<span class="number">2</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev64</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">7</span>];</span><br><span class="line">    x[<span class="number">7</span>] = t;</span><br><span class="line">    t = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = x[<span class="number">6</span>];</span><br><span class="line">    x[<span class="number">6</span>] = t;</span><br><span class="line">    t = x[<span class="number">2</span>];</span><br><span class="line">    x[<span class="number">2</span>] = x[<span class="number">5</span>];</span><br><span class="line">    x[<span class="number">5</span>] = t;</span><br><span class="line">    t = x[<span class="number">3</span>];</span><br><span class="line">    x[<span class="number">3</span>] = x[<span class="number">4</span>];</span><br><span class="line">    x[<span class="number">4</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">intrev16</span><span class="params">(<span class="keyword">uint16_t</span> v)</span> </span>&#123;</span><br><span class="line">    memrev16(&amp;v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">intrev32</span><span class="params">(<span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">    memrev32(&amp;v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">intrev64</span><span class="params">(<span class="keyword">uint64_t</span> v)</span> </span>&#123;</span><br><span class="line">    memrev64(&amp;v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;维基百科：&lt;/strong&gt;&lt;br&gt;字节顺序，又称端序或尾序（英语：&lt;strong&gt;Endianness&lt;/strong&gt;），在计算机科学领域中，指存储器中或在数字通信链路中，组成多字节的字的字节的排列顺序。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="大端" scheme="http://example.com/tags/%E5%A4%A7%E7%AB%AF/"/>
    
    <category term="小端" scheme="http://example.com/tags/%E5%B0%8F%E7%AB%AF/"/>
    
    <category term="endian" scheme="http://example.com/tags/endian/"/>
    
  </entry>
  
  <entry>
    <title>c/c++ 内存对齐</title>
    <link href="http://example.com/c-c/cpp-memory-alignment/"/>
    <id>http://example.com/c-c/cpp-memory-alignment/</id>
    <published>2020-09-22T06:15:23.000Z</published>
    <updated>2020-09-22T07:02:25.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>内存对齐，也叫字节对齐。<br>现代计算机中，内存空间都是按照字节划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。<br><a id="more"></a></p><p>CPU每次从内存中取出数据或者指令时，并非想象中的一个一个字节取出拼接的，而是根据自己的字长，也就是CPU一次能够处理的数据长度取出内存块，比如32位处理器将取出32位也就是4个字节的内存块进行处理。</p><h2 id="为什么需要内存对齐"><a href="#为什么需要内存对齐" class="headerlink" title="为什么需要内存对齐"></a>为什么需要内存对齐</h2><p>1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。<br>2、性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p><h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><p>每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数，例如32位处理器，默认为4，64位处理器，默认为8)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。<br>规则：<br>1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。<br>2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。<br>3、结合1、2可推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。  </p><p>根据上述规则，得到整体对齐系数= min((max(type1,type2,type3,…), n)<br>其中type为结构体中的类型的字节大小，n为#pragma pack(n)设定值  </p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n) <span class="comment">/* n = 1, 2, 4, 8, 16 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 4byte</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 1byte</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 2byte</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 1byte</span></span><br><span class="line">&#125; ma;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ma size=%ld\n&quot;</span>, <span class="keyword">sizeof</span>(ma));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. #pragma pack(1)</strong></p><p>按照1字节对齐的结果：<br>ma size=8<br>分析：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按1对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按1对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按1对齐；偏移量为5；存放位置区间[5,6]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按1对齐；偏移量为7；存放位置区间[7]</span></span><br><span class="line">    <span class="comment">// 共8个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure><p>   整体对齐系数=min(max(int, char, short, char), 1) = 1<br>所以不需要再进行整体对齐。整体大小就为8。  </p><p><strong>2. #pragma pack(2)</strong></p><p>按照2字节对齐的结果：<br>ma size=16<br>分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按2对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按2对齐；偏移量为8；存放位置区间[8]</span></span><br><span class="line">    <span class="comment">// 共9个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure><p>整体对齐系数=min(max(int, char, short, char), 2) = 2<br>将9提升到2的倍数，则为10，所以最终结果为10个字节。</p><p><strong>3. #pragma pack(4)</strong></p><p>按照4字节对齐的结果：<br>ma size=12<br>分析：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按2对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按2对齐；偏移量为8；存放位置区间[8]</span></span><br><span class="line">    <span class="comment">// 共9个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure><p>整体对齐系数=min(max(int, char, short, char), 4) = 4<br>将9提升到4的倍数，则为12，所以最终结果为12个字节。</p><p><strong>4. #pragma pack(8)</strong></p><p>按照8字节对齐的结果：<br>ma size=12<br>分析：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按2对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按2对齐；偏移量为8；存放位置区间[8]</span></span><br><span class="line">    <span class="comment">// 共9个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure><p>整体对齐系数=min(max(int, char, short, char), 8) = 4<br>将9提升到4的倍数，则为12，所以最终结果为12个字节。</p><p><strong>5. #pragma pack(16)</strong></p><p>按照16字节对齐的结果：<br>ma size=12<br>分析：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_align</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 长度4 &gt; 1 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 长度1 = 1 按2对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line">    <span class="keyword">short</span> c;    <span class="comment">// 长度2 &gt; 1 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line">    <span class="keyword">char</span> d;     <span class="comment">// 长度1 &gt; 1 按2对齐；偏移量为8；存放位置区间[8]</span></span><br><span class="line">    <span class="comment">// 共9个字节</span></span><br><span class="line">&#125; ma;</span><br></pre></td></tr></table></figure><p>整体对齐系数=min(max(int, char, short, char), 16) = 4<br>将9提升到4的倍数，则为12，所以最终结果为12个字节。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是内存对齐&quot;&gt;&lt;a href=&quot;#什么是内存对齐&quot; class=&quot;headerlink&quot; title=&quot;什么是内存对齐&quot;&gt;&lt;/a&gt;什么是内存对齐&lt;/h2&gt;&lt;p&gt;内存对齐，也叫字节对齐。&lt;br&gt;现代计算机中，内存空间都是按照字节划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="内存对齐" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>C++11新特性</title>
    <link href="http://example.com/c-c/cpp11-features/"/>
    <id>http://example.com/c-c/cpp11-features/</id>
    <published>2020-09-22T05:43:19.000Z</published>
    <updated>2020-09-22T07:02:20.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-新功能"><a href="#1-新功能" class="headerlink" title="1. 新功能"></a>1. 新功能</h2><h3 id="1-1-新类型"><a href="#1-1-新类型" class="headerlink" title="1.1 新类型"></a>1.1 新类型</h3><p>新增类型 long long 和 unsigned long long，以支持64位（或更宽）的整型；新增类型 char16_t 和 char32_t，以支持16位和32位的字符表示。</p><h3 id="1-2-统一的初始化"><a href="#1-2-统一的初始化" class="headerlink" title="1.2 统一的初始化"></a>1.2 统一的初始化</h3><a id="more"></a><p>C++11扩大了用大括号括起的列表（初始化列表）的适用范围，使其可用于所有内置类型和用户定义的类型（即类对象）。使用初始化列表时，可添加等号（=），也可不添加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有内置类型</span></span><br><span class="line"><span class="keyword">int</span> x = &#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> y &#123;<span class="number">2.42</span>&#125;;</span><br><span class="line"><span class="keyword">short</span> quar[<span class="number">5</span>] &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 可用于new表达式</span></span><br><span class="line"><span class="keyword">int</span> * arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>] &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">// 可用于自定义对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stump</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> roots;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stump(<span class="keyword">int</span> r, <span class="keyword">double</span> w) : roots(r), weight(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stump <span class="title">s1</span><span class="params">(<span class="number">3</span>, <span class="number">15.6</span>)</span></span>;    <span class="comment">// old style</span></span><br><span class="line">Stump s2&#123;<span class="number">5</span>, <span class="number">43</span>,<span class="number">4</span>&#125;;    <span class="comment">// C++11</span></span><br><span class="line">Stump s3 = &#123;<span class="number">4</span>, <span class="number">32.1</span>&#125;; <span class="comment">// c++11</span></span><br></pre></td></tr></table></figure><p>新增模板类 <strong>initializer_list</strong>，可将其用作构造函数的参数、常规函数的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; il)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = sum(&#123;<span class="number">2.5</span>, <span class="number">3.1</span>, <span class="number">4</span>&#125;); <span class="comment">// 4 将转为4.0</span></span><br><span class="line">    <span class="comment">// todo: ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; il)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = il.begin(); p != il.end(); p++)</span><br><span class="line">        tot += *p;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-声明"><a href="#1-3-声明" class="headerlink" title="1.3 声明"></a>1.3 声明</h3><h4 id="1-3-1-auto"><a href="#1-3-1-auto" class="headerlink" title="1.3.1 auto"></a>1.3.1 auto</h4><p>以前，关键字 <strong>auto</strong> 是一个存储类型说明符，C++11 将其用于实现自动类型推断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">112</span>; <span class="comment">// a is type int</span></span><br><span class="line"><span class="keyword">auto</span> pt = &amp;a; <span class="comment">// pt is type int *</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fm</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">auto</span> pf = fm; <span class="comment">// pf is type double (*)(double, int)</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-decltype"><a href="#1-3-2-decltype" class="headerlink" title="1.3.2 decltype"></a>1.3.2 decltype</h4><p>关键字 <strong>decltype</strong> 将变量的类型声明为表达式指定的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">decltype</span>(x*n) q; <span class="comment">// q same type as x*n, i.e., double</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x) pd; <span class="comment">// pd same as &amp;x, i.e., double *</span></span><br></pre></td></tr></table></figure><h4 id="1-3-3-返回类型后置"><a href="#1-3-3-返回类型后置" class="headerlink" title="1.3.3 返回类型后置"></a>1.3.3 返回类型后置</h4><p>C++11 新增了一种函数声明语法：在函数名和参数列表后面指定返回类型：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">// old style</span></span><br><span class="line">auto f2(double, int) -&gt; double; // new syntax, return type is double</span><br></pre></td></tr></table></figure><p>在模板函数中使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto eff(T t, U u) -&gt; decltype(T*U) &#123;</span><br><span class="line">    <span class="comment">// todo: ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-模板别名：using"><a href="#1-3-4-模板别名：using" class="headerlink" title="1.3.4 模板别名：using ="></a>1.3.4 模板别名：using =</h4><p>对于冗长或复杂的标识符，如果能够创建其别名将很方便。以前，C++为此提供了 typedef：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator itType;</span><br></pre></td></tr></table></figure><p>C++11 提供了另一种创建别名的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> itType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator;</span><br></pre></td></tr></table></figure><p>差别在于，新语法也可用于模板部分具体化，但 typedef 不能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> arr12 = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, <span class="number">12</span>&gt;;</span><br></pre></td></tr></table></figure><h4 id="1-3-5-nullptr"><a href="#1-3-5-nullptr" class="headerlink" title="1.3.5 nullptr"></a>1.3.5 nullptr</h4><p>空指针是不会指向有效数据的指针。以前，C++ 在源代码中使用 0 表示这种指针，但这带来了一些问题，因为这使得 0 即可表示指针常量，又可表示整型常量。<br>新增了关键字 nullptr，用于表示空指针，它是指针类型，不能转换为整型类型。为向后兼容，C++11 仍允许使用 0 表示空指针，因此表达式 nullptr == 0 为 true。</p><h3 id="1-4-智能指针"><a href="#1-4-智能指针" class="headerlink" title="1.4 智能指针"></a>1.4 智能指针</h3><p>C++11 摒弃了 auto_ptr，并新增了三种智能指针：<strong>unique_ptr</strong>、<strong>shared_ptr</strong> 和 <strong>weak_ptr</strong>。</p><h3 id="1-5-异常规范方面的修改"><a href="#1-5-异常规范方面的修改" class="headerlink" title="1.5 异常规范方面的修改"></a>1.5 异常规范方面的修改</h3><p>C++11 提供了关键字 noexcept，该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。</p><h3 id="1-6-作用域内枚举"><a href="#1-6-作用域内枚举" class="headerlink" title="1.6 作用域内枚举"></a>1.6 作用域内枚举</h3><p>传统的C++枚举提供了一种创建名称常量的方式，但其类型检查相当低级。另外，枚举名的作用域为枚举定义所属的作用域，这意味着如果在同一个作用域内定义两个枚举，他们的枚举成员不能同名。最后，枚举可能不是可完全移植的，因为不同的实现可能选择不同的底层类型。为解决这些问题，C++11 新增了一种枚举。这种枚举使用 class 或 struct 定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Old &#123;yes, no, maybe&#125;;    <span class="comment">// old form</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">New1</span> &#123;</span>never, sometimes, often, always&#125;; <span class="comment">// new form</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span> <span class="title">New2</span> &#123;</span>never, lever, sever&#125;; <span class="comment">// new form</span></span><br></pre></td></tr></table></figure><p>新枚举要求进行显示限定，以免发生名称冲突。因此，引用特定枚举时，需要使用 New1::never 和 New2::never 等。</p><h3 id="1-7-对类的修改"><a href="#1-7-对类的修改" class="headerlink" title="1.7 对类的修改"></a>1.7 对类的修改</h3><h4 id="1-7-1-显示转换运算符"><a href="#1-7-1-显示转换运算符" class="headerlink" title="1.7.1 显示转换运算符"></a>1.7.1 显示转换运算符</h4><p>传统C++的关键字 <strong>explicit</strong> 禁止单参数构造函数导致的自动转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plebe</span> &#123;</span></span><br><span class="line">    Plebe(<span class="keyword">int</span>); <span class="comment">// automatic int-to-plebe conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Plebe</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// requires explicit use</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Plebe a, b;</span><br><span class="line">a = <span class="number">5</span>;    <span class="comment">// implicit conversion, call Plebe(5)</span></span><br><span class="line">b = <span class="number">0.5</span>;  <span class="comment">// not allowed</span></span><br><span class="line">b = Plebe(<span class="number">0.5</span>); <span class="comment">// explicit conversion</span></span><br></pre></td></tr></table></figure><p>C++11扩展了 <strong>explicit</strong> 的这种用法，使得可对转换函数做类似的处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plebe</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// conversion functions</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">Plebe a, b;</span><br><span class="line"><span class="keyword">int</span> n = a;    <span class="comment">// int-to-Plebe automatic conversion</span></span><br><span class="line"><span class="keyword">double</span> x = b;  <span class="comment">// not allowed</span></span><br><span class="line">x = <span class="keyword">double</span>(<span class="number">0.5</span>); <span class="comment">// explicit conversion, allowed</span></span><br></pre></td></tr></table></figure><h4 id="1-7-2-类内成员初始化"><a href="#1-7-2-类内成员初始化" class="headerlink" title="1.7.2 类内成员初始化"></a>1.7.2 类内成员初始化</h4><p>传统C++不支持在类定义中初始化成员，C++11可以这么做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mem1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> mem2 &#123;<span class="number">1966.54</span>&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-8-模板和STL方面的修改"><a href="#1-8-模板和STL方面的修改" class="headerlink" title="1.8 模板和STL方面的修改"></a>1.8 模板和STL方面的修改</h3><h4 id="1-8-1-基于范围的for循环"><a href="#1-8-1-基于范围的for循环" class="headerlink" title="1.8.1 基于范围的for循环"></a>1.8.1 基于范围的for循环</h4><p>对于内置数组以及包含方法 begin() 和 end() 的类和 STL 容器，可以使用如下的方式进行循环工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : arr)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 可使用auto进行类型推断</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : arr)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 可使用引用类型进行修改元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : arr)</span><br><span class="line">x = <span class="built_in">std</span>::rand();</span><br></pre></td></tr></table></figure><h4 id="1-8-2-新的STL容器"><a href="#1-8-2-新的STL容器" class="headerlink" title="1.8.2 新的STL容器"></a>1.8.2 新的STL容器</h4><p>C++11新增了STL容器： <strong>forward_list、unordered_map、unordered_multimap、unordered_set</strong> 和 <strong>unordered_multiset</strong>。<br>C++11还新增了模板 <strong>array</strong>，该模板相对于数组，新增了begin() 和 end() 方法等。</p><h4 id="1-8-3-新的STL方法"><a href="#1-8-3-新的STL方法" class="headerlink" title="1.8.3 新的STL方法"></a>1.8.3 新的STL方法</h4><p>C++11 新增了STL方法 cbegin()、cend()、crbegin() 和 crend()。是begin()、 end()、rbegin() 和 rend() 方法的const版本。</p><h4 id="1-8-4-valarray升级"><a href="#1-8-4-valarray升级" class="headerlink" title="1.8.4 valarray升级"></a>1.8.4 valarray升级</h4><p>C++11添加了两个函数（begin() 和 end()），它们都接受valarray作为参数，并返回迭代器。这使得能够将基于范围的STL算法用于 valarray。</p><h4 id="1-8-5-摒弃export"><a href="#1-8-5-摒弃export" class="headerlink" title="1.8.5 摒弃export"></a>1.8.5 摒弃export</h4><h4 id="1-8-6-尖括号"><a href="#1-8-6-尖括号" class="headerlink" title="1.8.6 尖括号"></a>1.8.6 尖括号</h4><p>为避免与运算符 &gt;&gt; 混淆，C++要求在声明嵌套模板时使用空格将尖括号分开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt; vl;</span><br></pre></td></tr></table></figure><p>C++11 不再这样要求：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; vl;</span><br></pre></td></tr></table></figure><h3 id="1-9-右值引用"><a href="#1-9-右值引用" class="headerlink" title="1.9 右值引用"></a>1.9 右值引用</h3><p>传统的 C++ 引用（现在称为左值引用）使得标识符关联到左值。左值是一个表示数据的表达式（如变量名或解除引用的指针），程序可获取其地址。最初，左值可出现在赋值语句的左边，但修饰符 const 的出现使得可以声明这样的标识符，即不能给它赋值，但可获取其地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">101</span>;   <span class="comment">// can&#x27;t assign to b, but &amp;b is valid</span></span><br><span class="line"><span class="keyword">int</span> &amp; rn = n;        <span class="comment">// n identifies datum at address &amp;n</span></span><br><span class="line"><span class="keyword">int</span> &amp; rt = *pt;      <span class="comment">// *pt identifies datum at address pt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; rb = b;  <span class="comment">// b identifies const datum at address &amp;b</span></span><br></pre></td></tr></table></figure><p>C++11 新增了右值引用，这是使用&amp;&amp;表示的。右值引用可关联到右值，即可出现在赋值表达式右边，但不能对其应用地址运算符的值。右值包括字面常量、诸如x+y等表达式以及返回值的函数（条件是该函数返回的不是引用）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; r1 = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; r2 = x + y;</span><br><span class="line"><span class="keyword">double</span> &amp;&amp; r3 = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p>注意，r2关联到的是当时计算 x + y 得到的结果。也就是说，r2关联到的是33，即使以后修改了x 或 y，也不影响到r2。<br>有趣的是，将右值关联到右值引用导致该右值被存储到特定的位置，且可以获取该位置的地址。也就是说，虽然不能将运算符&amp;用于13，但可将其用于r1。通过将数据与特定的地址关联，使得可以通过右值引用来访问该数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> tf)</span> </span>&#123; <span class="keyword">return</span> <span class="number">5.0</span>*(tf<span class="number">-32.0</span>)/<span class="number">9.0</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> tc = <span class="number">21.5</span>;</span><br><span class="line">    <span class="keyword">double</span> &amp;&amp; rd1 = <span class="number">7.07</span>;</span><br><span class="line">    <span class="keyword">double</span> &amp;&amp; rd2 = <span class="number">1.8</span> * tc + <span class="number">32.0</span>;</span><br><span class="line">    <span class="keyword">double</span> &amp;&amp; rd3 = f(rd2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; tc value and address: &quot;</span> &lt;&lt; tc &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;tc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rd1 value and address: &quot;</span> &lt;&lt; rd1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;rd1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rd2 value and address: &quot;</span> &lt;&lt; rd2 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;rd2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rd3 value and address: &quot;</span> &lt;&lt; rd3 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;rd3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序输出如下：</span></span><br><span class="line">tc value <span class="keyword">and</span> address: <span class="number">21.5</span>, <span class="number">0x7ffeb988e850</span></span><br><span class="line">rd1 value <span class="keyword">and</span> address: <span class="number">7.07</span>, <span class="number">0x7ffeb988e858</span></span><br><span class="line">rd2 value <span class="keyword">and</span> address: <span class="number">70.7</span>, <span class="number">0x7ffeb988e860</span></span><br><span class="line">rd3 value <span class="keyword">and</span> address: <span class="number">21.5</span>, <span class="number">0x7ffeb988e868</span></span><br></pre></td></tr></table></figure><p>引入右值引用的主要目的之一是实现移动语义。</p><h2 id="2-移动语义和右值引用"><a href="#2-移动语义和右值引用" class="headerlink" title="2. 移动语义和右值引用"></a>2. 移动语义和右值引用</h2><h3 id="2-1-为何需要移动语义"><a href="#2-1-为何需要移动语义" class="headerlink" title="2.1 为何需要移动语义"></a>2.1 为何需要移动语义</h3><p>定义并实现了一个 MyString 字符串类，该类内部管理一个 char * 数组。这个时候一般都需要实现拷贝构造函数和拷贝赋值函数，因为默认的拷贝是浅拷贝，而指针这种资源不能共享，不然一个析构了，另一个也就完蛋了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">        CCtor ++;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyString() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间，不这么做，调用的次数可能远大于1000</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.push_back(MyString(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// output: CCtor = 1000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码调用了1000次拷贝构造函数，如果 MyString(“hello”) 构造出来的字符串本来就很长，构造一遍就很耗时了，最后却还要拷贝一遍，而 MyString(“hello”) 只是临时对象，拷贝完就没什么用了，这就造成了没有意义的资源申请和释放操作，如果能够直接使用临时对象已经申请的资源，既能节省资源，又能节省资源申请和释放的时间。而 C++11 新增加的移动语义就能够做到这一点。移动语义实际上避免了移动原始数据，而只是修改了记录。</p><h3 id="2-2-一个移动示例"><a href="#2-2-一个移动示例" class="headerlink" title="2.2 一个移动示例"></a>2.2 一个移动示例</h3><p>下面通过一个示例演示移动语义和右值引用的工作原理。要实现移动语义就必须增加两个函数：移动构造函数和移动赋值构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MCtor; <span class="comment">//统计调用移动构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CAsgn; <span class="comment">//统计调用拷贝赋值函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MAsgn; <span class="comment">//统计调用移动赋值函数的次数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">        CCtor ++;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">        :m_data(str.m_data) &#123;</span><br><span class="line">        MCtor ++;</span><br><span class="line">        str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str)&#123;</span><br><span class="line">        CAsgn ++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">        MAsgn ++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = str.m_data;</span><br><span class="line">        str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyString() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.push_back(MyString(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output：</span></span><br><span class="line"><span class="comment">* CCtor = 0</span></span><br><span class="line"><span class="comment">* MCtor = 1000</span></span><br><span class="line"><span class="comment">* CAsgn = 0</span></span><br><span class="line"><span class="comment">* MAsgn = 0 */</span></span><br></pre></td></tr></table></figure><p>可以看到，移动构造函数与拷贝构造函数的区别是，拷贝构造的参数是 const MyString&amp; str，是常量左值引用，而移动构造的参数是 MyString&amp;&amp; str，是右值引用，而 MyString(“hello”) 是个临时对象，是个右值，优先进入移动构造函数而不是拷贝构造函数。而移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是”偷”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为 nullptr，这一步很重要，如果不将别人的指针修改为空，那么临时对象析构的时候就会释放掉这个资源，”偷”也白偷了。</p><h3 id="2-3-强制移动"><a href="#2-3-强制移动" class="headerlink" title="2.3 强制移动"></a>2.3 强制移动</h3><p>对于一个左值，肯定是调用拷贝构造函数了，但是有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？ C++11 为了解决这个问题，在头文件 utility.h 中提供了 std::move() 方法来将左值转换为右值，从而方便应用移动语义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="function">MyString <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">        vecStr.push_back(tmp); <span class="comment">//调用的是拷贝构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    MyString::CCtor = <span class="number">0</span>;</span><br><span class="line">    MyString::MCtor = <span class="number">0</span>;</span><br><span class="line">    MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line">    MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr2;</span><br><span class="line">    vecStr2.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="function">MyString <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">        vecStr2.push_back(<span class="built_in">std</span>::move(tmp)); <span class="comment">//调用的是移动构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">CCtor = 1000</span></span><br><span class="line"><span class="comment">MCtor = 0</span></span><br><span class="line"><span class="comment">CAsgn = 0</span></span><br><span class="line"><span class="comment">MAsgn = 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CCtor = 0</span></span><br><span class="line"><span class="comment">MCtor = 1000</span></span><br><span class="line"><span class="comment">CAsgn = 0</span></span><br><span class="line"><span class="comment">MAsgn = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于大多数程序员来说，右值引用带来的主要好处并非是让他们能够编写使用右值引用的代码，而是能够使用利用右值引用实现移动语义的库代码。例如，STL 类现在都有复制构造函数、移动构造函数、复制赋值运算符和移动复制运算符。</p><h2 id="3-新的类功能"><a href="#3-新的类功能" class="headerlink" title="3. 新的类功能"></a>3. 新的类功能</h2><h3 id="3-1-特殊的成员函数"><a href="#3-1-特殊的成员函数" class="headerlink" title="3.1 特殊的成员函数"></a>3.1 特殊的成员函数</h3><p>在原有的4个特殊成员函数（默认构造函数、复制构造函数、复制赋值运算符和析构函数）的基础上，C++11 新增了两个：移动构造函数和移动赋值运算符。这些成员函数是编译器在各种情况下自动提供的。</p><h3 id="3-2-默认的方法和禁用的方法"><a href="#3-2-默认的方法和禁用的方法" class="headerlink" title="3.2 默认的方法和禁用的方法"></a>3.2 默认的方法和禁用的方法</h3><p>C++11 提供了更好地控制要使用的方法：可使用关键字 default 显示地声明这些方法的默认版本；关键字 delete 可用于禁止编译器使用特定方法。</p><h3 id="3-3-委托构造函数"><a href="#3-3-委托构造函数" class="headerlink" title="3.3 委托构造函数"></a>3.3 委托构造函数</h3><p>如果给类提供了多个构造函数，您可能重复编写相同的代码。也就是说，有些构造函数可能需要包含其他构造函数中已有的代码。为了让编码工作更简单、更可靠，C++11 允许您在一个构造函数的定义中使用另一个构造函数。这被称为委托。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notes</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> st;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Notes();</span><br><span class="line">    Notes(<span class="keyword">int</span>);</span><br><span class="line">    Notes(<span class="keyword">int</span>, <span class="keyword">double</span>);</span><br><span class="line">    Notes(<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">string</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Notes::Notes(<span class="keyword">int</span> kk, <span class="keyword">double</span> xx, <span class="built_in">std</span>::<span class="built_in">string</span> stt) : k(kk), x(xx), st(stt) &#123; <span class="comment">/*do stuff*/</span> &#125;</span><br><span class="line">Notes::Notes() : Notes(<span class="number">0</span>, <span class="number">0.01</span>, <span class="string">&quot;oh&quot;</span>) &#123; <span class="comment">/* do other stuff*/</span> &#125;</span><br><span class="line">Notes::Notes(<span class="keyword">int</span> kk) : Notes(kk, <span class="number">0.01</span>, <span class="string">&quot;oh&quot;</span>) &#123; <span class="comment">/* do other stuff*/</span> &#125;</span><br><span class="line">Notes::Notes(<span class="keyword">int</span> kk, <span class="keyword">double</span> xx) : Notes(kk, xx, <span class="string">&quot;oh&quot;</span>) &#123; <span class="comment">/* do other stuff*/</span> &#125;</span><br></pre></td></tr></table></figure><p>使用委托构造函数，会多发生一次构造函数的调用，这将会影响运行效率，好处在于能提高开发效率。</p><h2 id="4-Lambda函数"><a href="#4-Lambda函数" class="headerlink" title="4. Lambda函数"></a>4. Lambda函数</h2><p>C++11 新增Lambda函数，其格式如下：</p><blockquote><p>[捕捉列表] (参数) mutable -&gt; 返回值类型 {函数体}</p></blockquote><p>说明：</p><ul><li><p>[]是lambda的引出符，捕捉列表能够捕捉上下文中的变量，来供lambda函数使用：</p><ul><li>[var] 表示以值传递方式捕捉变量var</li><li>[=] 表示值传递捕捉所有父作用域变量</li><li>[&amp;var] 表示以引用传递方式捕捉变量var</li><li>[&amp;] 表示引用传递捕捉所有父作用域变量</li><li>[this] 表示值传递方式捕捉当前的this指针</li><li>还有一些组合：</li><li>[=,&amp;a] 表示以引用传递方式捕捉a,值传递方式捕捉其他变量</li><li>注意：</li><li>捕捉列表不允许变量重复传递，如：[=,a]、[&amp;,&amp;this]，会引起编译时期的错误</li></ul></li><li><p>参数列表与普通函数的参数列表一致。如果不需要传递参数，可以联连同()一同【省略】。</p></li><li>mutable 可以取消Lambda的常量属性，因为Lambda默认是const属性；multable仅仅是让Lamdba函数体修改值传递的变量，但是修改后并不会影响外部的变量。</li><li>-&gt;返回类型如果是void时，可以连-&gt;一起【省略】，如果返回类型很明确，可以省略，让编译器自动推倒类型。</li><li>函数体和普通函数一样，除了可以使用参数之外，还可以使用捕获的变量。</li></ul><p>从C++11开始，Lambda被广泛用在STL中，比如foreach。与函数指针比起来，函数指针有巨大的缺陷：1.函数定义在别处，阅读起来很困难；2.使用函数指针，很可能导致编译器不对其进行inline优化，循环次数太多时，函数指针和Lambda比起来性能差距太大。函数2指针不能应用在一些运行时才能决定的状态，在没有C++11时，只能用仿函数。使得学习STL算法的代价大大降低。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-新功能&quot;&gt;&lt;a href=&quot;#1-新功能&quot; class=&quot;headerlink&quot; title=&quot;1. 新功能&quot;&gt;&lt;/a&gt;1. 新功能&lt;/h2&gt;&lt;h3 id=&quot;1-1-新类型&quot;&gt;&lt;a href=&quot;#1-1-新类型&quot; class=&quot;headerlink&quot; title=&quot;1.1 新类型&quot;&gt;&lt;/a&gt;1.1 新类型&lt;/h3&gt;&lt;p&gt;新增类型 long long 和 unsigned long long，以支持64位（或更宽）的整型；新增类型 char16_t 和 char32_t，以支持16位和32位的字符表示。&lt;/p&gt;
&lt;h3 id=&quot;1-2-统一的初始化&quot;&gt;&lt;a href=&quot;#1-2-统一的初始化&quot; class=&quot;headerlink&quot; title=&quot;1.2 统一的初始化&quot;&gt;&lt;/a&gt;1.2 统一的初始化&lt;/h3&gt;</summary>
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="c++11" scheme="http://example.com/tags/c-11/"/>
    
  </entry>
  
  <entry>
    <title>c++ 编译与链接</title>
    <link href="http://example.com/c-c/cpp-compilie-link/"/>
    <id>http://example.com/c-c/cpp-compilie-link/</id>
    <published>2020-09-22T04:00:48.000Z</published>
    <updated>2020-09-22T07:02:29.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-编译系统"><a href="#1-编译系统" class="headerlink" title="1. 编译系统"></a>1. 编译系统</h2><p>从源码文件到可执行程序是如何实现的呢？下面写个简单的程序来进行说明。<br>以下是一个 hello.c 程序：</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Linux系统上，由编译器把源文件转换为可执行文件的命令如下：</p><blockquote><p>gcc hello.c -o hello</p></blockquote><p>这是gcc编译器一步到位将源文件编译成了可执行文件，其中省略了的几个步骤，由gcc编译器自动执行。我们拆开来看，整个编译分为四个步骤：</p><blockquote><p>1-&gt; gcc -E hello.c -o hello.i<br>2-&gt; gcc -S hello.i -o hello.s<br>3-&gt; gcc -c hello.s -o hello.o<br>4-&gt; gcc hello.o -o hello</p></blockquote><p>步骤1：<strong>预处理阶段</strong>，处理以 # 开头的预处理命令；<br>步骤2：<strong>编译阶段</strong>，翻译成汇编文件；<br>步骤3：<strong>汇编阶段</strong>，将汇编文件翻译成可重定位目标文件（.o文件）；<br>步骤4：<strong>链接阶段</strong>，将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。<br><img src="https://qqadapt.qpic.cn/txdocpic/0/8a5e60d8034df3a7be257782321abbca/0" alt="compilie&amp;link"><br>以上就是编译链接成可执行文件的过程，下面介绍两种链接方式：<strong>静态链接</strong>和<strong>动态链接</strong>。</p><h2 id="2-静态链接"><a href="#2-静态链接" class="headerlink" title="2. 静态链接"></a>2. 静态链接</h2><h3 id="2-1-为什么需要静态链接"><a href="#2-1-为什么需要静态链接" class="headerlink" title="2.1 为什么需要静态链接"></a>2.1 为什么需要静态链接</h3><p>在实际开发中，我们不可能把所有的代码都写在一个源文件中，所以会出现很多源文件。这些源文件并非是独立的，而是有一定的依赖关系，如一个源文件需要调用另一个源文件中的函数，但是每个源文件都是独立编译的，即每个 <strong>.c</strong> 将会编译成对应的 <strong>.o</strong> 文件，那么就需要将这些目标文件进行链接，从而生成一个可执行文件，这个过程就是静态链接。</p><h3 id="2-2-静态链接的过程"><a href="#2-2-静态链接的过程" class="headerlink" title="2.2 静态链接的过程"></a>2.2 静态链接的过程</h3><p>在Linux中，静态链接库以 .a 为文件后缀，如 libc.a 为 c语言的静态链接库。<br>在示例程序中，调用了 stdio.h 中的 printf 函数，在 libc.a 中找到 printf.o 和它的依赖目标文件，然后将这些依赖文件和我们的 hello.o 文件链接打包成一个可执行文件，过程如下图：<br><img src="https://qqadapt.qpic.cn/txdocpic/0/830e5f24d85ce1067c6bc9125e003bc9/0" alt="static"></p><h3 id="2-3-静态链接的优缺点"><a href="#2-3-静态链接的优缺点" class="headerlink" title="2.3 静态链接的优缺点"></a>2.3 静态链接的优缺点</h3><p><strong>优点：</strong></p><ol><li>因为可执行程序中已经具备了执行程序所需要的所有东西，所以程序加载速度快，执行速度也快。</li><li>只需要保证开发者计算机上有正确的 .a 文件，在发布可执行程序时，不需要考虑发布机器上是否存在 .a 文件。</li></ol><p><strong>缺点：</strong></p><ol><li>使用静态链接生成的可执行文件体积较大，包含了相同的公共代码，造成空间浪费。</li><li>更新困难，如果静态库文件更新，需要重新编译链接整个可执行文件，再行发布。</li></ol><h2 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h2><p>为了解决静态链接的缺点，就需要使用到动态链接。<br>在Linux中，动态链接库以 .so 为文件后缀。<br>动态链接的思想就是将程序按照模块拆分为各个相对独立的部分，在程序运行时才将它们链接在一起形成完整的程序。<br><img src="https://qqadapt.qpic.cn/txdocpic/0/4f8013511ac6fbf141ebdfe1a1d065aa/0" alt="mem"><br><strong>优点：</strong></p><ol><li>更加节省内存并减少页面交换。</li><li>更新方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。</li><li>可是实现进程之间的资源共享。</li></ol><p><strong>缺点：</strong></p><ol><li>当某个动态库更新后，如果依赖该动态库的程序与更新后的动态库不兼容，则该程序将无法正常执行。</li><li>因为是运行时加载，所以相对于静态链接，性能会有所下降。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-编译系统&quot;&gt;&lt;a href=&quot;#1-编译系统&quot; class=&quot;headerlink&quot; title=&quot;1. 编译系统&quot;&gt;&lt;/a&gt;1. 编译系统&lt;/h2&gt;&lt;p&gt;从源码文件到可执行程序是如何实现的呢？下面写个简单的程序来进行说明。&lt;br&gt;以下是一个 hello.c 程序：&lt;/p&gt;</summary>
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="编译" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91/"/>
    
    <category term="链接" scheme="http://example.com/tags/%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL库底层数据结构</title>
    <link href="http://example.com/c-c/cpp-STL-brief/"/>
    <id>http://example.com/c-c/cpp-STL-brief/</id>
    <published>2020-09-22T03:56:39.000Z</published>
    <updated>2020-09-22T07:02:22.563Z</updated>
    
    <content type="html"><![CDATA[<p>STL容器可以分为以下几大类：<br>① 序列容器：vector、list、deque、string<br>② 关联容器：set、multiset、unorderd_set、unorderd_multiset、map、multimap、unorderd_map、unorderd_multimap<br>③ 其他容器：stack、queue、valarray、bitset<br><a id="more"></a></p><h2 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h2><p>内部数据结构：<strong>数组</strong>。<br>vector 数组动态增加大小，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对 vector 的任何操作，一旦引起空间重新配置，同时指向原vector 的所有迭代器就都失效了。<br>vector 常用来保存需要经常进行随机访问的内容，并且不需要经常对中间元素进行添加删除操作。</p><h2 id="2-list"><a href="#2-list" class="headerlink" title="2. list"></a>2. list</h2><p>内部数据结构：<strong>环状双向链表</strong>。<br>不能随机访问元素，可双向遍历。增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。</p><h2 id="3-deque"><a href="#3-deque" class="headerlink" title="3. deque"></a>3. deque</h2><p>内部数据结构：<strong>数组</strong>。<br>deque 是支持向两端高效地插入数据、支持随机访问的容器。deque 的数据被表示为一个分段数组，容器中的元素分段存放在一个个大小固定的数组中，此外容器还需要维护一个存放这些数组首地址的索引数组。</p><p>总结：<br>1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用 vector；<br>2、如果你需要大量的插入和删除，而不关心随即存取，则应使用 list；<br>3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用 deque。</p><h2 id="4-stack"><a href="#4-stack" class="headerlink" title="4. stack"></a>4. stack</h2><p>内部数据结构：底层以某种容器（ <strong>list 或 deque（缺省）</strong>）作为数据结构。<br>stack 是一种先进后出（FILO）的数据结构。它只有一个出口，stack 允许新增元素，移除元素，取得最顶端元素。但除了最顶端外，没有任何其它方法可以存取stack的其它元素，stack不允许遍历行为。<br>缺省情况下以 deque 作为底部数据结构，并封闭其头端开口，便能实现一个 deuqe。</p><h2 id="5-queue"><a href="#5-queue" class="headerlink" title="5. queue"></a>5. queue</h2><p>内部数据结构：底层以某种容器（ <strong>list 或 deque（缺省）</strong>）作为数据结构。<br>queue 是一种先进先出（First In First Out,FIFO）的数据结构。它有两个出口，queue 允许新增元素，移除元素，从最底端加入元素，取得最顶端元素。但除了最底端可以加入，最顶端可以取出外，没有任何其它方法可以存取 queue 的其它元素。<br>缺省情况下以 deque 作为底部数据结构，并封闭其头端入口和尾端出口，便能实现一个 queue。</p><p>stack 和 queue 其实是适配器，而不叫容器，因为是对容器的再封装。</p><h2 id="6-set和multiset"><a href="#6-set和multiset" class="headerlink" title="6. set和multiset"></a>6. set和multiset</h2><p>内部数据结构：<strong>RB-tree</strong>。<br>set 底层是通过红黑树（RB-tree）来实现的，由于红黑树是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的 STL 的 set 即以 RB-Tree 为底层机制。又由于 set 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 set 操作行为，都只有转调用 RB-tree 的操作行为而已。<br>multiset的特性以及用法和 set 完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制是 RB-tree 的 insert_equal() 而非 insert_unique()。</p><h2 id="7-map和multimap"><a href="#7-map和multimap" class="headerlink" title="7. map和multimap"></a>7. map和multimap</h2><p>内部数据结构：<strong>RB-tree</strong>。<br>与set的结构一样，都是使用 RB-tree 实现的，只不过map的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。<br>multimap 的特性以及用法与 map 完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制 RB-tree 的 insert_equal() 而非 insert_unique。</p><h2 id="8-unordered-set和unordered-multiset"><a href="#8-unordered-set和unordered-multiset" class="headerlink" title="8. unordered_set和unordered_multiset"></a>8. unordered_set和unordered_multiset</h2><p>内部数据结构：<strong>hash table</strong>。<br>底层由哈希表实现。无序，查找元素的时间复杂度为常数。</p><h2 id="9-unordered-map和unordered-multimap"><a href="#9-unordered-map和unordered-multimap" class="headerlink" title="9. unordered_map和unordered_multimap"></a>9. unordered_map和unordered_multimap</h2><p>内部数据结构：<strong>hash table</strong>。<br>底层由哈希表实现。无序，查找元素的时间复杂度为常数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;STL容器可以分为以下几大类：&lt;br&gt;① 序列容器：vector、list、deque、string&lt;br&gt;② 关联容器：set、multiset、unorderd_set、unorderd_multiset、map、multimap、unorderd_map、unorderd_multimap&lt;br&gt;③ 其他容器：stack、queue、valarray、bitset&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="stl" scheme="http://example.com/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-网络通信</title>
    <link href="http://example.com/Redis/4-net/redis-parse-networking/"/>
    <id>http://example.com/Redis/4-net/redis-parse-networking/</id>
    <published>2020-09-22T03:21:08.000Z</published>
    <updated>2020-09-22T03:30:51.494Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：anet.c/anet.h/networking.c</p><p><strong>1. 简介</strong><br>Redis在<code>anet.c</code>中对TCP/IP网络中socket api接口和状态设置进行了封装。状态设置主要包括socket连接的阻塞性、tcp的保活定时器的设置、设置发送缓冲区、tcp的nagle算法设置、设置发送/接收超时时间、地址重用的设置和IPv6/IPv4的设置等。<br>Redis网络通讯的具体实现在<code>networking.c</code>中，主要包括如何建立和客户端的连接，并且接收其命令，返回给客户端。</p><a id="more"></a><p><strong>2. 回顾tcp socket编程</strong><br>2.1 TCP客户/服务器程序socket编程流程如下：<br><img src="/Redis/4-net/redis-parse-networking/socket.png" alt="socket"></p><p>2.2 TCP的三次握手<br><img src="/Redis/4-net/redis-parse-networking/tcp_handshake.png" alt="handshake"></p><p>2.3 TCP的四次挥手<br>TCP的断开连接操作可由<strong>任意一端发起</strong><br><img src="/Redis/4-net/redis-parse-networking/tcp_close.png" alt="close"></p><p><strong>3. anet解析</strong><br>anet.h中定义的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port)</span></span>; <span class="comment">// tcp连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port)</span></span>; <span class="comment">// TCP非阻塞连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockBindConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *source_addr)</span></span>; <span class="comment">// TCP非阻塞绑定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockBestEffortBindConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *source_addr)</span></span>; <span class="comment">// TCP非阻塞绑定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">// unix socket连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixNonBlockConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">// unix socket非阻塞连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetRead</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span>; <span class="comment">// socket读数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetResolve</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *host, <span class="keyword">char</span> *ipbuf, <span class="keyword">size_t</span> ipbuf_len)</span></span>; <span class="comment">// 解析所有的东西</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetResolveIP</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *host, <span class="keyword">char</span> *ipbuf, <span class="keyword">size_t</span> ipbuf_len)</span></span>; <span class="comment">// 解析IP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// IPv4下创建socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcp6Server</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// IPv6下创建socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> perm, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// unix创建socket和bind</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> serversock, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// tcp socket接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> serversock)</span></span>; <span class="comment">// unix tcp socket接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetWrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span>; <span class="comment">// socket写数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetNonBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置socket为非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置socket为阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetEnableTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 启用tcp_nodelay选项（关闭Nagle算法）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetDisableTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 禁用tcp_nodelay选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置tcp keepalive选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetSendTimeout</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> ms)</span></span>; <span class="comment">// 设置发送超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetRecvTimeout</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> ms)</span></span>; <span class="comment">// 设置接收超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetPeerToString</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// 获取客户端的ip、port</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">int</span> interval)</span></span>; <span class="comment">// 设置tcp keepalive选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetSockName</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// 获取套接字的名字</span></span><br><span class="line"><span class="comment">/* 格式化操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatAddr</span><span class="params">(<span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len, <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatPeer</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatSock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len)</span></span>;</span><br></pre></td></tr></table></figure><p>Redis服务启动后会调用<code>server.c/listenToPort()</code>进行socket相关的设置和端口监听。如果服务器配置不包含要绑定的特定地址，则该函数会尝试IPv6（调用<code>anetTcp6Server()</code>）和IPv4（调用<code>anetTcpServer()</code>）协议进行绑定。<br>不管是使用IPv6还是IPv4协议，最终调用的都是<code>_anetTcpServer()</code>来创建socket并进行绑定监听，以下是该函数的实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _anetTcpServer(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> af, <span class="keyword">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">-1</span>, rv;</span><br><span class="line">    <span class="keyword">char</span> _port[<span class="number">6</span>];  <span class="comment">/* strlen(&quot;65535&quot;) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">servinfo</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(_port,<span class="number">6</span>,<span class="string">&quot;%d&quot;</span>,port);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = af;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE;    <span class="comment">/* No effect if bindaddr != NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将域名解析成ip地址</span></span><br><span class="line">    <span class="keyword">if</span> ((rv = getaddrinfo(bindaddr,_port,&amp;hints,&amp;servinfo)) != <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;%s&quot;</span>, gai_strerror(rv));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = servinfo; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = socket(p-&gt;ai_family,p-&gt;ai_socktype,p-&gt;ai_protocol)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (af == AF_INET6 &amp;&amp; anetV6Only(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// 设置SO_REUSEADDR允许我们重复bind相同的本地地址</span></span><br><span class="line">        <span class="keyword">if</span> (anetSetReuseAddr(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// bind &amp;&amp; listen</span></span><br><span class="line">        <span class="keyword">if</span> (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;unable to bind socket, errno: %d&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">-1</span>) close(s);</span><br><span class="line">    s = ANET_ERR;</span><br><span class="line">end:</span><br><span class="line">    freeaddrinfo(servinfo);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. networking解析</strong><br>新版本Redis增加了多线程I/O来改进读写缓冲区的性能，而不是改进命令执行的性能主要原因是：</p><ol><li>读写缓冲区在命令执行的生命周期中是占了比较大的比重</li><li>Redis更倾向于保持简单的设计，如果在命令执行部分改用多线程会不得不处理各种问题，例如并发写入、加锁等</li></ol><p>那么将读写缓冲区改为多线程后整个模型大致如下：<br><img src="/Redis/4-net/redis-parse-networking/thread-io.png" alt="thread-io"></p><p>4.1 线程初始化<br>首先，如果用户没有开启多线程IO，也就是io_threads_num == 1时直接按照单线程模型处理，如果超过线程数IO_THREADS_MAX_NUM上限则异常退出。</p><p>紧接着Redis使用listCreate()创建io_threads_num个线程，并且对主线程（id=0）以外的线程进行处理：</p><ul><li>初始化线程的等待任务数为0</li><li>获取锁，使得线程不能进行操作</li><li>将线程tid与Redis中的线程id（for循环生成）进行映射</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    io_threads_active = <span class="number">0</span>; <span class="comment">/* We start with threads not active. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果io_threads_num为1，则按照单线程模型处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程数设置超过上限</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num &gt; IO_THREADS_MAX_NUM) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal: too many I/O threads configured. &quot;</span></span><br><span class="line">                             <span class="string">&quot;The maximum number is %d.&quot;</span>, IO_THREADS_MAX_NUM);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 生成并初始化对应 io_threads_num 个I/O线程 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; server.io_threads_num; i++) &#123;</span><br><span class="line">        io_threads_list[i] = listCreate();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* 0为主线程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 非主线程则需要以下处理 */</span></span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">// 为线程初始化对应的锁</span></span><br><span class="line">        pthread_mutex_init(&amp;io_threads_mutex[i],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 线程等待状态初始化为0</span></span><br><span class="line">        io_threads_pending[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化后将线程暂时锁住</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[i]); <span class="comment">/* Thread will be stopped. */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid,<span class="literal">NULL</span>,IOThreadMain,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Fatal: Can&#x27;t initialize IO thread.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将index和对应线程ID加以映射</span></span><br><span class="line">        io_threads[i] = tid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2 建立连接<br>Redis服务端会初始化一个socket端口来监听客户端的连接，当一个连接建立后，服务端会对客户端的socket进行设置：</p><ol><li>客户端socket设置为非阻塞模式，因为Redis采用的是非阻塞I/O多路复用模型。</li><li>客户端socket设置为 TCP_NODELAY 属性，禁用 Nagle 算法。</li><li>将该socket绑定读事件到时间loop，用于监听这个客户端socket的数据发送。</li><li>建立连接后如果发现已经超过最大连接数，则关闭连接，删除该客户端socket。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当conn为NULL时，创建无网络连接的伪客户端</span></span><br><span class="line"><span class="comment">     * 当conn不为NULL时，创建带网络连接的客户端</span></span><br><span class="line"><span class="comment">     * 因为 Redis 的命令必须在客户端的上下文中使用，所以在执行 Lua 环境中的命令时</span></span><br><span class="line"><span class="comment">     * 需要用到这种伪终端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (conn) &#123;</span><br><span class="line">        <span class="comment">// 设置非阻塞</span></span><br><span class="line">        connNonBlock(conn);</span><br><span class="line">        <span class="comment">// 禁用tcp_nodelay</span></span><br><span class="line">        connEnableTcpNoDelay(conn);</span><br><span class="line">        <span class="comment">// 设置 keep alive</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            connKeepAlive(conn,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 绑定读事件和处理函数到事件loop（开始接收命令请求）</span></span><br><span class="line">        connSetReadHandler(conn, readQueryFromClient);</span><br><span class="line">        <span class="comment">// 将私有数据指针与连接相关联</span></span><br><span class="line">        connSetPrivateData(conn, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化客户端参数</span></span><br><span class="line">    selectDb(c,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> client_id = ++server.next_client_id;</span><br><span class="line">    c-&gt;id = client_id;</span><br><span class="line">    c-&gt;resp = <span class="number">2</span>;</span><br><span class="line">    c-&gt;conn = conn;</span><br><span class="line">    c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">    c-&gt;qb_pos = <span class="number">0</span>;</span><br><span class="line">    c-&gt;querybuf = sdsempty();</span><br><span class="line">    c-&gt;pending_querybuf = sdsempty();</span><br><span class="line">    c-&gt;querybuf_peak = <span class="number">0</span>;</span><br><span class="line">    c-&gt;reqtype = <span class="number">0</span>;</span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    c-&gt;argv = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;user = DefaultUser;</span><br><span class="line">    c-&gt;multibulklen = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">    c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">    c-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">/* If the default user does not require authentication, the user is</span></span><br><span class="line"><span class="comment">     * directly authenticated. */</span></span><br><span class="line">    c-&gt;authenticated = (c-&gt;user-&gt;flags &amp; USER_FLAG_NOPASS) != <span class="number">0</span>;</span><br><span class="line">    c-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line">    c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    c-&gt;reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;read_reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_off = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_time = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_listening_port = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_ip[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    c-&gt;slave_capa = SLAVE_CAPA_NONE;</span><br><span class="line">    c-&gt;reply = listCreate();</span><br><span class="line">    c-&gt;reply_bytes = <span class="number">0</span>;</span><br><span class="line">    c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line">    listSetFreeMethod(c-&gt;reply,freeClientReplyValue);</span><br><span class="line">    listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span><br><span class="line">    c-&gt;btype = BLOCKED_NONE;</span><br><span class="line">    c-&gt;bpop.timeout = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.keys = dictCreate(&amp;objectKeyHeapPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_group = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_consumer = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_group_noack = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.numreplicas = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.reploffset = <span class="number">0</span>;</span><br><span class="line">    c-&gt;woff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;watched_keys = listCreate();</span><br><span class="line">    c-&gt;pubsub_channels = dictCreate(&amp;objectKeyPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    c-&gt;pubsub_patterns = listCreate();</span><br><span class="line">    c-&gt;peerid = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;client_list_node = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;client_tracking_redirection = <span class="number">0</span>;</span><br><span class="line">    c-&gt;client_tracking_prefixes = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_callback = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_callback_privdata = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_module = <span class="literal">NULL</span>;</span><br><span class="line">    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</span><br><span class="line">    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</span><br><span class="line">    <span class="keyword">if</span> (conn) linkClient(c); <span class="comment">// 如果不是伪客户端，那么添加到服务器的客户端链表中</span></span><br><span class="line">    initClientMultiState(c); <span class="comment">// 初始化客户端的事务状态</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.3 读事件到来<br>读事件到来，Redis需要判断是否满足Threaded IO条件。如果符合，则将client放到等待读取的队列中，并将client的flag设置为等待读取；如果不符合，则按照单线程模型往下继续处理。<br>等待读取队列由server维护，包含了所有处于读事件pending的客户端列表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取客户端结构体</span></span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果启动了 I/O 线程，则将客户端加到server.clients_pending_read列表中 */</span></span><br><span class="line">    <span class="keyword">if</span> (postponeClientRead(c)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    readlen = PROTO_IOBUF_LEN; <span class="comment">// 通用缓冲区大小 1024*16</span></span><br><span class="line">    <span class="comment">/* 如果是批量请求，则需要提高缓冲区的大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> remaining = (<span class="keyword">size_t</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在某些边缘情况下，“remaining”变量可能为零，例如，在客户端暂停后恢复被阻塞的客户端。 */</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &gt; <span class="number">0</span> &amp;&amp; remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取缓冲区内当前内容的长度</span></span><br><span class="line"><span class="comment">     * 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span></span><br><span class="line"><span class="comment">     * 这些滞留内容也许不能完整构成一个符合协议的命令 */</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen); <span class="comment">// 扩容querybuf的大小</span></span><br><span class="line">    nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen); <span class="comment">// 读取内容到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取错误</span></span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE, <span class="string">&quot;Reading from client: %s&quot;</span>,connGetLastError(c-&gt;conn));</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF</span></span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">&quot;Client closed connection&quot;</span>);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) &#123;</span><br><span class="line">        <span class="comment">/* 将缓冲区内的内容追加到pending缓冲区中，稍后将使用这个缓冲区，以便在执行最后一个命令时应用字符串的副本 */</span></span><br><span class="line">        c-&gt;pending_querybuf = sdscatlen(c-&gt;pending_querybuf,</span><br><span class="line">                                        c-&gt;querybuf+qblen,nread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据内容，更新查询缓冲区（SDS） free 和 len 属性</span></span><br><span class="line">    <span class="comment">// 并将 &#x27;\0&#x27; 正确地放到内容的最后</span></span><br><span class="line">    sdsIncrLen(c-&gt;querybuf,nread);</span><br><span class="line">    <span class="comment">// 记录服务器和客户端最后一次互动的时间</span></span><br><span class="line">    c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 如果客户端是 master 的话，更新它的复制偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) c-&gt;read_reploff += nread;</span><br><span class="line">    server.stat_net_input_bytes += nread;</span><br><span class="line">    <span class="comment">// 查询缓冲区长度超出服务器最大缓冲区长度</span></span><br><span class="line">    <span class="comment">// 清空缓冲区并释放客户端</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;</span>, ci, bytes);</span><br><span class="line">        sdsfree(ci);</span><br><span class="line">        sdsfree(bytes);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 客户端输入缓冲区中有更多数据，继续分析以防有完整的命令要执行. */</span></span><br><span class="line">     processInputBufferAndReplicate(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开启了Threaded-IO，如何分配读取pending的client给thread呢？<code>handleClientsWithPendingReadsUsingThreads()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingReadsUsingThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!io_threads_active || !server.io_threads_do_reads) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查有多少等待读的client</span></span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;%d TOTAL READ pending clients\n&quot;</span>, processed);</span><br><span class="line"></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将每个等待的client分配给线程，当等待长度超过线程数时，每个线程分配到的client可能会超过1个</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改每个线程需要完成的数量 */</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_READ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        io_threads_pending[j] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 也可以使用主线程来处理客户端的一部分 */</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        readQueryFromClient(c-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待线程处理直到没有剩余任务 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += io_threads_pending[j];</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;I/O READ All threads finshed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次运行客户端列表以处理新的缓冲区 */</span></span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) &#123;</span><br><span class="line">            c-&gt;flags &amp;= ~ CLIENT_PENDING_COMMAND;</span><br><span class="line">            processCommandAndResetClient(c);</span><br><span class="line">        &#125;</span><br><span class="line">        processInputBufferAndReplicate(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空client_pending_read</span></span><br><span class="line">    listEmpty(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何处理读请求？<br>在上面的过程中，当任务分发完毕后，每个线程按照正常流程将自己负责的Client的读取缓冲区的内容进行处理，和原来的单线程没有太大差异。</p><p>每轮处理中，需要将各个线程的锁开启，打开标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) &#123; <span class="built_in">printf</span>(<span class="string">&quot;S&quot;</span>); fflush(<span class="built_in">stdout</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;--- STARTING THREADED IO ---\n&quot;</span>);</span><br><span class="line">    serverAssert(io_threads_active == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">        <span class="comment">// 解开线程的锁定状态</span></span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[j]);</span><br><span class="line">    <span class="comment">// 现在可以开始多线程IO执行对应读/写任务</span></span><br><span class="line">    io_threads_active = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样结束时，首先需要检查是否有剩余待读的IO，如果没有，将线程锁定，标志关闭：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要停止的时候可能还有等待读的Client 在停止前进行处理</span></span><br><span class="line">    handleClientsWithPendingReadsUsingThreads();</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) &#123; <span class="built_in">printf</span>(<span class="string">&quot;E&quot;</span>); fflush(<span class="built_in">stdout</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;--- STOPPING THREADED IO [R%d] [W%d] ---\n&quot;</span>,</span><br><span class="line">        (<span class="keyword">int</span>) listLength(server.clients_pending_read),</span><br><span class="line">        (<span class="keyword">int</span>) listLength(server.clients_pending_write));</span><br><span class="line">    serverAssert(io_threads_active == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">        <span class="comment">// 本轮IO结束 将所有线程上锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[j]);</span><br><span class="line">    <span class="comment">// IO状态设置为关闭</span></span><br><span class="line">    io_threads_active = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.3 写入返回缓冲区<br>众多的<code>addReply*()</code>方法最终会调用<code>_addReplyToBuffer()</code>函数在缓冲区中添加回复数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _addReplyToBuffer(client *c, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> available = <span class="keyword">sizeof</span>(c-&gt;buf)-c-&gt;bufpos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正准备关闭客户端，无需回复任何内容</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果回复列表中已经有内容，则无法向静态缓冲区添加更多内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;reply) &gt; <span class="number">0</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查缓冲区是否有足够的空间用于该字符串 */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; available) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内容追加到c-&gt;buf中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;buf+c-&gt;bufpos,s,len);</span><br><span class="line">    c-&gt;bufpos+=len;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用<code>_addReplyToBuffer()</code>函数失败，将会调用另一个函数<code>_addReplyProtoToList()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _addReplyProtoToList(client *c, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    listNode *ln = listLast(c-&gt;reply);</span><br><span class="line">    clientReplyBlock *tail = ln? listNodeValue(ln): <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that &#x27;tail&#x27; may be NULL even if we have a tail node, becuase when</span></span><br><span class="line"><span class="comment">     * addDeferredMultiBulkLength() is used, it sets a dummy node to NULL just</span></span><br><span class="line"><span class="comment">     * fo fill it later, when the size of the bulk length is set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Append to tail string when possible. */</span></span><br><span class="line">    <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">        <span class="comment">/* Copy the part we can fit into the tail, and leave the rest for a</span></span><br><span class="line"><span class="comment">         * new node */</span></span><br><span class="line">        <span class="keyword">size_t</span> avail = tail-&gt;size - tail-&gt;used;</span><br><span class="line">        <span class="keyword">size_t</span> copy = avail &gt;= len? len: avail;</span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf + tail-&gt;used, s, copy);</span><br><span class="line">        tail-&gt;used += copy;</span><br><span class="line">        s += copy;</span><br><span class="line">        len -= copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        <span class="comment">/* Create a new node, make sure it is allocated to at</span></span><br><span class="line"><span class="comment">         * least PROTO_REPLY_CHUNK_BYTES */</span></span><br><span class="line">        <span class="keyword">size_t</span> size = len &lt; PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;</span><br><span class="line">        tail = zmalloc(size + <span class="keyword">sizeof</span>(clientReplyBlock));</span><br><span class="line">        <span class="comment">/* take over the allocation&#x27;s internal fragmentation */</span></span><br><span class="line">        tail-&gt;size = zmalloc_usable(tail) - <span class="keyword">sizeof</span>(clientReplyBlock);</span><br><span class="line">        tail-&gt;used = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf, s, len);</span><br><span class="line">        listAddNodeTail(c-&gt;reply, tail);</span><br><span class="line">        c-&gt;reply_bytes += tail-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    asyncCloseClientOnOutputBufferLimitReached(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：anet.c/anet.h/networking.c&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 简介&lt;/strong&gt;&lt;br&gt;Redis在&lt;code&gt;anet.c&lt;/code&gt;中对TCP/IP网络中socket api接口和状态设置进行了封装。状态设置主要包括socket连接的阻塞性、tcp的保活定时器的设置、设置发送缓冲区、tcp的nagle算法设置、设置发送/接收超时时间、地址重用的设置和IPv6/IPv4的设置等。&lt;br&gt;Redis网络通讯的具体实现在&lt;code&gt;networking.c&lt;/code&gt;中，主要包括如何建立和客户端的连接，并且接收其命令，返回给客户端。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="4-net" scheme="http://example.com/categories/Redis/4-net/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-事件驱动</title>
    <link href="http://example.com/Redis/4-net/redis-parse-event/"/>
    <id>http://example.com/Redis/4-net/redis-parse-event/</id>
    <published>2020-09-22T03:19:42.000Z</published>
    <updated>2020-09-22T03:32:09.042Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：ae.c/ae.h/ae_evport.c/ae_epoll.c/ae_kqueue.c/ae_select.c</p><p><strong>1. 简介</strong><br>Redis 是一个事件驱动的内存数据库，服务器需要处理两种类型的事件：</p><ul><li>文本（IO）事件<code>AE_FILE_EVENTS</code></li><li>时间事件<code>AE_TIME_EVENTS</code></li></ul><a id="more"></a><p><strong>2. 文本（IO）事件</strong><br>Redis是基于 Reactor 模式开发了自己的网络事件处理器，这个处理器被称为文件事件处理器。</p><ul><li>文件事件处理器使用 I/O 多路复用（multiplexing）模型来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用模型来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。<br>优势：</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作。</li><li>使用多路I/O复用模型，非阻塞IO。</li></ul><p>Redis提供了4中 I/O 多路复用的方式，其性能由高到低依次是：<code>evport</code> -&gt; <code>epoll</code> -&gt; <code>kqueue</code> -&gt; <code>select</code>。<br>不同的平台使用了不同的实现方式，比如 epoll 和 select 可以用于Linux平台，kqueue 用于MacOS平台，select 用于Windows平台，evport 用于Solaris平台。<br>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_select.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>一般情况下，Redis服务端都是部署在Linux系统上的，所以本文内容就只解析Redis是怎么利用epoll实现 I/O 多路复用的吧。</p><p><strong>epoll：</strong><br>epoll相关的接口实现都封装在了ae_epoll.c中，主要提供了以下几个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 调用epoll_create创建epoll实例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span></span>; <span class="comment">// 重新设置epoll_event的大小</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 释放实例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>; <span class="comment">// 当有新的客户端连接时，将新的fd注册到epoll实例中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> delmask)</span></span>; <span class="comment">// 当有客户端断开连接时，将epoll实例中该客户端的fd删除</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span></span>; <span class="comment">// 调用epoll_wait获取客户端产生的io事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">aeApiName</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;epoll&quot;</span>; &#125;</span><br></pre></td></tr></table></figure><p>在redis.h/redisServer 结构中，保存着基于事件驱动的程序状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    aeEventLoop *el;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* 当前注册的最大fd */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* 最大fd数 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* 用于检测系统时钟偏差 */</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* 注册事件 */</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* 触发事件 */</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line">    <span class="keyword">int</span> stop;</span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* 用于轮询特定于API的数据 */</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line">    aeBeforeSleepProc *aftersleep;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure><p>Redis服务器在启动时，首先会创建事件轮询器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据不同平台调用不同的 I/O 多路复用模型</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成后，开始事件轮询主循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件的调度和执行函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果不处理时间事件或文本时间，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意，只要我们想处理时间事件，即使没有要处理的文件事件，我们也要调用select（），以便在下一个时间事件准备好触发之前休眠 */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            <span class="comment">// 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算剩余时间 */</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms =</span><br><span class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">                shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果我们必须检查事件，但由于AE_DONT_WAIT而需要尽快返回，我们需要将超时设置为0 */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 等待事件触发或者超时 */</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 阻塞后处理函数 */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果设置了AE_BARRIER标志，我们优先处理写事件 */</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理写事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果需要反转读写处理顺序，处理完写事件后，可以处理读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理时间事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* 返回处理的文本/时间事件数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 时间事件</strong><br>Redis有很多操作需要在给定的时间点进行处理，时间事件就是对这类定时任务的抽象。<br>先看看时间事件的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* 时间事件唯一标识符 */</span></span><br><span class="line">    <span class="comment">/* 事件的到达时间 */</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    <span class="comment">/* 事件处理函数 */</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    <span class="comment">/* 事件释放函数 */</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="comment">/* 多路复用库的私有数据 */</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line">    <span class="comment">/* 指向前、后两个时间事件结构，形成双向链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><p>处理时间事件的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</span><br><span class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 记录最新一次执行这个函数的时间，用于处理系统时间被修改产生的问题 */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span>(te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 2. 遍历链表找出所有 when_sec 和 when_ms 小于现在时间的事件。 */</span></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果当前的事件被设置为删除，则删除该事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</span><br><span class="line">            aeTimeEvent *next = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;prev)</span><br><span class="line">                te-&gt;prev-&gt;next = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;next)</span><br><span class="line">                te-&gt;next-&gt;prev = te-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line">            zfree(te);</span><br><span class="line">            te = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            <span class="comment">/* 3. 执行事件对应的处理函数 */</span></span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">/* 4. 检查事件类型，如果是周期事件则刷新该事件下一次的执行事件，否则从列表中删除事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong><br>为什么单线程的Redis会这么快？</p><ul><li>Redis是完全基于内存的数据库，绝大部分请求是纯粹的内存操作，非常快速。</li><li>Redis由C语言编写，数据结构简单，对数据的操作也简单，Redis中的数据结构是专门设计的。</li><li>Redis采用单线程，保证了数据操作的原子性，不存在多进程或者多线程导致切换而消耗CPU，避免了不必要的上下文切换和竞争条件，不存在加/解锁的操作，不用考虑可能出现的死锁导致性能消耗。</li><li>使用 I/O 多路复用模型，非阻塞IO，可以处理并发的连接。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：ae.c/ae.h/ae_evport.c/ae_epoll.c/ae_kqueue.c/ae_select.c&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 简介&lt;/strong&gt;&lt;br&gt;Redis 是一个事件驱动的内存数据库，服务器需要处理两种类型的事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本（IO）事件&lt;code&gt;AE_FILE_EVENTS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;时间事件&lt;code&gt;AE_TIME_EVENTS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="4-net" scheme="http://example.com/categories/Redis/4-net/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-事务</title>
    <link href="http://example.com/Redis/3-database/redis-parse-multi/"/>
    <id>http://example.com/Redis/3-database/redis-parse-multi/</id>
    <published>2020-09-22T03:17:54.000Z</published>
    <updated>2020-09-22T03:30:45.651Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：multi.c/redis.h</p><p><strong>1. 简介</strong><br>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><a id="more"></a><p>Redis事务的ACID特性：</p><p><strong>A原子性（atomicity）</strong><br>单个Redis命令的执行是原子性的，但Redis没有在事务上增加任何维护原子性的机制，所以<strong>Redis事务的执行不是原子性</strong>的。<br>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败<br>事务失败时，Redis 也不会进行任何的重试或者回滚动作，不满足要么全部全部执行，要么都不执行的条件</p><p><strong>C一致性（consistency）：</strong><br>一致性分下面几种情况来讨论：</p><p>首先，如果一个事务的指令全部被执行，那么数据库的状态是满足数据库完整性约束的</p><p>其次，如果一个事务中有的指令有错误，那么数据库的状态是满足数据完整性约束的</p><p>最后，如果事务运行到某条指令时，进程被kill掉了，那么要分下面几种情况讨论：</p><ul><li>如果当前redis采用的是内存模式，那么重启之后redis数据库是空的，那么满足一致性条件</li><li>如果当前采用RDB模式存储的，在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。 恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数 据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的</li><li>如果当前采用的是AOF存储的，那么可能事务的内容还未写入到AOF文件，那么此时肯定是满足一致性的，如果事务的内容有部分写入到AOF文件中，那么需要用工具把AOF中事务执行部分成功的指令移除，这时，移除之后的AOF文件也是满足一致性的</li></ul><p>所以，<strong>redis事务满足一致性约束</strong>。</p><p><strong>I隔离性（isolation）：</strong><br>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性</strong>的。</p><p><strong>D持久性（durability）：</strong><br>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定</p><ul><li>在单纯的内存模式下，事务肯定是不持久的</li><li>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的</li><li>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync 或 fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</li><li>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</li></ul><p><strong>2. 命令介绍</strong><br>下面介绍命令的使用详情：</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>MULTI</td><td>标记一个事务的开始</td></tr><tr><td>DISCARD</td><td>取消事务，放弃执行事务块内的所有命令</td></tr><tr><td>EXEC</td><td>执行事务内的所有命令</td></tr><tr><td>WATCH key [key …]</td><td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断，不会被执行</td></tr><tr><td>UNWATCH</td><td>取消 WATCH 命令对所有 key 的监视</td></tr></tbody></table></div><p><strong>3. 实现细节</strong><br>Redis事务从开始到结束通常分为三步：</p><ol><li>事务开始(MULTI)：MULTI命令可以将执行该命令的客户端从非事务状态切换成事务状态，这一切换是通过客户端状态的flags属性中打开 <code>CLIENT_MULTI</code> 标识完成的。</li><li>命令入队：切换到事务状态后，该客户端输入的所有命令，都会被暂存到一个命令队列里，不会立即执行。</li><li>事务执行(EXEX)：EXEC命令将命令队列里的命令挨个执行完成。</li></ol><p>Redis会把每个连接的客户端封装成一个client结构体，该结构体包含大量的字段用来保存需要的信息。其中，事务相关的字段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    multiState mstate;</span><br><span class="line">    <span class="built_in">list</span> *watched_keys; <span class="comment">// 监视的key列表（节点结构：watchedKey）</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Client MULTI/EXEC state */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    robj **argv;    <span class="comment">/* 参数 */</span></span><br><span class="line">    <span class="keyword">int</span> argc;       <span class="comment">/* 参数数量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span>   <span class="comment">/* 命令本身 */</span></span><br><span class="line">&#125; multiCmd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">/* 事务命令队列 */</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">/* 队列中命令的数量 */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">int</span> minreplicas;        <span class="comment">/* 需要同步复制的最小数量 */</span></span><br><span class="line">    <span class="keyword">time_t</span> minreplicas_timeout; <span class="comment">/* 同步复制超时时间 */</span></span><br><span class="line">&#125; multiState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视列表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchedKey</span> &#123;</span></span><br><span class="line">    robj *key;      <span class="comment">/* watch的key*/</span></span><br><span class="line">    redisDb *db;    <span class="comment">/* 指向的db */</span></span><br><span class="line">&#125; watchedKey;</span><br></pre></td></tr></table></figure><p>需要注意的是，客户端打开事务操作标识后，只有命令：EXEC、DISCARD、WATCH、MULTI命令会被立即执行，该逻辑在server.c文件中的processCommand方法中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Exec the command */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将命令插入队列</span></span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 立即执行</span></span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将命令插入队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    multiCmd *mc;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">            <span class="keyword">sizeof</span>(multiCmd)*(c-&gt;mstate.count+<span class="number">1</span>));</span><br><span class="line">    mc = c-&gt;mstate.commands+c-&gt;mstate.count;</span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv,c-&gt;argv,<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        incrRefCount(mc-&gt;argv[j]);</span><br><span class="line">    c-&gt;mstate.count++;</span><br><span class="line">    c-&gt;mstate.cmd_flags |= c-&gt;cmd-&gt;flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们考虑一下watch机制的触发时机，现在我们已经把想要watch的key加入到了watch的数据结构中，可以想到触发watch的时机应该是修改key的内容时，通知到所有watch了该key的客户端。该触发机制的源码在multi.c文件的<code>touchWatchedKey()</code>函数中实现。</p><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 设置客户端事务标识</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 执行命令队列中的命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 取消事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 监视一个或多个key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 取消监视</span></span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>事务开始：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;MULTI calls can not be nested&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置客户端的事务标识</span></span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行事务：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> must_propagate = <span class="number">0</span>; <span class="comment">// 标记是否需要把MULTI/EXEC传递到AOF或者slaves节点</span></span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>; <span class="comment">// 标记当前redis节点是否为主节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有处于事务状态，则返回错误提示信息</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;EXEC without MULTI&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先对两个需要终止当前事务的条件进行判断:</span></span><br><span class="line"><span class="comment">     * 1) 当有WATCH的key被修改时则终止，返回一个nullmultibulk对象</span></span><br><span class="line"><span class="comment">     * 2) 当之前有命令加入事务命令数组出错则终止，例如传入的命令参数数量不对，会返回execaborterr */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">        addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                                                   shared.nullarray[c-&gt;resp]);</span><br><span class="line">        <span class="comment">// 删除当前事务信息</span></span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">goto</span> handle_monitor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果事务命令中有写的操作，并且当前redis节点为只读slave节点，将返回错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (!server.loading &amp;&amp; server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; c-&gt;mstate.cmd_flags &amp; CMD_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;Transaction contains write commands but instance &quot;</span></span><br><span class="line">            <span class="string">&quot;is now a read-only replica. EXEC aborted.&quot;</span>);</span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">goto</span> handle_monitor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行队列中的所有命令 */</span></span><br><span class="line">    unwatchAllKeys(c); <span class="comment">/* 把watch的key都删除 */</span></span><br><span class="line">    <span class="comment">// 保存当前命令上下文</span></span><br><span class="line">    orig_argv = c-&gt;argv;</span><br><span class="line">    orig_argc = c-&gt;argc;</span><br><span class="line">    orig_cmd = c-&gt;cmd;</span><br><span class="line">    addReplyArrayLen(c,c-&gt;mstate.count);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 同步事务操作到AOF或者集群中的从节点. */</span></span><br><span class="line">        <span class="keyword">if</span> (!must_propagate &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; (CMD_READONLY|CMD_ADMIN))) &#123;</span><br><span class="line">            execCommandPropagateMulti(c);</span><br><span class="line">            must_propagate = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> acl_keypos;</span><br><span class="line">        <span class="keyword">int</span> acl_retval = ACLCheckCommandPerm(c,&amp;acl_keypos);</span><br><span class="line">        <span class="keyword">if</span> (acl_retval != ACL_OK) &#123;</span><br><span class="line">            addACLLogEntry(c,acl_retval,acl_keypos,<span class="literal">NULL</span>);</span><br><span class="line">            addReplyErrorFormat(c,</span><br><span class="line">                <span class="string">&quot;-NOPERM ACLs rules changed between the moment the &quot;</span></span><br><span class="line">                <span class="string">&quot;transaction was accumulated and the EXEC call. &quot;</span></span><br><span class="line">                <span class="string">&quot;This command is no longer allowed for the &quot;</span></span><br><span class="line">                <span class="string">&quot;following reason: %s&quot;</span>,</span><br><span class="line">                (acl_retval == ACL_DENIED_CMD) ?</span><br><span class="line">                <span class="string">&quot;no permission to execute the command or subcommand&quot;</span> :</span><br><span class="line">                <span class="string">&quot;no permission to touch the specified keys&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            call(c,server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 由于命令可以修改参数的值或者数量，因此重新保存命令上下文 */</span></span><br><span class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复原始命令上下文</span></span><br><span class="line">    c-&gt;argv = orig_argv;</span><br><span class="line">    c-&gt;argc = orig_argc;</span><br><span class="line">    c-&gt;cmd = orig_cmd;</span><br><span class="line">    <span class="comment">// 事务执行完成，删除该事务</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保EXEC会进行传递 */</span></span><br><span class="line">    <span class="keyword">if</span> (must_propagate) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog &amp;&amp; was_master &amp;&amp; !is_master) &#123;</span><br><span class="line">            <span class="keyword">char</span> *execcmd = <span class="string">&quot;*1\r\n$4\r\nEXEC\r\n&quot;</span>;</span><br><span class="line">            feedReplicationBacklog(execcmd,<span class="built_in">strlen</span>(execcmd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">handle_monitor:</span><br><span class="line">    <span class="comment">/* monitor命令操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp; !server.loading)</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取消事务：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;DISCARD without MULTI&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的删除逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="comment">// 状态位还原</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);</span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放事务中的所有命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeClientMultiState</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        multiCmd *mc = c-&gt;mstate.commands+j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mc-&gt;argc; i++)</span><br><span class="line">            decrRefCount(mc-&gt;argv[i]);</span><br><span class="line">        zfree(mc-&gt;argv);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(c-&gt;mstate.commands);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事务相关字段设为初始值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initClientMultiState</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;mstate.commands = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;mstate.count = <span class="number">0</span>;</span><br><span class="line">    c-&gt;mstate.cmd_flags = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>watch监视：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;WATCH inside MULTI is not allowed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        watchForKey(c,c-&gt;argv[j]);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    watchedKey *wk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断key是否已经被watch过 */</span></span><br><span class="line">    listRewind(c-&gt;watched_keys,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key,wk-&gt;key))</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果未被watch，则将key加入到列表中</span></span><br><span class="line"><span class="comment">     * 整个watch操作保存了两套数据结构，一套是在db-&gt;watched_keys中的字典结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys,key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) &#123;</span><br><span class="line">        clients = listCreate();</span><br><span class="line">        dictAdd(c-&gt;db-&gt;watched_keys,key,clients);</span><br><span class="line">        incrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    listAddNodeTail(clients,c);</span><br><span class="line">    <span class="comment">/* 另一套是在c-&gt;watched_keys中的链表结构 */</span></span><br><span class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</span><br><span class="line">    wk-&gt;key = key;</span><br><span class="line">    wk-&gt;db = c-&gt;db;</span><br><span class="line">    incrRefCount(key);</span><br><span class="line">    listAddNodeTail(c-&gt;watched_keys,wk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unwatch取消监视：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">    <span class="comment">// 修改客户端状态</span></span><br><span class="line">    c-&gt;flags &amp;= (~CLIENT_DIRTY_CAS);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchAllKeys</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="comment">// 如果客户端没有watch任何key，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    listRewind(c-&gt;watched_keys,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        <span class="built_in">list</span> *clients;</span><br><span class="line">        watchedKey *wk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 遍历取出该客户端watch的key */</span></span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        clients = dictFetchValue(wk-&gt;db-&gt;watched_keys, wk-&gt;key);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,clients != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,listSearchKey(clients,c));</span><br><span class="line">        <span class="comment">/* Kill the entry at all if this was the only client */</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>)</span><br><span class="line">            dictDelete(wk-&gt;db-&gt;watched_keys, wk-&gt;key);</span><br><span class="line">        <span class="comment">/* Remove this watched key from the client-&gt;watched list */</span></span><br><span class="line">        listDelNode(c-&gt;watched_keys,ln);</span><br><span class="line">        decrRefCount(wk-&gt;key);</span><br><span class="line">        zfree(wk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：multi.c/redis.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 简介&lt;/strong&gt;&lt;br&gt;Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;br&gt;总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="3-database" scheme="http://example.com/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-发布和订阅</title>
    <link href="http://example.com/Redis/3-database/redis-parse-pubsub/"/>
    <id>http://example.com/Redis/3-database/redis-parse-pubsub/</id>
    <published>2020-09-22T03:16:19.000Z</published>
    <updated>2020-09-22T03:31:11.629Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：pubsub.c/redis.h</p><p><strong>1. 前言</strong><br>Redis发布订阅(pub/sub)是一种消息通信模式，由三部分组成：发布者(pub)，频道(channel)，订阅者(sub)。具体结构如下：</p><a id="more"></a><p><img src="/Redis/3-database/redis-parse-pubsub/pubsub1.png" alt="pubsub1"><br>发布者和订阅者都是Redis客户端，频道是Redis服务端，发布者将消息发布到某一频道上，订阅了这一频道的订阅者就会收到该条信息。Redis客户端可订阅任意数量的频道。<br>Redis的发布订阅功能并不保证可靠，因为所有数据都存在内存中，没有提供持久化的功能，也不记录消费端状态，所以相对市面上的一些消息队列相比（如kafka、rabittMQ等），可靠性会差很多。在Redis5.0版本的stream消息队列功能发布之前，会有使用者使用redis-list来实现消息队列和发布订阅的功能，虽然有持久化（AOF &amp; RDB）的功能，但是实现起来比较笨拙，不够方便。</p><p>pubsub与stream比较：</p><div class="table-container"><table><thead><tr><th>pub/sub</th><th>stream</th></tr></thead><tbody><tr><td>不能持久化消息</td><td>可以持久化，支持RDB和AOF两种持久化机制</td></tr><tr><td>没有消息队列中群组的概念</td><td>引入了消费组的概念</td></tr><tr><td>redis客户端断线重连会丢失中间的数据</td><td>支持position，能够消费历史消息。断线后支持消息继续从上次的时间点读取，不会丢失消息，也可以直接读取最新消息</td></tr><tr><td>redis断线后需要重新订阅</td><td></td><td>不存在这个问题</td></tr><tr><td>没有ack机制</td><td>有ACK机制，能够一定程度保证消息“at least once” 消费</td></tr></tbody></table></div><p>基于stream消息队列的多种好处，pub/sub功能仅做源码学习，实际项目中推荐使用stream或者kafka等消息队列。</p><p><strong>2. 命令介绍</strong><br>下面介绍命令的使用详情：</p><ul><li>PSUBSCRIBE pattern [pattern1 ….]<ul><li>说明：订阅一个或多个符合给定模式的频道，每个模式以*作为匹配符</li><li>参数：pattern(给定的模式)</li><li>返回：接受到的信息</li></ul></li><li>PUNSUBSCRIBE pattern [pattern1 ….]<ul><li>说明：用于退订所有给定模式的频道</li><li>参数：pattern(给定的模式)</li><li>返回：这个命令在不同的客户端中有不同的表现。</li></ul></li><li>SUBSCRIBE channel [channel1 …]<ul><li>说明：用于订阅给定的一个或多个频道的信息</li><li>参数：channel(给定的频道名)</li><li>返回：接收到的信息</li></ul></li><li>UNSUBSCRIBE channel [channel1 …]<ul><li>说明：用于退订给定的一个或多个频道的信息</li><li>参数：channel(给定的频道名)</li><li>返回：这个命令在不同的客户端中有不同的表现</li></ul></li><li>PUBLISH channel message<ul><li>说明：用于将信息发送到指定的频道</li><li>参数：channel(频道名称)，message(将要发送的信息)</li><li>返回：接收到此消息的订阅者数量</li></ul></li><li>PUBSUB &lt; subcommand &gt; argument [argument1 ….]<ul><li>说明：用于查看订阅与发布系统状态，它由数个不同格式的子命令组成</li><li>参数：subcommand(子命令)，argument(子命令参数)</li><li>返回：由活跃频道组成的列表</li></ul></li></ul><p>子命令如下：</p><div class="table-container"><table><thead><tr><th>subcommand</th><th>argument</th><th>说明</th></tr></thead><tbody><tr><td>CHANNELS</td><td>[pattern]</td><td>返回指定模式pattern的活跃的频道,指定返回由SUBSCRIBE订阅的频道</td></tr><tr><td>NUMSUB</td><td>channel channel2 …</td><td>返回指定频道的订阅数量</td></tr><tr><td>NUMPAT</td><td></td><td>返回订阅模式的数量，注意：这个命令返回的不是订阅模式的客户端的数量， 而是客户端订阅的所有模式的数量总和</td></tr></tbody></table></div><p><strong>3. 实现原理</strong><br>每个 Redis 服务器进程维持着一个标识服务器状态 的 redis.h/redisServer 结构，其中就 保存着有订阅的频道 以及 订阅模式 的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Pubsub */</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* 订阅频道（字典数据结构） */</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* 订阅模式（列表结构） */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* 该客户端订阅的频道 */</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* 该客户端订阅的模式 */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.在Redis服务端内部维护了一个 <code>pubsub_channels</code> 的channel列表，记录了此客户端所订阅的频道。</p><p>2.当客户端订阅某一个频道之后，Redis服务端就会往自身的 <code>pubsub_channels</code> 这个字典变量中新添加一条数据，实际上这个 dict 字典维护的是一张链表，比如，下图展示的 pubsub_channels 示例中，client 1、client 2 就订阅了 channel 1，而其他频道也分别被其他客户端订阅：<br><img src="/Redis/3-database/redis-parse-pubsub/pubsub2.png" alt="pubsub1"></p><p>3.当一个Redis客户端publish一个message的时候，会先去服务端的 <code>pubsub_channels</code> 找相应的channel，遍历里面的client，然后发送通知，即完成了整个发布订阅的流程。</p></blockquote><p>下面我们通过代码来看看pub/sub的实现吧。</p><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pubsub commands implementation */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于订阅给定的一个或多个频道的信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于退订给定的一个或多个频道的信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psubscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 订阅一个或多个符合给定模式的频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">punsubscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于退订所有给定模式的频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于将信息发送到指定的频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pubsubCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于查看订阅与发布系统状态 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pubsub low level API */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freePubsubPattern</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; <span class="comment">/* 释放发布订阅的模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listMatchPubsubPattern</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span>; <span class="comment">/* 发布订阅模式是否匹配 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clientSubscriptionsCount</span><span class="params">(redisClient *c)</span></span>; <span class="comment">/* 返回客户端的所订阅的数量，包括channels + patterns频道和模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(redisClient *c, robj *channel)</span></span>; <span class="comment">/* Client订阅一个Channel频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeChannel</span><span class="params">(redisClient *c, robj *channel, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* 取消订阅Client中的Channel */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribePattern</span><span class="params">(redisClient *c, robj *pattern)</span></span>; <span class="comment">/* Client客户端订阅一种模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribePattern</span><span class="params">(redisClient *c, robj *pattern, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* Client客户端取消订阅pattern模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllChannels</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* 客户端取消自身订阅的所有Channel */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllPatterns</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* 客户端取消订阅所有的pattern模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span></span>; <span class="comment">/* 为所有订阅了Channel的Client发送消息message */</span></span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>Redis客户端订阅频道：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        pubsubSubscribeChannel(c,c-&gt;argv[j]);</span><br><span class="line">    <span class="comment">// 添加pubsub订阅标识，方便其他地方判断</span></span><br><span class="line">    c-&gt;flags |= CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(client *c, robj *channel)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step.1 将要订阅的 channel 添加到各自客户端的 pubsub_channels 容器中 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(c-&gt;pubsub_channels,channel,<span class="literal">NULL</span>) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        incrRefCount(channel);</span><br><span class="line">        <span class="comment">/* step.2 将要订阅的channel 添加到 server.pubsub_channels 中, 方便在publish时判定是否触发通知 */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果此频道的client列表为空，则创建新列表并添加</span></span><br><span class="line">            clients = listCreate();</span><br><span class="line">            dictAdd(server.pubsub_channels,channel,clients);</span><br><span class="line">            incrRefCount(channel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，获取频道的客户端列表，在尾部添加新的元素</span></span><br><span class="line">            clients = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* step.3 将客户端自身添加到相应的 server.pubsub_channels 对应的队列中去, 在通知时只需遍历该队列即可 */</span></span><br><span class="line">        listAddNodeTail(clients,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 回复客户端 */</span></span><br><span class="line">    addReplyPubsubSubscribed(c,channel);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端订阅的总channel数, 两种订阅方式相加</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clientSubscriptionsCount</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictSize(c-&gt;pubsub_channels)+</span><br><span class="line">           listLength(c-&gt;pubsub_patterns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>客户端自行管理需要订阅的channel, 放到 c-&gt;pubsub_channels 中;</li><li>redis使用的一个统一的 server-&gt;pubsub_channels dict容器进行管理所有的channel;</li><li>对于多个客户端订阅一个channel, redis 使用list进行管理追加;</li></ol><p><strong>Redis客户端退订频道：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">        pubsubUnsubscribeAllChannels(c,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">            pubsubUnsubscribeChannel(c,c-&gt;argv[j],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 退订所有频道，返回退订的数目 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllChannels</span><span class="params">(client *c, <span class="keyword">int</span> notify)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = dictGetSafeIterator(c-&gt;pubsub_channels);</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历该客户端订阅的所有频道并退订</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *channel = dictGetKey(de);</span><br><span class="line"></span><br><span class="line">        count += pubsubUnsubscribeChannel(c,channel,notify);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We were subscribed to nothing? Still reply to the client. */</span></span><br><span class="line">    <span class="keyword">if</span> (notify &amp;&amp; count == <span class="number">0</span>) addReplyPubsubUnsubscribed(c,<span class="literal">NULL</span>);</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeChannel</span><span class="params">(client *c, robj *channel, <span class="keyword">int</span> notify)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从client.pubsub_channels中移除频道 */</span></span><br><span class="line">    incrRefCount(channel);</span><br><span class="line">    <span class="keyword">if</span> (dictDelete(c-&gt;pubsub_channels,channel) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 从server.pubsub_channels中移除频道 */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</span><br><span class="line">        clients = dictGetVal(de);</span><br><span class="line">        ln = listSearchKey(clients,c);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,ln);</span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果列表中没有数据了，就移除频道列表</span></span><br><span class="line">            dictDelete(server.pubsub_channels,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (notify) addReplyPubsubUnsubscribed(c,channel);</span><br><span class="line">    decrRefCount(channel); <span class="comment">/* it is finally safe to release it */</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：pubsub.c/redis.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br&gt;Redis发布订阅(pub/sub)是一种消息通信模式，由三部分组成：发布者(pub)，频道(channel)，订阅者(sub)。具体结构如下：&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="3-database" scheme="http://example.com/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-AOF持久化</title>
    <link href="http://example.com/Redis/3-database/redis-parse-aof/"/>
    <id>http://example.com/Redis/3-database/redis-parse-aof/</id>
    <published>2020-09-22T03:14:40.000Z</published>
    <updated>2020-09-22T03:30:15.571Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：aof.c/rio.c/rio.h</p><p><strong>1. 前言</strong><br>除了RDB持久化功能以外，Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis所执行的写命令来记录数据库状态的。</p><a id="more"></a><p><strong>2. RDB和AOF的区别</strong><br>antirez 在《Redis 持久化解密》一文中讲述了 RDB 和 AOF 各自的优缺点：</p><ul><li>RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据备份。非常适合备份，全量复制等场景。比如每6小时执行 bgsave 备份，并把 RDB 文件拷贝到远程机器或者文件系统中，用于灾难恢复。</li><li>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</li><li>RDB 方式数据没办法做到实时持久化，而 AOF 方式可以做到。</li></ul><p><strong>3. AOF持久化的实现</strong><br><img src="/Redis/3-database/redis-parse-aof/aof1.png" alt="AOF1"><br>如上图所示，AOF 持久化功能的实现可以分为命令追加( append )、文件写入( write )、文件同步( sync )、文件重写(rewrite)和重启加载(load)。其流程如下：</p><ul><li>所有的写命令会追加到 AOF 缓冲中。</li><li>AOF 缓冲区根据对应的策略向硬盘进行同步操作。</li><li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li><li>当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li></ul><p><strong>命令追加</strong><br>当 AOF 持久化功能处于打开状态（配置文件中：<code>appendonly yes</code>）时，Redis 在执行完一个写命令之后，调用<code>feedAppendOnlyFile</code>函数，以协议格式(也就是RESP，即 Redis 客户端和服务器交互的通信协议 )将被执行的写命令追加到 Redis 服务端维护的 AOF 缓冲区末尾（sds类型变量：<code>aof_buf</code>）。</p><p>比如说 SET mykey myvalue 这条命令就以如下格式记录到 AOF 缓冲中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;</span></span><br></pre></td></tr></table></figure><p><strong>文件写入与同步</strong><br>Redis的服务器进程是一个事件循环，文件事件负责处理客户端的命令请求，而时间事件负责执行<code>serverCron</code>函数这样的定时运行的函数。在处理文件事件执行写命令，使得命令被追加到<code>aof_buf</code>中，然后在处理时间事件执行<code>serverCron</code>函数会调用<code>flushAppendOnlyFile</code>函数进行文件的写入和同步。<br>flushAppendOnlyFile函数的行为由服务器配置的<code>appendfsync</code>选项的值决定，该选项有三个可选值，分别是<code>always</code>、<code>everysec</code> 和 <code>no</code>：</p><ul><li><strong>always： 每执行一个命令保存一次。</strong> Redis 在每个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件，并且同步 AOF 文件，所以 always 的效率是 appendfsync 选项三个值当中最差的一个，但从安全性来说，也是最安全的。当发生故障停机时，AOF 持久化也只会丢失一个事件循环中所产生的命令数据。</li><li><strong>everysec： 每一秒钟保存一次。</strong> Redis 在每个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件中，并且每隔一秒就要在子线程中对 AOF 文件进行一次同步。从效率上看，该模式足够快。当发生故障停机时，只会丢失一秒钟的命令数据。</li><li><strong>no：不保存。</strong> 将aof_buf中的所有内容写入到aof文件，但不对aof文件同步，<code>fsync</code> 由操作系统执行。</li></ul><p>Redis的 <code>write</code> 操作会触发延迟写（delayed write）机制，在同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</p><blockquote><p><strong>延迟写机制：</strong> 传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。 当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则 并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时， 再将该缓冲排入到输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式就被称为延迟写。</p></blockquote><p>而 <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</p><p>三种AOF模式在安全性和性能方面的区别如下：</p><ul><li><strong>no：</strong> <code>write</code> 和 <code>fsync</code> 都由主进程执行，两个操作都会阻塞主进程。因为 <code>fsync</code> 操作只会在AOF 关闭或 Redis 关闭时执行，或者由操作系统触发。所以当系统故障宕机，那么丢失数据的数量由操作系统的缓存冲洗策略决定。</li><li><strong>always：</strong> 该模式的安全性最高，但性能也是最差的，因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后，才能继续处理请求。</li><li><strong>everysec：</strong> <code>write</code> 操作由主进程执行，阻塞主进程。<code>fsync</code> 操作由子线程执行，不直接阻塞主进程，但<code>fsync</code> 操作完成的快慢会影响 <code>write</code> 操作的阻塞时长。因为是一秒执行一次，所以它的安全性高于<code>no</code>模式，系统故障宕机将会丢失一秒钟的命令数据。</li></ul><p><code>appendfsync</code> 的三个值代表着三种不同的调用 <code>fsync</code> 的策略。调用 <code>fsync</code> 周期越频繁，读写效率就越差，但是相应的安全性越高，发生宕机时丢失的数据越少。</p><p><strong>4. AOF数据恢复</strong><br>AOF文件中包含了重建Redis数据所需的所有命令，所以Redis只要读入并重新执行一遍 AOF 文件里边保存的写命令，就可以还原 Redis 关闭之前的状态。<br><img src="/Redis/3-database/redis-parse-aof/aof2.png" alt="AOF2"></p><p><strong>5. AOF重写</strong><br>因为AOF持久化是通过保存被执行的写命令来记录Redis状态的，所以随着Redis长时间运行，AOF文件中的内容越来越多，文件的体积也会越来越大，如果不加以控制，Redis通过AOF文件还原数据库需要的时间将会变得很久，同时AOF文件很可能会对Redis甚至宿主主机造成影响。<br>为了解决上诉问题，Redis提供了AOF文件重写（rewrite）功能。通过该功能，Redis 可以创建一个新的 AOF 文件来替代现有的 AOF 文件。新旧两个 AOF 文件所保存的 Redis 状态相同，但是新的 AOF 文件不会包含任何浪费空间的冗余命令，所以新 AOF 文件的体积通常比旧 AOF 文件的体积要小得很多。</p><blockquote><p>例如：<br>重写前AOF文件命令记录:<br>RPUSH list “A”,”B”<br>RPUSH list “C”,”D”<br>LPOP list<br>LPOP list<br>RPUSH list “E”,”F”</p><p>重写后AOF文件命令记录：<br>RPUSH list “C”,”D”,”E”,”F”</p></blockquote><p>如上所示，重写前，AOF文件要保存5条命令，重写后只需要保存一条，所以重写后的文件要小很多。</p><p><strong>AOF重写实现</strong><br>AOF文件重写通过 <code>rewriteAppendOnlyFileBackground()</code> 实现，重写不需要对现有的AOF文件进行任何读取、分析或者写入操作，而是读取服务器当前的数据库状态来实现的（<code>rewriteAppendOnlyFileRio()</code>）。首先从数据库中读取键对应的值，然后用一条命令去记录键值对，代替之前的多条命令，这就是AOF重写功能实现。</p><p>在实际过程中，为了避免在执行命令时造成客户端输入缓冲区溢出，AOF 重写在处理列表、哈希表、集合和有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果数量超<code>REDIS_AOF_REWRITE_ITEMS_PER_CMD</code> ( 一般为64 )常量，则使用多条命令记录该键的值，而不是一条命令。</p><p>AOF重写函数会进行大量的写入操作，调用该函数的线程将被长时间阻塞，所以Redis在子进程中执行AOF重写操作。</p><ul><li>子进程重写期间，主线程可以继续处理客户端命令请求。</li><li>子进程带有主线程的内存数据拷贝副本，这样就可以避免与主进程竞争db-&gt;dict，在不用锁的情况下，也能保证数据的安全性。</li></ul><p>AOF重写期间，主进程依然能接收处理命令，会对现有的Redis数据库进行修改，从而导致AOF重写后的数据与现有的数据库数据不一致。因此，Redis设置了AOF重写缓冲区，在创建子进程后，主进程每执行一个写命令都会写到缓冲区中。在子进程完成重写后，主进程会将AOF重写缓冲区的数据写入到重写后的AOF文件中，以此保证数据的一致性。</p><h2 id="函数主要功能"><a href="#函数主要功能" class="headerlink" title="函数主要功能"></a>函数主要功能</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span></span>; <span class="comment">// 将缓冲区的数据刷入到磁盘文件中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span></span>; <span class="comment">// 将写操作的数据添加到AOF缓冲区末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// AOF文件重写</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span></span>; <span class="comment">// 加载AOF文件恢复数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopAppendOnly</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 停止</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startAppendOnly</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundRewriteDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span></span>; <span class="comment">// 子进程重写完成信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofRewriteBufferReset</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 清空AOF重写缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">aofRewriteBufferSize</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取AOF重写缓冲区的大小</span></span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>写操作命令追加到AOF缓冲区：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">    sds buf = sdsempty();</span><br><span class="line">    robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换dbid，追加select命令</span></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">&quot;%d&quot;</span>,dictid);</span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">&quot;*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        server.aof_selected_db = dictid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        <span class="comment">/* 将EXPIRE/PEXPIRE/EXPIREAT转化成PEXPIREAT生成命令协议格式的字符串 */</span></span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</span><br><span class="line">        <span class="comment">/* 将SETEX/PSETEX转换成SET和PEXPIREAT生成命令协议格式的字符串 */</span></span><br><span class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">&quot;SET&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv);</span><br><span class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        robj *exarg = <span class="literal">NULL</span>, *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,argv);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">&quot;ex&quot;</span>)) exarg = argv[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">&quot;px&quot;</span>)) pxarg = argv[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        serverAssert(!(exarg &amp;&amp; pxarg));</span><br><span class="line">        <span class="keyword">if</span> (exarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               exarg);</span><br><span class="line">        <span class="keyword">if</span> (pxarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               pxarg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 将写命令生成命令协议格式的字符串 */</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将命令的协议格式的字符串追加到aof_buf */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前正在做AOF重写，则将命令的协议格式的字符串追加到AOF重写缓存区 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AOF缓冲区的数据刷入到AOF文件中：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">            server.aof_fsync_offset != server.aof_current_size &amp;&amp;</span><br><span class="line">            server.unixtime &gt; server.aof_last_fsync &amp;&amp;</span><br><span class="line">            !(sync_in_progress = aofFsyncInProgress())) &#123;</span><br><span class="line">            <span class="keyword">goto</span> try_fsync;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">        <span class="comment">// 如果AOF fsync当前已在BIO线程中进行返回true</span></span><br><span class="line">        sync_in_progress = aofFsyncInProgress();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">        <span class="comment">/* 使用这个append fsync策略，我们进行后台fsync。如果fsync仍在进行中，我们可以尝试将写入延迟几秒钟。 */</span></span><br><span class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_delayed_fsync++;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_flush_sleep &amp;&amp; sdslen(server.aof_buf)) &#123;</span><br><span class="line">        usleep(server.aof_flush_sleep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将aof_buf中的内容写入到AOF文件中</span></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-pending-fsync&quot;</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasActiveChildProcess()) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-active-child&quot;</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-alone&quot;</span>,latency);</span><br><span class="line">    &#125;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;aof-write&quot;</span>,latency);</span><br><span class="line"></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">ssize_t</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">            can_log = <span class="number">1</span>;</span><br><span class="line">            last_write_error_log = server.unixtime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error writing to the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">                server.aof_last_write_errno = errno;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Short write while writing to &quot;</span></span><br><span class="line">                                       <span class="string">&quot;the AOF file: (nwritten=%lld, &quot;</span></span><br><span class="line">                                       <span class="string">&quot;expected=%lld)&quot;</span>,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                    serverLog(LL_WARNING, <span class="string">&quot;Could not remove short write &quot;</span></span><br><span class="line">                             <span class="string">&quot;from the append-only file.  Redis may refuse &quot;</span></span><br><span class="line">                             <span class="string">&quot;to load the AOF the next time it starts.  &quot;</span></span><br><span class="line">                             <span class="string">&quot;ftruncate: %s&quot;</span>, strerror(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nwritten = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_last_write_errno = ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t recover from AOF write error when the AOF fsync policy is &#x27;always&#x27;. Exiting...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            server.aof_last_write_status = C_ERR;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_current_size += nwritten;</span><br><span class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;AOF write error looks solved, Redis can write again.&quot;</span>);</span><br><span class="line">            server.aof_last_write_status = C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server.aof_current_size += nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">        sdsclear(server.aof_buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sdsfree(server.aof_buf);</span><br><span class="line">        server.aof_buf = sdsempty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">try_fsync:</span><br><span class="line">    <span class="comment">// appendfsync为no或者有后台进程在进行aof或rdb，不进行文件同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp; hasActiveChildProcess())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        redis_fsync(server.aof_fd); <span class="comment">/* Let&#x27;s try to get this data on the disk */</span></span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-fsync-always&quot;</span>,latency);</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) &#123;</span><br><span class="line">            aof_background_fsync(server.aof_fd);</span><br><span class="line">            server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        &#125;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AOF重写：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR; <span class="comment">//创建父进程与子进程的管道</span></span><br><span class="line">    openChildInfoPipe();</span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">        <span class="comment">// 通过子进程来重写AOF文件</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            sendChildCOWInfo(CHILD_INFO_TYPE_AOF, <span class="string">&quot;AOF rewrite&quot;</span>);</span><br><span class="line">            exitFromChild(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exitFromChild(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t rewrite append only file in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            aofClosePipes();</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Background append only file rewriting started by pid %d&quot;</span>,childpid);</span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        server.aof_rewrite_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AOF重写实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    rio aof;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> byte;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-%d.aof&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">&quot;Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.aof_child_diff = sdsempty();</span><br><span class="line">    rioInitWithFile(&amp;aof,fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_rewrite_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;aof,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    startSaving(RDBFLAGS_AOF_PREAMBLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_use_rdb_preamble) &#123;</span><br><span class="line">        <span class="keyword">int</span> error;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveRio(&amp;aof,&amp;error,RDBFLAGS_AOF_PREAMBLE,<span class="literal">NULL</span>) == C_ERR) &#123;</span><br><span class="line">            errno = error;</span><br><span class="line">            <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取Redis数据库状态进行重写操作</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据刷入到新的AOF文件中</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从父进程的重写缓冲区获取更多数据，如果20ms内没有新数据，则退出循环 */</span></span><br><span class="line">    <span class="keyword">int</span> nodata = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> start = mstime();</span><br><span class="line">    <span class="keyword">while</span>(mstime()-start &lt; <span class="number">1000</span> &amp;&amp; nodata &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodata++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodata = <span class="number">0</span>;</span><br><span class="line">        aofReadDiffFromParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 请求主进程停止发送差异. */</span></span><br><span class="line">    <span class="keyword">if</span> (write(server.aof_pipe_write_ack_to_parent,<span class="string">&quot;!&quot;</span>,<span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,server.aof_pipe_read_ack_from_parent) != ANET_OK)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">/* 设定10秒超时时间来接受主进程的相应 */</span></span><br><span class="line">    <span class="keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,<span class="number">1</span>,<span class="number">5000</span>) != <span class="number">1</span> ||</span><br><span class="line">        byte != <span class="string">&#x27;!&#x27;</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Parent agreed to stop sending diffs. Finalizing AOF...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取最终差异. */</span></span><br><span class="line">    aofReadDiffFromParent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将接收到的差异写入文件中 */</span></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">&quot;Concatenating %.2f MB of AOF diff received from parent.&quot;</span>,</span><br><span class="line">        (<span class="keyword">double</span>) sdslen(server.aof_child_diff) / (<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保数据不会保留在操作系统的输出缓冲区中 */</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重命名. */</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error moving temp append only file on the final destination: %s&quot;</span>, strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        stopSaving(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;SYNC append only file rewrite performed&quot;</span>);</span><br><span class="line">    stopSaving(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error writing append only file on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    stopSaving(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从AOF文件中恢复数据：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span> *<span class="title">fakeClient</span>;</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redis_stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">int</span> old_aof_state = server.aof_state;</span><br><span class="line">    <span class="keyword">long</span> loops = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> valid_up_to = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> valid_before_multi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal error: can&#x27;t open the append log file for reading: %s&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理长度为0的AOF文件，服务启动后，如果没有写操作，则AOF文件的长度为0，是特殊情况 */</span></span><br><span class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_current_size = <span class="number">0</span>;</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 暂时禁用AOF，以防止读取同一文件的同时，有客户端进行写操作命令 */</span></span><br><span class="line">    server.aof_state = AOF_OFF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建伪客户端</span></span><br><span class="line">    fakeClient = createAOFClient();</span><br><span class="line">    <span class="comment">// 开始加载文件的初始化工作</span></span><br><span class="line">    startLoadingFile(fp, filename, RDBFLAGS_AOF_PREAMBLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查这个AOF文件是否有RDB前导码。在这种情况下，我们需要加载RDB文件，然后继续加载AOF tail. */</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">5</span>]; <span class="comment">/* &quot;REDIS&quot; */</span></span><br><span class="line">    <span class="keyword">if</span> (fread(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rio rdb;</span><br><span class="line"></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Reading RDB preamble from AOF file...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">        <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,RDBFLAGS_AOF_PREAMBLE,<span class="literal">NULL</span>) != C_OK) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Reading the remaining AOF tail...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析AOF文件内容. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> argc, j;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">        robj **argv;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        sds argsds;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Serve the clients from time to time */</span></span><br><span class="line">        <span class="keyword">if</span> (!(loops++ % <span class="number">1000</span>)) &#123;</span><br><span class="line">            loadingProgress(ftello(fp));</span><br><span class="line">            processEventsWhileBlocked();</span><br><span class="line">            processModuleLoadingProgressEvent(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (feof(fp))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        argc = atoi(buf+<span class="number">1</span>); <span class="comment">// 命令的参数个数</span></span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line"></span><br><span class="line">        argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*argc);</span><br><span class="line">        fakeClient-&gt;argc = argc;</span><br><span class="line">        fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">            <span class="comment">/* 解析参数长度. */</span></span><br><span class="line">            <span class="keyword">char</span> *readres = fgets(buf,<span class="keyword">sizeof</span>(buf),fp);</span><br><span class="line">            <span class="keyword">if</span> (readres == <span class="literal">NULL</span> || buf[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">if</span> (readres == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">goto</span> readerr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">goto</span> fmterr;</span><br><span class="line">            &#125;</span><br><span class="line">            len = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            argsds = sdsnewlen(SDS_NOINIT,len);</span><br><span class="line">            <span class="keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                sdsfree(argsds);</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            argv[j] = createObject(OBJ_STRING,argsds);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fread(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j+<span class="number">1</span>; <span class="comment">/* Free up to j. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 执行命令 */</span></span><br><span class="line">        cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Unknown command &#x27;%s&#x27; reading the append only file&quot;</span>,</span><br><span class="line">                (<span class="keyword">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == server.multiCommand) valid_before_multi = valid_up_to;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在伪客户端中执行该命令 */</span></span><br><span class="line">        fakeClient-&gt;cmd = cmd;</span><br><span class="line">        <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">            fakeClient-&gt;cmd-&gt;proc != execCommand)</span><br><span class="line">        &#123;</span><br><span class="line">            queueMultiCommand(fakeClient);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmd-&gt;proc(fakeClient);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverAssert(fakeClient-&gt;bufpos == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     listLength(fakeClient-&gt;reply) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 清理伪客户端中的命令. */</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        fakeClient-&gt;cmd = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_load_truncated) valid_up_to = ftello(fp);</span><br><span class="line">        <span class="keyword">if</span> (server.key_load_delay)</span><br><span class="line">            usleep(server.key_load_delay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Revert incomplete MULTI/EXEC transaction in AOF file&quot;</span>);</span><br><span class="line">        valid_up_to = valid_before_multi;</span><br><span class="line">        <span class="keyword">goto</span> uxeof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">loaded_ok: <span class="comment">/* DB loaded, cleanup and return C_OK to the caller. */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    freeFakeClient(fakeClient);</span><br><span class="line">    server.aof_state = old_aof_state;</span><br><span class="line">    stopLoading(<span class="number">1</span>);</span><br><span class="line">    aofUpdateCurrentSize();</span><br><span class="line">    server.aof_rewrite_base_size = server.aof_current_size;</span><br><span class="line">    server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">readerr: <span class="comment">/* Read error. If feof(fp) is true, fall through to unexpected EOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Unrecoverable error reading the append only file: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">uxeof: <span class="comment">/* Unexpected AOF end of file. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_load_truncated) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Warning: short read while loading the AOF file !!!&quot;</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Truncating the AOF at offset %llu !!!&quot;</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) valid_up_to);</span><br><span class="line">        <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span> || truncate(filename,valid_up_to) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Last valid command offset is invalid&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error truncating the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Make sure the AOF file descriptor points to the end of the</span></span><br><span class="line"><span class="comment">             * file after the truncate call. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_fd != <span class="number">-1</span> &amp;&amp; lseek(server.aof_fd,<span class="number">0</span>,SEEK_END) == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t seek the end of the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;AOF loaded anyway because aof-load-truncated is enabled&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> loaded_ok;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &#x27;aof-load-truncated&#x27; configuration option to yes and restart the server.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fmterr: <span class="comment">/* Format error. */</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：aof.c/rio.c/rio.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br&gt;除了RDB持久化功能以外，Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis所执行的写命令来记录数据库状态的。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="3-database" scheme="http://example.com/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-RDB持久化</title>
    <link href="http://example.com/Redis/3-database/redis-parse-rdb/"/>
    <id>http://example.com/Redis/3-database/redis-parse-rdb/</id>
    <published>2020-09-22T03:12:52.000Z</published>
    <updated>2020-09-22T03:31:24.643Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：rdb.c/rdb.h/rio.c/rio.h</p><p><strong>1. 前言</strong><br>Redis是内存数据库，所有的数据都是存在内存中，这样就会存在一个问题，就是当服务进程退出，所有数据都将会丢失，所以Redis提供了两种数据持久化的机制，分别是RDB(Redis DataBase)和AOF(Append Only File)。这两种机制的区别将在后面介绍AOF持久化中介绍。  </p><p>RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。<br>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为<code>dump.rdb</code>。</p><a id="more"></a><p><strong>2. RDB持久化的方式</strong><br>RDB持久化有三种方式，分别是：SAVE、BGSAVE、根据配置定期执行。<br>①.SAVE触发<br>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。<br>②.BGSAVE触发<br>执行该命令时，Redis会派生出一个子进程，然后由子进程负责创建 RDB 文件，父进程继续处理命令请求。<br>③.定期执行<br>定期执行的触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p><ul><li><strong>save</strong>：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如”save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li><li><strong>stop-writes-on-bgsave-error</strong>：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了。</li><li><strong>rdbcompression</strong>：默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li><li><strong>rdbchecksum</strong>：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li><li><strong>dbfilename</strong>：设置快照的文件名，默认是 dump.rdb。</li><li><strong>dir</strong>:设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</li></ul><div class="table-container"><table><thead><tr><th>命令</th><th>SAVE</th><th>BGSAVE</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞状态</td><td>是</td><td>是（阻塞发生在fork）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork，消耗内存</td></tr></tbody></table></div><p><strong>3. RDB的优势和劣势</strong><br><strong>优势：</strong></p><ul><li>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li><li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><p><strong>劣势：</strong><br>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p><p><strong>4. RDB文件结构</strong><br>一个rdb可以分为以下几个部分：</p><ul><li>REDIS：5字节，保存着 “REDIS” 五个字符</li><li>db_version：4字节，RDB文件的版本号</li><li>databases：数据库中的键值对<ul><li>SELECTDB：1字节常量</li><li>db_number：数据库号码</li><li>key_value_pairs：键值对（含过期时间的键值对会带有 EXPIRETIME_MS 和过期时间 ms）<ul><li>EXPIRETIME_MS：标识符，对应的值是该key的过期时间戳，含过期时间的键值对才有该数据</li><li>ms：过期时间戳，含过期时间的键值对才有该数据</li><li>TYPE：该key的数据类型</li><li>key：key对应的字符串</li><li>value：key对应的值</li></ul></li></ul></li><li><p>EOF：标志着数据库内容的结尾（不是文件的结尾）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_OPCODE_EOF        255</span></span><br></pre></td></tr></table></figure></li><li><p>check_sum：校验和（CRC64），用来检查RDB文件是否出错</p></li></ul><p>图示如下：<br><img src="/Redis/3-database/redis-parse-rdb/rdb1.png" alt="rdb1"></p><p><strong>4.1 TYPE编码</strong><br><code>TYPE</code>常量记录了值对象的类型和编码，规则如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_LIST   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_SET    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_ZSET   3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_HASH   4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_ZSET_2 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_MODULE 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_MODULE_2 7</span></span><br><span class="line"><span class="comment">/* Object types for encoded objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_HASH_ZIPMAP    9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_LIST_ZIPLIST  10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_SET_INTSET    11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_ZSET_ZIPLIST  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_HASH_ZIPLIST  13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_LIST_QUICKLIST 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_STREAM_LISTPACKS 15</span></span><br></pre></td></tr></table></figure><p><strong>4.2 key</strong><br>在RDB文件中有很多地方需要存储长度信息，如字符串长度、list长度等等。如果使用固定的int或long类型来存储该信息，在长度值比较小的时候会造成较大的空间浪费。为了节省空间，Redis也是无所不用其极，设计了一套特殊的方法对长度进行编码后再存储。</p><p>RDB文件中的长度编码主要通过读取第一字节的最高 2 位来决定接下来如何解析长度信息，在 <code>rdbSaveLen()</code> 函数中，我们可以看到有以下四种方式：</p><div class="table-container"><table><thead><tr><th>编码方式</th><th>占用字节数</th><th>说明</th></tr></thead><tbody><tr><td>00\</td><td>000000</td><td>1byte</td><td>这一字节的其余 6 位表示长度，可以保存的最大长度是 63 （包括在内）</td></tr><tr><td>01\</td><td>000000 00000000</td><td>2byte</td><td>长度为 14 位，当前字节 6 位，加上下个字节 8 位</td></tr><tr><td>10\</td><td>000000 [32 bit integer]</td><td>5byte</td><td>长度由随后的 32 位整数保存</td></tr><tr><td>11\</td><td>000000</td><td></td><td>后跟一个特殊编码的对象。字节中的 6 位（实际上只用到两个bit）指定对象的类型，用来确定怎样读取和解析接下来的数据</td></tr></tbody></table></div><p><code>rdbSaveLen()</code>的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveLen</span><span class="params">(rio *rdb, <span class="keyword">uint64_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">size_t</span> nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) &#123;</span><br><span class="line">        <span class="comment">/* Save a 6 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = (len&amp;<span class="number">0xFF</span>)|(RDB_6BITLEN&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) &#123;</span><br><span class="line">        <span class="comment">/* Save a 14 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = ((len&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>)|(RDB_14BITLEN&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        buf[<span class="number">1</span>] = len&amp;<span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">2</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt;= UINT32_MAX) &#123;</span><br><span class="line">        <span class="comment">/* Save a 32 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = RDB_32BITLEN;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> len32 = htonl(len);</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,&amp;len32,<span class="number">4</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">1</span>+<span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Save a 64 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = RDB_64BITLEN;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        len = htonu64(len);</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,&amp;len,<span class="number">8</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">1</span>+<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nwritten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数主要功能"><a href="#函数主要功能" class="headerlink" title="函数主要功能"></a>函数主要功能</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span></span>; <span class="comment">// 保存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi, <span class="keyword">int</span> rdbflags)</span></span>; <span class="comment">// 加载</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoadRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>数据保存到rdb文件中：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> cwd[MAXPATHLEN]; <span class="comment">/* Current working dir path for error messages. */</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建rdb文件</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-%d.rdb&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed opening the RDB file %s (in server root dir %s) &quot;</span></span><br><span class="line">            <span class="string">&quot;for saving: %s&quot;</span>,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化rio</span></span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    startSaving(RDBFLAGS_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_save_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将db中的数据存入到rio中</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveRio(&amp;rdb,&amp;error,RDBFLAGS_NONE,rsi) == C_ERR) &#123;</span><br><span class="line">        errno = error;</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure data will not remain on the OS&#x27;s output buffers */</span></span><br><span class="line">    <span class="comment">// 同步数据到磁盘文件中</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></span><br><span class="line"><span class="comment">     * if the generate DB file is ok. */</span></span><br><span class="line">    <span class="comment">// 重命名rdb文件</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Error moving temp DB file %s on the final &quot;</span></span><br><span class="line">            <span class="string">&quot;destination %s (in server root dir %s): %s&quot;</span>,</span><br><span class="line">            tmpfile,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        stopSaving(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;DB saved on disk&quot;</span>);</span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line">    server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    stopSaving(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error saving DB on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    stopSaving(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">uint64_t</span> cksum;</span><br><span class="line">    <span class="keyword">size_t</span> processed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">&quot;REDIS%04d&quot;</span>,RDB_VERSION);</span><br><span class="line">    <span class="comment">// 保存REDIS RDB_VERSION</span></span><br><span class="line">    <span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 保存一些生产rdb文件的默认字段信息</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存数据库信息</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the SELECT DB opcode */</span></span><br><span class="line">        <span class="comment">// 保存SELECTDB常量和dbid</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the RESIZE DB opcode. We trim the size to UINT32_MAX, which</span></span><br><span class="line"><span class="comment">         * is currently the largest type we are able to represent in RDB sizes.</span></span><br><span class="line"><span class="comment">         * However this does not limit the actual size of the DB to load since</span></span><br><span class="line"><span class="comment">         * these sizes are just hints to resize the hash tables. */</span></span><br><span class="line">        <span class="keyword">uint64_t</span> db_size, expires_size;</span><br><span class="line">        db_size = dictSize(db-&gt;dict);</span><br><span class="line">        expires_size = dictSize(db-&gt;expires);</span><br><span class="line">        <span class="comment">// 保存RESIZEDB常量，数据库size和设置expire的key-value的size</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,db_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,expires_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line">        <span class="comment">// 遍历数据库的键空间，将数据库中的key-value存到rdb文件</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr = dictGetKey(de);</span><br><span class="line">            robj key, *o = dictGetVal(de);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            expire = getExpire(db,&amp;key);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When this RDB is produced as part of an AOF rewrite, move</span></span><br><span class="line"><span class="comment">             * accumulated diff from parent to child while rewriting in</span></span><br><span class="line"><span class="comment">             * order to have a smaller final write. */</span></span><br><span class="line">            <span class="keyword">if</span> (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">                rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">            &#123;</span><br><span class="line">                processed = rdb-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don&#x27;t release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are storing the replication information on disk, persist</span></span><br><span class="line"><span class="comment">     * the script cache as well: on successful PSYNC after a restart, we need</span></span><br><span class="line"><span class="comment">     * to be able to process any EVALSHA inside the replication backlog the</span></span><br><span class="line"><span class="comment">     * master will send us. */</span></span><br><span class="line">    <span class="keyword">if</span> (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123;</span><br><span class="line">        di = dictGetIterator(server.lua_scripts);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            robj *body = dictGetVal(de);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveAuxField(rdb,<span class="string">&quot;lua&quot;</span>,<span class="number">3</span>,body-&gt;ptr,sdslen(body-&gt;ptr)) == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don&#x27;t release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF opcode */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></span><br><span class="line"><span class="comment">     * loading code skips the check in this case. */</span></span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="keyword">if</span> (error) *error = errno;</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从rdb文件中加载数据：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi, <span class="keyword">int</span> rdbflags)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 获取文件状态写入server结构体中（如加载的文件大小、加载时间等）</span></span><br><span class="line">    startLoadingFile(fp, filename,rdbflags);</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp); <span class="comment">// 初始化rio</span></span><br><span class="line">    retval = rdbLoadRio(&amp;rdb,rdbflags,rsi);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    stopLoading(retval==C_OK);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoadRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> dbid;</span><br><span class="line">    <span class="keyword">int</span> type, rdbver;</span><br><span class="line">    redisDb *db = server.db+<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    rdb-&gt;update_cksum = rdbLoadProgressCallback;</span><br><span class="line">    rdb-&gt;max_processing_chunk = server.loading_process_events_interval_bytes;</span><br><span class="line">    <span class="comment">// 读取REDIS RDB_VERSION</span></span><br><span class="line">    <span class="keyword">if</span> (rioRead(rdb,buf,<span class="number">9</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">    buf[<span class="number">9</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 检查REDIS RDB_VERSION</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(buf,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Wrong signature trying to load DB from file&quot;</span>);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    rdbver = atoi(buf+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (rdbver &lt; <span class="number">1</span> || rdbver &gt; RDB_VERSION) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t handle RDB format version %d&quot;</span>,rdbver);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Key-specific attributes, set by opcodes before the key type. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lru_idle = <span class="number">-1</span>, lfu_freq = <span class="number">-1</span>, expiretime = <span class="number">-1</span>, now = mstime();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lru_clock = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始读取数据写入到数据库中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        robj *key, *val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read type. */</span></span><br><span class="line">        <span class="comment">// 读取数据的类型</span></span><br><span class="line">        <span class="keyword">if</span> ((type = rdbLoadType(rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle special types. */</span></span><br><span class="line">        <span class="comment">// 根据不同的类型进行相应的处理</span></span><br><span class="line">        <span class="keyword">if</span> (type == RDB_OPCODE_EXPIRETIME) &#123;</span><br><span class="line">            <span class="comment">/* EXPIRETIME: load an expire associated with the next key</span></span><br><span class="line"><span class="comment">             * to load. Note that after loading an expire we need to</span></span><br><span class="line"><span class="comment">             * load the actual type, and continue. */</span></span><br><span class="line">            expiretime = rdbLoadTime(rdb);</span><br><span class="line">            expiretime *= <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (rioGetReadError(rdb)) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_EXPIRETIME_MS) &#123;</span><br><span class="line">            <span class="comment">/* EXPIRETIME_MS: milliseconds precision expire times introduced</span></span><br><span class="line"><span class="comment">             * with RDB v3. Like EXPIRETIME but no with more precision. */</span></span><br><span class="line">            expiretime = rdbLoadMillisecondTime(rdb,rdbver);</span><br><span class="line">            <span class="keyword">if</span> (rioGetReadError(rdb)) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_FREQ) &#123;</span><br><span class="line">            <span class="comment">/* FREQ: LFU frequency. */</span></span><br><span class="line">            <span class="keyword">uint8_t</span> byte;</span><br><span class="line">            <span class="keyword">if</span> (rioRead(rdb,&amp;byte,<span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            lfu_freq = byte;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_IDLE) &#123;</span><br><span class="line">            <span class="comment">/* IDLE: LRU idle time. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> qword;</span><br><span class="line">            <span class="keyword">if</span> ((qword = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            lru_idle = qword;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_EOF) &#123;</span><br><span class="line">            <span class="comment">/* EOF: End of file, exit the main loop. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_SELECTDB) &#123;</span><br><span class="line">            <span class="comment">/* SELECTDB: Select the specified database. */</span></span><br><span class="line">            <span class="keyword">if</span> ((dbid = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> (dbid &gt;= (<span class="keyword">unsigned</span>)server.dbnum) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;FATAL: Data file was created with a Redis &quot;</span></span><br><span class="line">                    <span class="string">&quot;server configured to handle more than %d &quot;</span></span><br><span class="line">                    <span class="string">&quot;databases. Exiting\n&quot;</span>, server.dbnum);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            db = server.db+dbid;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_RESIZEDB) &#123;</span><br><span class="line">            <span class="comment">/* RESIZEDB: Hint about the size of the keys in the currently</span></span><br><span class="line"><span class="comment">             * selected data base, in order to avoid useless rehashing. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> db_size, expires_size;</span><br><span class="line">            <span class="keyword">if</span> ((db_size = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR)</span><br><span class="line">                <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> ((expires_size = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR)</span><br><span class="line">                <span class="keyword">goto</span> eoferr;</span><br><span class="line">            dictExpand(db-&gt;dict,db_size);</span><br><span class="line">            dictExpand(db-&gt;expires,expires_size);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_AUX) &#123;</span><br><span class="line">            <span class="comment">/* AUX: generic string-string fields. Use to add state to RDB</span></span><br><span class="line"><span class="comment">             * which is backward compatible. Implementations of RDB loading</span></span><br><span class="line"><span class="comment">             * are requierd to skip AUX fields they don&#x27;t understand.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * An AUX field is composed of two strings: key and value. */</span></span><br><span class="line">            robj *auxkey, *auxval;</span><br><span class="line">            <span class="keyword">if</span> ((auxkey = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> ((auxval = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((<span class="keyword">char</span>*)auxkey-&gt;ptr)[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">/* All the fields with a name staring with &#x27;%&#x27; are considered</span></span><br><span class="line"><span class="comment">                 * information fields and are logged at startup with a log</span></span><br><span class="line"><span class="comment">                 * level of NOTICE. */</span></span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;RDB &#x27;%s&#x27;: %s&quot;</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxkey-&gt;ptr,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;repl-stream-db&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi) rsi-&gt;repl_stream_db = atoi(auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;repl-id&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi &amp;&amp; sdslen(auxval-&gt;ptr) == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(rsi-&gt;repl_id,auxval-&gt;ptr,CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">                    rsi-&gt;repl_id_is_set = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;repl-offset&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi) rsi-&gt;repl_offset = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;lua&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Load the script back in memory. */</span></span><br><span class="line">                <span class="keyword">if</span> (luaCreateFunction(<span class="literal">NULL</span>,server.lua,auxval) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    rdbExitReportCorruptRDB(</span><br><span class="line">                        <span class="string">&quot;Can&#x27;t load Lua script from RDB file! &quot;</span></span><br><span class="line">                        <span class="string">&quot;BODY: %s&quot;</span>, auxval-&gt;ptr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;redis-ver&quot;</span>)) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;Loading RDB produced by version %s&quot;</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;ctime&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">time_t</span> age = time(<span class="literal">NULL</span>)-strtol(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (age &lt; <span class="number">0</span>) age = <span class="number">0</span>;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;RDB age %ld seconds&quot;</span>,</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) age);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;used-mem&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> usedmem = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;RDB memory usage when created %.2f Mb&quot;</span>,</span><br><span class="line">                    (<span class="keyword">double</span>) usedmem / (<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;aof-preamble&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> haspreamble = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (haspreamble) serverLog(LL_NOTICE,<span class="string">&quot;RDB has an AOF tail&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;redis-bits&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Just ignored. */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* We ignore fields we don&#x27;t understand, as by AUX field</span></span><br><span class="line"><span class="comment">                 * contract. */</span></span><br><span class="line">                serverLog(LL_DEBUG,<span class="string">&quot;Unrecognized RDB AUX field: &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxkey-&gt;ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            decrRefCount(auxkey);</span><br><span class="line">            decrRefCount(auxval);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read type again. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_MODULE_AUX) &#123;</span><br><span class="line">            <span class="comment">/* Load module data that is not related to the Redis key space.</span></span><br><span class="line"><span class="comment">             * Such data can be potentially be stored both before and after the</span></span><br><span class="line"><span class="comment">             * RDB keys-values section. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> moduleid = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">int</span> when_opcode = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">int</span> when = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (rioGetReadError(rdb)) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> (when_opcode != RDB_MODULE_OPCODE_UINT)</span><br><span class="line">                rdbReportReadError(<span class="string">&quot;bad when_opcode&quot;</span>);</span><br><span class="line">            moduleType *mt = moduleTypeLookupModuleByID(moduleid);</span><br><span class="line">            <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">            moduleTypeNameByID(name,moduleid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!rdbCheckMode &amp;&amp; mt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Unknown module. */</span></span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains AUX module data I can&#x27;t load: no matching module &#x27;%s&#x27;&quot;</span>, name);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rdbCheckMode &amp;&amp; mt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mt-&gt;aux_load) &#123;</span><br><span class="line">                    <span class="comment">/* Module doesn&#x27;t support AUX. */</span></span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains module AUX data, but the module &#x27;%s&#x27; doesn&#x27;t seem to support it.&quot;</span>, name);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                RedisModuleIO io;</span><br><span class="line">                moduleInitIOContext(io,mt,rdb,<span class="literal">NULL</span>);</span><br><span class="line">                io.ver = <span class="number">2</span>;</span><br><span class="line">                <span class="comment">/* Call the rdb_load method of the module providing the 10 bit</span></span><br><span class="line"><span class="comment">                 * encoding version in the lower 10 bits of the module ID. */</span></span><br><span class="line">                <span class="keyword">if</span> (mt-&gt;aux_load(&amp;io,moduleid&amp;<span class="number">1023</span>, when) != REDISMODULE_OK || io.error) &#123;</span><br><span class="line">                    moduleTypeNameByID(name,moduleid);</span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains module AUX data for the module type &#x27;%s&#x27;, that the responsible module is not able to load. Check for modules log above for additional clues.&quot;</span>, name);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (io.ctx) &#123;</span><br><span class="line">                    moduleFreeContext(io.ctx);</span><br><span class="line">                    zfree(io.ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">uint64_t</span> eof = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (eof != RDB_MODULE_OPCODE_EOF) &#123;</span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains module AUX data for the module &#x27;%s&#x27; that is not terminated by the proper module value EOF marker&quot;</span>, name);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* RDB check mode. */</span></span><br><span class="line">                robj *aux = rdbLoadCheckModuleValue(rdb,name);</span><br><span class="line">                decrRefCount(aux);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read key */</span></span><br><span class="line">        <span class="keyword">if</span> ((key = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">        <span class="comment">/* Read value */</span></span><br><span class="line">        <span class="keyword">if</span> ((val = rdbLoadObject(type,rdb,key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            <span class="keyword">goto</span> eoferr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the key already expired. This function is used when loading</span></span><br><span class="line"><span class="comment">         * an RDB file from disk, either at startup, or when an RDB was</span></span><br><span class="line"><span class="comment">         * received from the master. In the latter case, the master is</span></span><br><span class="line"><span class="comment">         * responsible for key expiry. If we would expire keys here, the</span></span><br><span class="line"><span class="comment">         * snapshot taken by the master may not be reflected on the slave. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; !(rdbflags&amp;RDBFLAGS_AOF_PREAMBLE) &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            decrRefCount(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Add the new object in the hash table */</span></span><br><span class="line">            dbAdd(db,key,val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Set the expire time if needed */</span></span><br><span class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) setExpire(<span class="literal">NULL</span>,db,key,expiretime);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Set usage information (for eviction). */</span></span><br><span class="line">            objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Decrement the key refcount since dbAdd() will take its</span></span><br><span class="line"><span class="comment">             * own reference. */</span></span><br><span class="line">            decrRefCount(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server.key_load_delay)</span><br><span class="line">            usleep(server.key_load_delay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Reset the state that is key-specified and is populated by</span></span><br><span class="line"><span class="comment">         * opcodes before the key, so that we start from scratch again. */</span></span><br><span class="line">        expiretime = <span class="number">-1</span>;</span><br><span class="line">        lfu_freq = <span class="number">-1</span>;</span><br><span class="line">        lru_idle = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Verify the checksum if RDB version is &gt;= 5 */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbver &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> cksum, expected = rdb-&gt;cksum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rioRead(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">        <span class="keyword">if</span> (server.rdb_checksum) &#123;</span><br><span class="line">            memrev64ifbe(&amp;cksum);</span><br><span class="line">            <span class="keyword">if</span> (cksum == <span class="number">0</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;RDB file was saved with checksum disabled: no check performed.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != expected) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Wrong RDB checksum. Aborting now.&quot;</span>);</span><br><span class="line">                rdbExitReportCorruptRDB(<span class="string">&quot;RDB CRC error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unexpected end of file is handled here calling rdbReportReadError():</span></span><br><span class="line"><span class="comment">     * this will in turn either abort Redis in most cases, or if we are loading</span></span><br><span class="line"><span class="comment">     * the RDB file from a socket during initial SYNC (diskless replica mode),</span></span><br><span class="line"><span class="comment">     * we&#x27;ll report the error to the caller, so that we can retry. */</span></span><br><span class="line">eoferr:</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">&quot;Short read or OOM loading DB. Unrecoverable error, aborting now.&quot;</span>);</span><br><span class="line">    rdbReportReadError(<span class="string">&quot;Unexpected EOF reading RDB file&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：rdb.c/rdb.h/rio.c/rio.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br&gt;Redis是内存数据库，所有的数据都是存在内存中，这样就会存在一个问题，就是当服务进程退出，所有数据都将会丢失，所以Redis提供了两种数据持久化的机制，分别是RDB(Redis DataBase)和AOF(Append Only File)。这两种机制的区别将在后面介绍AOF持久化中介绍。  &lt;/p&gt;
&lt;p&gt;RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。&lt;br&gt;RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为&lt;code&gt;dump.rdb&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="3-database" scheme="http://example.com/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-通知功能notify</title>
    <link href="http://example.com/Redis/3-database/redis-parse-notify/"/>
    <id>http://example.com/Redis/3-database/redis-parse-notify/</id>
    <published>2020-09-22T03:11:26.000Z</published>
    <updated>2020-09-22T03:32:46.301Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：notify.c/server.h</p><p><strong>1. 事件通知概述</strong><br>对于Redis服务器，它可以通过订阅发布功能来发送服务器中的键空间事件。所谓的键空间事件，就是数据库中键的增加、修改和删除等操作，用于告知收听该类事件的客户端当前数据库中执行了哪些操作。客户端可以通过 订阅与发布功能（pub/sub）功能，来接收那些以某种方式改动了Redis数据集的事件。<br>目前Redis的订阅与发布功能采用的是发送即忘（fire and forget）的策略，当订阅事件的客户端断线时，它会丢失所有在断线期间分发给它的事件。<br>订阅与发布功能（pub/sub）功能实现在pubsub.c中，后续会在博文中讲到。</p><a id="more"></a><p><strong>2. 事件类型</strong><br>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件：  </p><ul><li>键空间通知（key-space）</li><li>键事件通知（key-event）</li></ul><p>当 <code>del mykey</code> 命令执行时：</p><ul><li>键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 del</li><li>键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 mykey</li></ul><p><strong>3. 配置</strong><br>因为开启键空间通知功能需要消耗一些 CPU，所以在默认配置下，该功能处于关闭状态。开启通知功能有以下两种方式：  </p><ol><li>修改 redis.conf 中的 <code>notify-keyspace-events</code> 参数</li><li>通过 CONFIG SET 命令来设定 <code>notify-keyspace-events</code> 参数</li></ol><p><code>notify-keyspace-events</code> 参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知：</p><div class="table-container"><table><thead><tr><th>字符</th><th>发送的通知</th></tr></thead><tbody><tr><td>K</td><td>键空间通知，所有通知以 <strong>keyspace@\<db></db></strong> 为前缀</td></tr><tr><td>E</td><td>键事件通知，所有通知以 <strong>keyevent@\<db></db></strong> 为前缀</td></tr><tr><td>g</td><td>DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</td></tr><tr><td>$</td><td>字符串命令的通知</td></tr><tr><td>l</td><td>列表命令的通知</td></tr><tr><td>s</td><td>集合命令的通知</td></tr><tr><td>h</td><td>哈希命令的通知</td></tr><tr><td>z</td><td>有序集合命令的通知</td></tr><tr><td>x</td><td>过期事件：每当有过期键被删除时发送</td></tr><tr><td>e</td><td>驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</td></tr><tr><td>A</td><td>参数 g$lshzxe 的别名，包含所有的字符</td></tr></tbody></table></div><p>输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何通知被分发。<br>在源码中设定了一系列的宏定义，用来标识以上这些字符事件的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键空间通知的类型，每个类型都关联着一个有目的的字符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_KEYSPACE (1&lt;&lt;0)    <span class="comment">/* K */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_KEYEVENT (1&lt;&lt;1)    <span class="comment">/* E */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_GENERIC (1&lt;&lt;2)     <span class="comment">/* g */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_STRING (1&lt;&lt;3)      <span class="comment">/* $ */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_LIST (1&lt;&lt;4)        <span class="comment">/* l */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_SET (1&lt;&lt;5)         <span class="comment">/* s */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_HASH (1&lt;&lt;6)        <span class="comment">/* h */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_ZSET (1&lt;&lt;7)        <span class="comment">/* z */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_EXPIRED (1&lt;&lt;8)     <span class="comment">/* x */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_EVICTED (1&lt;&lt;9)     <span class="comment">/* e */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_STREAM (1&lt;&lt;10)     <span class="comment">/* t */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_KEY_MISS (1&lt;&lt;11)   <span class="comment">/* m (Note: This one is excluded from NOTIFY_ALL on purpose) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_ALL (NOTIFY_GENERIC | NOTIFY_STRING | NOTIFY_LIST | NOTIFY_SET | NOTIFY_HASH | NOTIFY_ZSET | NOTIFY_EXPIRED | NOTIFY_EVICTED | NOTIFY_STREAM) <span class="comment">/* A flag */</span></span></span><br></pre></td></tr></table></figure><p>在notify.c文件中，只有三个功能函数，下面让我们来看看源码实现吧。</p><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keyspace events notification */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyspaceEventsStringToFlags</span><span class="params">(<span class="keyword">char</span> *classes)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">keyspaceEventsFlagsToString</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 因为redis命令中事件类型是字符类型，所以会使用一个int类型的flags参数</span></span><br><span class="line"><span class="comment"> * 通过多个字符按位或运算保存起来，方便后面使用 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyspaceEventsStringToFlags</span><span class="params">(<span class="keyword">char</span> *classes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = classes;</span><br><span class="line">    <span class="keyword">int</span> c, flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = *p++) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: flags |= NOTIFY_ALL; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>: flags |= NOTIFY_GENERIC; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: flags |= NOTIFY_STRING; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: flags |= NOTIFY_LIST; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: flags |= NOTIFY_SET; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: flags |= NOTIFY_HASH; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>: flags |= NOTIFY_ZSET; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: flags |= NOTIFY_EXPIRED; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: flags |= NOTIFY_EVICTED; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>: flags |= NOTIFY_KEYSPACE; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: flags |= NOTIFY_KEYEVENT; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: flags |= NOTIFY_STREAM; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: flags |= NOTIFY_KEY_MISS; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将flags参数转为sds类型</span></span><br><span class="line"><span class="function">sds <span class="title">keyspaceEventsFlagsToString</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    sds res;</span><br><span class="line"></span><br><span class="line">    res = sdsempty();</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; NOTIFY_ALL) == NOTIFY_ALL) &#123;</span><br><span class="line">        res = sdscatlen(res,<span class="string">&quot;A&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_GENERIC) res = sdscatlen(res,<span class="string">&quot;g&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_STRING) res = sdscatlen(res,<span class="string">&quot;$&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_LIST) res = sdscatlen(res,<span class="string">&quot;l&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_SET) res = sdscatlen(res,<span class="string">&quot;s&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_HASH) res = sdscatlen(res,<span class="string">&quot;h&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_ZSET) res = sdscatlen(res,<span class="string">&quot;z&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_EXPIRED) res = sdscatlen(res,<span class="string">&quot;x&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_EVICTED) res = sdscatlen(res,<span class="string">&quot;e&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_STREAM) res = sdscatlen(res,<span class="string">&quot;t&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NOTIFY_KEYSPACE) res = sdscatlen(res,<span class="string">&quot;K&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NOTIFY_KEYEVENT) res = sdscatlen(res,<span class="string">&quot;E&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NOTIFY_KEY_MISS) res = sdscatlen(res,<span class="string">&quot;m&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用Redis的订阅和发布功能来发送键空间事件通知。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果任何模块对事件感兴趣，将立即通知感兴趣的模块。这将绕过通知配置，但模块引擎将仅在事件类型与事件订阅者感兴趣的类型匹配时调用事件订阅者。 */</span></span><br><span class="line">     moduleNotifyKeyspaceEvent(type, event, key, dbid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知功能关闭，直接退出 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(server.notify_keyspace_events &amp; type)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事件对象</span></span><br><span class="line">    eventobj = createStringObject(event,<span class="built_in">strlen</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 键空间通知，格式为__keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">&quot;__keyspace@&quot;</span>,<span class="number">11</span>);</span><br><span class="line">        len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">&quot;__:&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        <span class="comment">// 调用pub/sub命令发送</span></span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 键时间通知，格式为__keyevente@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">&quot;__keyevent@&quot;</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">&quot;__:&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        <span class="comment">// 调用pub/sub命令发送</span></span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：notify.c/server.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 事件通知概述&lt;/strong&gt;&lt;br&gt;对于Redis服务器，它可以通过订阅发布功能来发送服务器中的键空间事件。所谓的键空间事件，就是数据库中键的增加、修改和删除等操作，用于告知收听该类事件的客户端当前数据库中执行了哪些操作。客户端可以通过 订阅与发布功能（pub/sub）功能，来接收那些以某种方式改动了Redis数据集的事件。&lt;br&gt;目前Redis的订阅与发布功能采用的是发送即忘（fire and forget）的策略，当订阅事件的客户端断线时，它会丢失所有在断线期间分发给它的事件。&lt;br&gt;订阅与发布功能（pub/sub）功能实现在pubsub.c中，后续会在博文中讲到。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="3-database" scheme="http://example.com/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-数据库的实现</title>
    <link href="http://example.com/Redis/3-database/redis-parse-db/"/>
    <id>http://example.com/Redis/3-database/redis-parse-db/</id>
    <published>2020-09-22T03:09:36.000Z</published>
    <updated>2020-09-22T03:30:13.691Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：db.c/server.h</p><p><strong>1. Redis数据库介绍：</strong><br>在前两个阶段中，我们学习了redis数据结构的实现，而这些数据结构都是为了实现数据库功能做的铺垫，下面，让我们一起来看看redis数据库是如何实现的吧。  </p><p>Redis服务器在运行的时候会创建大量的redisObject对象，这些对象都是存在redisDb中的，为了快速索引到某个对象，redisDb采用了dict字典结构设计。<br>启动Redis后，Redis服务器将所有数据库都保存在redisServer结构的db数组中，db数组的每一项都是一个redisDb结构，代表一个数据库。根据配置参数，redis服务器在初始化的时候，默认情况下会创建16个数据库，由dbnum决定(可通过<code>databases</code>配置修改)，每个数据库都是独立的。<br>客户端可以通过<code>select</code>命令来切换数据库，如<code>select 1</code>会切换到数据库号为 1 的数据库，select是通过修改客户端的db指针，指针指向不同的数据库来实现数据库的切换操作的。  </p><a id="more"></a><p>操作如下图：<br><img src="/Redis/3-database/redis-parse-db/db0.png" alt="dbSelect"></p><p>redis服务结构体如下：<br><img src="/Redis/3-database/redis-parse-db/db1.png" alt="redisServer"></p><p>redis通过字典保存数据库中的所有键值对，我们称之为键空间(key space)。键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种redis对象。</li></ul><p><strong>2. redis数据库支持增删改查(curd)操作：</strong></p><p><strong>①.添加新键</strong><br>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间的字典里，其中键为字符串对象，值为任意一种类型的redis对象。<br><strong>②.删除键</strong><br>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。<br><strong>③.更新键</strong><br>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象类型的不同，更新的方法也不同。<br><strong>④.查询键</strong><br>对一个数据库键进行查询，实际上就是在键空间中取出键所对应的值对象，根据值对象类型的不同，取值的方法也不同。  </p><p>除了以上操作外，redis还有很多针对数据库本身的命令，也是通过对键空间进行处理来完成的。  </p><p><strong>3. 读写键空间时的维护操作：</strong><br>当使用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的操作，其中包括：</p><ul><li>在读取一个键之后（读写操作都需要先对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中(hit)次数或不命中(miss)次数，这两个值可以在<code>INFO stat</code>命令的<code>keyspace_hits</code>和<code>keyspace_misses</code>属性中查看。</li><li>在读取一个键之后，服务器会更新键的LRU或LFU时间，这个值用于计算键的闲置时间，可以使用<code>OBJECT idletime [key]</code>命令查看key的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期的键，然后才执行余下操作。</li><li>如果有客户端使用<code>WATCH</code>命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏(dirty)，从而让事务程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键后，都会对脏(dirty)键计数器的值增 1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器会按配置发送相应的数据库通知。</li></ul><p><strong>4. 设置键的生存时间或过期时间：</strong><br>Redis有四个命令可以设置键的过期时间，包括expire,pexpire,expireat,pexpireat，不过这四个命令最后都会转化成pexpireat命令来实现。<br>RedisDb中，使用一个字典expires来存储带有过期时间的键，称之为过期字典。</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间（精度为毫秒的unix时间戳）。</li></ul><p><strong>5. 过期键的删除策略：</strong><br>如果一个键过期了，那么它什么时候被删除呢？redis有三种删除策略：</p><ol><li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，执行删除操作，如果没过期，则返回该键。</li><li>定期删除：每隔一段时间，程序对数据库进行检查，删除过期的键。至于要删除多少过期键，以及要检查多少个数据库，则由算法实现。</li></ol><p>这几种方式各有利弊。</p><ol><li>定时删除对内存最为友好，当键过期时，会立即删除该键，释放内存。不过对CPU最不友好，因为每一个键都需要创建一个定时器，这种行为可能会占用相当一部分的CPU时间。此外，创建定时器需要用到Redis服务器中的时间时间，而当前时间时间的实现方式-无序链表查找一个事件的时间复杂度为O(N)，不能高效地处理大量时间事件。</li><li>惰性删除策略对CPU是最友好的，但是对内存最不友好。如果一个键已经过期，这个键又保留在数据库中，那么内存就会一直占用不释放，由db.c/expireIfNeeded()函数实现惰性删除。</li><li>定期删除算是前两种策略的一种整合和折中，定期策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率减少删除操作对CPU时间的影响。定期删除过期键可以有效地减少因为过期键带来的内存浪费。</li></ol><p>下面我们通过代码来看看redis数据库的实现吧。</p><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redisServer</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;    <span class="comment">/* 数据库数组*/</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;      <span class="comment">/* 数据库的总个数 */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redisDb</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库的键空间 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期字典 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* 存放所有造成阻塞的键及其客户端 */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* 存放push操作添加的造成阻塞的键，便于解阻塞 */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* 被watch命令监控的键和相应的客户端，用于multi/exec */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* 数据库编号 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 平均生存时间 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* 要尝试逐项进行碎片整理的密钥名称列表 */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeExpire</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 移除key的过期时间，当只有在db-&gt;dict中存在key时，才会移除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> lazy)</span></span>; <span class="comment">// 将过期key的del操作通知给slaves和AOF文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 被动的删除过期key。当用户对key进行操作时，首先判断key是否过期，过期则删除返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 返回key的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(client *c, redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span></span>; <span class="comment">// 设置key的过期时间</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// db中查找元素的底层实现</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 调用lookupKeyReadWithFlags，需要修改键的访问时间</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 调用lookupKeyWriteWithFlags，需要修改键的访问时间</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyReadOrReply</span><span class="params">(client *c, robj *key, robj *reply)</span></span>; <span class="comment">// 调用lookupKeyRead，未找到则将描述信息加入到缓冲区输出到客户端</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteOrReply</span><span class="params">(client *c, robj *key, robj *reply)</span></span>; <span class="comment">// 调用lookupKeyWrite，未找到则将描述信息加入到缓冲区输出到客户端</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 首先从过期字典中查找键是否过期，未过期调用lookupKey来查找元素，并更新键的命中或不命中的属性</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 首先从过期字典中查找键是否过期并调用lookupKey来查找元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 键空间增加键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 重写键的值，继承源键的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genericSetKey</span><span class="params">(redisDb *db, robj *key, robj *val, <span class="keyword">int</span> keepttl)</span></span>; <span class="comment">// 高阶函数，如果key不存在则增加，key存在则修改值，可选择是否删除过期字典中的key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 调用genericSetKey，并从过期字典中删除该key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbExists</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// key是否存在</span></span><br><span class="line"><span class="function">robj *<span class="title">dbRandomKey</span><span class="params">(redisDb *db)</span></span>; <span class="comment">// 随机获取key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 同步删除键空间和过期字典中的key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 通过redis延迟删除配置，选择dbSyncDelete或者dbAsyncDelete</span></span><br><span class="line"><span class="function">robj *<span class="title">dbUnshareStringValue</span><span class="params">(redisDb *db, robj *key, robj *o)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">emptyDb</span><span class="params">(<span class="keyword">int</span> dbnum, <span class="keyword">int</span> flags, <span class="keyword">void</span>(callback)(<span class="keyword">void</span>*))</span></span>; <span class="comment">// 调用emptyDbGeneric清空数据库</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">emptyDbGeneric</span><span class="params">(redisDb *dbarray, <span class="keyword">int</span> dbnum, <span class="keyword">int</span> flags, <span class="keyword">void</span>(callback)(<span class="keyword">void</span>*))</span></span>; <span class="comment">// 清空数据库</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAllDataAndResetRDB</span><span class="params">(<span class="keyword">int</span> flags)</span></span>; <span class="comment">// 清空所有的数据库并重置</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dbTotalServerKeyCount</span><span class="params">()</span></span>; <span class="comment">// 统计所有数据库的键数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(client *c, <span class="keyword">int</span> id)</span></span>; <span class="comment">// 选择数据库</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 每次修改键空间的键时，都会调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalFlushedDb</span><span class="params">(<span class="keyword">int</span> dbid)</span></span>; <span class="comment">// 清空数据库时调用此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// redis-cluster集群 slot槽点相关函数，将在cluster中解释</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot, robj **keys, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">countKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">delKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verifyClusterConfigWithData</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> cursor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseScanCursorOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> *cursor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slotToKeyAdd</span><span class="params">(robj *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slotToKeyDel</span><span class="params">(robj *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slotToKeyFlush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 异步删除过期key，放入惰性删除列表中，将在另一个bio.c线程中回收</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emptyDbAsync</span><span class="params">(redisDb *db)</span></span>; <span class="comment">// 异步清空数据库，创建新库，将旧库放入惰性删除列表中，将在另一个bio.c线程中回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* API to get key arguments from commands */</span></span><br><span class="line"><span class="comment">// 一些命令的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getKeysFromCommand</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>; <span class="comment">// 获取所有的 keyIndex</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getKeysFreeResult</span><span class="params">(<span class="keyword">int</span> *result)</span></span>; <span class="comment">// 释放keyindex</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">zunionInterGetKeys</span><span class="params">(struct redisCommand *cmd,robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">evalGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">sortGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">migrateGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">georadiusGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">xreadGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">memoryGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：db.c/server.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Redis数据库介绍：&lt;/strong&gt;&lt;br&gt;在前两个阶段中，我们学习了redis数据结构的实现，而这些数据结构都是为了实现数据库功能做的铺垫，下面，让我们一起来看看redis数据库是如何实现的吧。  &lt;/p&gt;
&lt;p&gt;Redis服务器在运行的时候会创建大量的redisObject对象，这些对象都是存在redisDb中的，为了快速索引到某个对象，redisDb采用了dict字典结构设计。&lt;br&gt;启动Redis后，Redis服务器将所有数据库都保存在redisServer结构的db数组中，db数组的每一项都是一个redisDb结构，代表一个数据库。根据配置参数，redis服务器在初始化的时候，默认情况下会创建16个数据库，由dbnum决定(可通过&lt;code&gt;databases&lt;/code&gt;配置修改)，每个数据库都是独立的。&lt;br&gt;客户端可以通过&lt;code&gt;select&lt;/code&gt;命令来切换数据库，如&lt;code&gt;select 1&lt;/code&gt;会切换到数据库号为 1 的数据库，select是通过修改客户端的db指针，指针指向不同的数据库来实现数据库的切换操作的。  &lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="3-database" scheme="http://example.com/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-有序集合对象zset</title>
    <link href="http://example.com/Redis/2-object/redis-parse-zset/"/>
    <id>http://example.com/Redis/2-object/redis-parse-zset/</id>
    <published>2020-09-22T03:07:53.000Z</published>
    <updated>2020-09-22T03:31:47.723Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：t_zset.c/server.h</p><p>zset对象底层编码方式有两种，<code>ziplist</code>或<code>skiplist</code>。<br>使用ziplist编码需要同时满足以下两个条件：  </p><ul><li>有序集合对象中所有元素的大小都小于64字节。（可通过redis.conf配置：zset_max_ziplist_value）</li><li>有序集合对象保存的元素个数不超过128个。（可通过redis.conf配置：zset_max_ziplist_entries）</li></ul><a id="more"></a><p>ziplist的结构如下：<br><img src="/Redis/2-object/redis-parse-zset/t_zset_ziplist.png" alt="zset_ziplist"><br>如上图，集合的元素由两个紧挨着的节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。压缩列表内的元素按照分值从小到大排序，分值小的靠近表头，分值大的靠近表尾。  </p><p>zset编码底层实际上是由skiplist和dict构成的：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>为什么会使用两种数据结构呢？其实，使用单一的数据结构也是可以实现有序集合对象的，比如单独使用字典，查找时间复杂度为O(1)，因为字典是无序的，所以当执行范围型操作时，首先要对所有元素进行排序，这里就会增加时间复杂度和空间复杂度了。当单独使用跳跃表时，查找的时间复杂度将会是O(logN)。所以，将两者的优势结合，将会很大的提高性能。另外，两种数据结构都会通过指针来共享相同的元素和分值，所以不会对内存造成不必要的浪费。</p><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th><th>时间复杂度</th></tr></thead><tbody><tr><td>ZCARD</td><td>返回key的有序集元素个数</td><td>O(1)</td></tr><tr><td>ZCOUNT</td><td>返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员</td><td>O(log(N))</td></tr><tr><td>ZINCRBY</td><td>为有序集key的成员member的score值加上增量increment</td><td>O(log(N))</td></tr><tr><td>ZINTERSTORE</td><td>计算给定的numkeys个有序集合的交集，并且把结果放到destination中</td><td>O(N<em>K)+O(M</em>log(M))，最坏的情况，N是最小的输入排序集，K是输入排序集的数量，M是结果排序集中的元素的数量</td></tr><tr><td>ZLEXCOUNT</td><td>用于计算有序集合中指定成员之间的成员数量</td><td>O(log(N))</td></tr><tr><td>ZPOPMAX</td><td>删除并返回有序集合key中的最多count个具有最高得分的成员</td><td>O(log(N)*M)</td></tr><tr><td>ZPOPMIN</td><td>删除并返回有序集合key中的最多count个具有最低得分的成员</td><td>O(log(N)*M)</td></tr><tr><td>ZRANGE</td><td>返回存储在有序集合key中的指定范围的元素</td><td>O(log(N)+M)</td></tr><tr><td>ZRANGEBYLEX</td><td>返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同</td><td>O(log(N)+M)</td></tr><tr><td>ZREVRANGEBYLEX</td><td>返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同</td><td>O(log(N)+M)</td></tr><tr><td>ZRANGEBYSCORE</td><td>返回指定分数范围的元素列表</td><td>O(log(N)+M)</td></tr><tr><td>ZRANK</td><td>返回有序集key中成员member的排名</td><td>O(log(N))</td></tr><tr><td>ZREM</td><td>在key集合中移除指定的元素</td><td>O(M*log(N))</td></tr><tr><td>ZREMRANGEBYLEX</td><td>删除名称按字典由低到高排序成员之间所有成员</td><td>O(log(N)+M)</td></tr><tr><td>ZREMRANGEBYRANK</td><td>移除有序集key中，指定排名(rank)区间内的所有成员</td><td>O(log(N)+M)</td></tr><tr><td>ZREMRANGEBYSCORE</td><td>移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员</td><td>O(log(N)+M)</td></tr><tr><td>ZREVRANGE</td><td>返回有序集key中，指定区间内的成员</td><td>O(log(N)+M)</td></tr><tr><td>ZREVRANGEBYSCORE</td><td>返回有序集合中指定分数区间内的成员，分数由高到低排序</td><td>O(log(N)+M)</td></tr><tr><td>ZREVRANK</td><td>返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列</td><td>O(log(N))</td></tr><tr><td>ZSCORE</td><td>返回有序集key中，成员member的score值</td><td>O(1)</td></tr><tr><td>ZUNIONSTORE</td><td>计算给定的numkeys个有序集合的并集，并且把结果放到destination中</td><td>O(N)+O(M log(M))</td></tr><tr><td>ZSCAN</td><td>用于迭代集合类型中的集合成员</td><td>O(1)</td></tr></tbody></table></div><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcardCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcountCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincrbyCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zinterstoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlexcountCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zpopmaxCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zpopminCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangeCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebylexCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebylexCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebyscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrankCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebylexCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyrankCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangeCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebyscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrankCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zunionstoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscanCommand</span><span class="params">(client *c)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr><p>添加命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数含义：  </span></span><br><span class="line"><span class="comment">* XX: 仅仅更新存在的成员，不添加新成员。</span></span><br><span class="line"><span class="comment">* NX: 不更新存在的成员。只添加新成员。</span></span><br><span class="line"><span class="comment">* CH: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 changed 的意思)。</span></span><br><span class="line"><span class="comment">*     更改的元素是新添加的成员，已经存在的成员更新分数。 所以在命令中指定的成员有相同的分数将不</span></span><br><span class="line"><span class="comment">*     被计算在内。注：在通常情况下，ZADD返回值只计算新添加成员的数量。</span></span><br><span class="line"><span class="comment">* INCR: 当ZADD指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作。 */</span></span><br><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    zaddGenericCommand(c,ZADD_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincrbyCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    zaddGenericCommand(c,ZADD_INCR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nanerr = <span class="string">&quot;resulting score is not a number (NaN)&quot;</span>;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">0</span>, *scores = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> j, elements;</span><br><span class="line">    <span class="keyword">int</span> scoreidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> added = <span class="number">0</span>;      <span class="comment">/* Number of new elements added. */</span></span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>;    <span class="comment">/* Number of elements with updated score. */</span></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;  <span class="comment">/* Number of elements processed, may remain zero with</span></span><br><span class="line"><span class="comment">                           options like XX. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析命令参数 */</span></span><br><span class="line">    scoreidx = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class="line">        <span class="keyword">char</span> *opt = c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;nx&quot;</span>)) flags |= ZADD_NX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;xx&quot;</span>)) flags |= ZADD_XX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;ch&quot;</span>)) flags |= ZADD_CH;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;incr&quot;</span>)) flags |= ZADD_INCR;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        scoreidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> incr = (flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nx = (flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx = (flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch = (flags &amp; ZADD_CH) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断参数合法性（元素-分值对） */</span></span><br><span class="line">    elements = c-&gt;argc-scoreidx;</span><br><span class="line">    <span class="keyword">if</span> (elements % <span class="number">2</span> || !elements) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查不兼容的选项 */</span></span><br><span class="line">    <span class="keyword">if</span> (nx &amp;&amp; xx) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;XX and NX options at the same time are not compatible&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (incr &amp;&amp; elements &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;INCR option supports a single increment-element pair&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查分数参数是否合格 */</span></span><br><span class="line">    scores = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*elements);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class="number">2</span>],&amp;scores[j],<span class="literal">NULL</span>)</span><br><span class="line">            != C_OK) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* db中查找集合 */</span></span><br><span class="line">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    <span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) <span class="keyword">goto</span> reply_to_client; <span class="comment">/* 没有找到key，并且设置了 XX 参数，则什么都不做 */</span></span><br><span class="line">        <span class="comment">// 如果db中没有key，则创建zset对象</span></span><br><span class="line">        <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">        &#123;</span><br><span class="line">            zobj = createZsetObject();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zobj = createZsetZiplistObject();</span><br><span class="line">        &#125;</span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zobj-&gt;type != OBJ_ZSET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> newscore;</span><br><span class="line">        score = scores[j];</span><br><span class="line">        <span class="keyword">int</span> retflags = flags;</span><br><span class="line"></span><br><span class="line">        ele = c-&gt;argv[scoreidx+<span class="number">1</span>+j*<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        <span class="keyword">int</span> retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,nanerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_ADDED) added++;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class="line">        <span class="keyword">if</span> (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class="line">        score = newscore;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (added+updated);</span><br><span class="line"></span><br><span class="line">reply_to_client:</span><br><span class="line">    <span class="keyword">if</span> (incr) &#123; <span class="comment">/* ZINCRBY or INCR option. */</span></span><br><span class="line">        <span class="keyword">if</span> (processed)</span><br><span class="line">            addReplyDouble(c,score);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyNull(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ZADD. */</span></span><br><span class="line">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    <span class="keyword">if</span> (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class="line">            incr ? <span class="string">&quot;zincr&quot;</span> : <span class="string">&quot;zadd&quot;</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>其他命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br><span class="line">ZCOUNT key min max</span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX]</span><br><span class="line">ZLEXCOUNT key min max</span><br><span class="line">ZPOPMAX key [count]</span><br><span class="line">ZPOPMIN key [count]</span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">ZRANK key member</span><br><span class="line">ZREM key member [member ...]</span><br><span class="line">ZREMRANGEBYLEX key min max</span><br><span class="line">ZREMRANGEBYRANK key start stop</span><br><span class="line">ZREMRANGEBYSCORE key min max</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">ZREVRANK key member</span><br><span class="line">ZSCORE key member</span><br><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX]</span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：t_zset.c/server.h&lt;/p&gt;
&lt;p&gt;zset对象底层编码方式有两种，&lt;code&gt;ziplist&lt;/code&gt;或&lt;code&gt;skiplist&lt;/code&gt;。&lt;br&gt;使用ziplist编码需要同时满足以下两个条件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有序集合对象中所有元素的大小都小于64字节。（可通过redis.conf配置：zset_max_ziplist_value）&lt;/li&gt;
&lt;li&gt;有序集合对象保存的元素个数不超过128个。（可通过redis.conf配置：zset_max_ziplist_entries）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="2-object" scheme="http://example.com/categories/Redis/2-object/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-集合对象set</title>
    <link href="http://example.com/Redis/2-object/redis-parse-set/"/>
    <id>http://example.com/Redis/2-object/redis-parse-set/</id>
    <published>2020-09-22T02:58:05.000Z</published>
    <updated>2020-09-22T03:31:33.946Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：t_set.c/server.h</p><p>set对象底层编码方式有两种，<code>intset</code>或<code>hashtable</code>。<br>使用intset编码的条件：  </p><ul><li>集合对象中所有元素都是整数值。</li><li>集合对象保存的元素个数不超过512个。（可通过redis.conf配置：set_max_intset_entries）</li></ul><a id="more"></a><p>下面让我们测试一下：<br>例1：<br><img src="/Redis/2-object/redis-parse-set/t_set_intset1.png" alt="intset1"><br>当添加非整数的字符串时，则会转为hashtable编码<br><img src="/Redis/2-object/redis-parse-set/t_set_intset2.png" alt="intset2">  </p><p>例2：<br>插入512个整数，使用的是intset编码<br><img src="/Redis/2-object/redis-parse-set/t_set_intset3.png" alt="intset3"><br>当插入第513个整数时，将会转为hashtable编码<br><img src="/Redis/2-object/redis-parse-set/t_set_intset4.png" alt="intset4">  </p><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th><th>时间复杂度</th></tr></thead><tbody><tr><td>SADD</td><td>添加一个或多个元素到集合里</td><td>O(N)，N为添加的元素个数</td></tr><tr><td>SCARD</td><td>返回集合存储的key的基数 (集合元素的数量)</td><td>O(1)</td></tr><tr><td>SISMEMBER</td><td>返回成员member是否是存储的集合key的成员</td><td>O(1)</td></tr><tr><td>SINTER</td><td>返回指定所有的集合的成员的交集</td><td>O(N*M)，其中N是最小集合的基数，M是集合的数目</td></tr><tr><td>SINTERSTORE</td><td>类似SINTER，将结果存放到destination集合中，如果destination存在，则覆盖重写</td><td>O(N*M)，其中N是最小集合的基数，M是集合的数目</td></tr><tr><td>SDIFF</td><td>返回一个集合与给定集合的差集的元素</td><td>O(N)，N为所有集合的元素总数</td></tr><tr><td>SDIFFSTORE</td><td>类似SDIFF，将结果存放到destination集合中，如果destination存在，则覆盖重写</td><td>O(N)，N为所有集合的元素总数</td></tr><tr><td>SUNION</td><td>返回给定的多个集合的并集中的所有成员</td><td>O(N)</td></tr><tr><td>SUNIONSTORE</td><td>类似SUNION，将结果存放到destination集合中，如果destination存在，则覆盖重写</td><td>平均O(N)</td></tr><tr><td>SMEMBERS</td><td>返回key集合所有的元素，由SINTER实现</td><td>O(N)，N为该集合元素总数</td></tr><tr><td>SMOVE</td><td>将member从source集合移动到destination集合中</td><td>O(1)</td></tr><tr><td>SPOP</td><td>从存储在key的集合中移除并返回一个或多个随机元素</td><td>O(1)</td></tr><tr><td>SRANDMEMBER</td><td>类似SPOP，区别是该命令不删除元素</td><td>O(N)，N为指定count的值</td></tr><tr><td>SREM</td><td>在key集合中移除指定的元素</td><td>O(N)，N为指定的元素个数</td></tr><tr><td>SSCAN</td><td>用于迭代集合类型中的集合成员</td><td>O(1)</td></tr></tbody></table></div><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sadd命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scardCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// scard命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sdiff命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffstoreCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sdiffstore命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sinter和smembers命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterstoreCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sinterstore命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sismemberCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sismember命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoveCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// smove命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// spop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srandmemberCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// srandmember命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sremCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// srem命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sscanCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sscan命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sunion命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionstoreCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sunionstore命令</span></span><br></pre></td></tr></table></figure><h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr><p>插入命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">int</span> j, added = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果db中不存在该key，则根据元素类型选择使用intset编码或者hashtable编码创建set集合</span></span><br><span class="line">        <span class="built_in">set</span> = setTypeCreate(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="built_in">set</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;type != OBJ_SET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeAdd(<span class="built_in">set</span>,c-&gt;argv[j]-&gt;ptr)) added++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (added) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_SET,<span class="string">&quot;sadd&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += added;</span><br><span class="line">    addReplyLongLong(c,added);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">/* Convert to regular set when the intset contains</span></span><br><span class="line"><span class="comment">                 * too many entries. */</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Failed to get integer from object, convert to regular set. */</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The set *was* an intset and this value is not integer</span></span><br><span class="line"><span class="comment">             * encodable, so dictAdd should always work. */</span></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>交集命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line">SMEMBERS key <span class="comment">// 该命令是通过SINTER命令实现的</span></span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setkeys：集合数组指针</span></span><br><span class="line"><span class="comment">// setnum：集合数量（命令中key的个数）</span></span><br><span class="line"><span class="comment">// dstkey：结果集是否添加到新的集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterGenericCommand</span><span class="params">(client *c, robj **setkeys,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">unsigned</span> <span class="keyword">long</span> setnum, robj *dstkey)</span> </span>&#123;</span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    sds elesds;</span><br><span class="line">    <span class="keyword">int64_t</span> intobj;</span><br><span class="line">    <span class="keyword">void</span> *replylen = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dbDelete(c-&gt;db,dstkey)) &#123;</span><br><span class="line">                    signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">                    server.dirty++;</span><br><span class="line">                &#125;</span><br><span class="line">                addReply(c,shared.czero);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReply(c,shared.emptyset[c-&gt;resp]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[j] = setobj; <span class="comment">// 从db中获取的集合对象存入到临时数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据集合的大小从小到大进行排序</span></span><br><span class="line">    qsort(sets,setnum,<span class="keyword">sizeof</span>(robj*),qsortCompareSetsByCardinality);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        replylen = addReplyDeferredLen(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dstset = createIntsetObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    si = setTypeInitIterator(sets[<span class="number">0</span>]); <span class="comment">// 从第一个集合开始遍历</span></span><br><span class="line">    <span class="comment">// 此处是while+for循环，所有时间复杂度是O(N*M)</span></span><br><span class="line">    <span class="keyword">while</span>((encoding = setTypeNext(si,&amp;elesds,&amp;intobj)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="comment">// 判断第一个集合的元素是否在集合j中</span></span><br><span class="line">            <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_INTSET &amp;&amp;</span><br><span class="line">                    !intsetFind((intset*)sets[j]-&gt;ptr,intobj))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                    elesds = sdsfromlonglong(intobj);</span><br><span class="line">                    <span class="keyword">if</span> (!setTypeIsMember(sets[j],elesds)) &#123;</span><br><span class="line">                        sdsfree(elesds);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sdsfree(elesds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!setTypeIsMember(sets[j],elesds)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT)</span><br><span class="line">                    addReplyBulkCBuffer(c,elesds,sdslen(elesds));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    addReplyBulkLongLong(c,intobj);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                    elesds = sdsfromlonglong(intobj);</span><br><span class="line">                    setTypeAdd(dstset,elesds);</span><br><span class="line">                    sdsfree(elesds);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setTypeAdd(dstset,elesds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setTypeReleaseIterator(si);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">        <span class="keyword">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,<span class="string">&quot;sinterstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setDeferredSetLen(c,replylen,cardinality);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>并集&amp;差集命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">并集：</span><br><span class="line">SUNION key [key ...]</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line">差集：</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_UNION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_UNION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_DIFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_DIFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionDiffGenericCommand</span><span class="params">(client *c, robj **setkeys, <span class="keyword">int</span> setnum,</span></span></span><br><span class="line"><span class="function"><span class="params">                              robj *dstkey, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">int</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> diff_algo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            sets[j] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[j] = setobj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 差集算法有两种：</span></span><br><span class="line"><span class="comment">     * 算法1： 时间复杂度为O(N*M)，N是第一个集合的大小，M是集合的总数</span></span><br><span class="line"><span class="comment">     * 算法2： 时间复杂度为O(N)，N是所有集合的元素总数</span></span><br><span class="line"><span class="comment">     * 根据输入条件计算选择使用哪种算法 */</span></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> algo_one_work = <span class="number">0</span>, algo_two_work = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sets[j] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            algo_one_work += setTypeSize(sets[<span class="number">0</span>]);</span><br><span class="line">            algo_two_work += setTypeSize(sets[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 算法1 具有更好的常数时间，并且如果有共同的元素，则执行的操作更少。 */</span></span><br><span class="line">        algo_one_work /= <span class="number">2</span>;</span><br><span class="line">        diff_algo = (algo_one_work &lt;= algo_two_work) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff_algo == <span class="number">1</span> &amp;&amp; setnum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            qsort(sets+<span class="number">1</span>,setnum<span class="number">-1</span>,<span class="keyword">sizeof</span>(robj*),</span><br><span class="line">                qsortCompareSetsByRevCardinality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个临时的set进行存储元素，如果是store模式，则存储该临时集合 */</span></span><br><span class="line">    dstset = createIntsetObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_UNION) &#123;</span><br><span class="line">        <span class="comment">/* 并集很简单，只需要把所有集合的元素放入到临时集合中就能得出 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* non existing keys are like empty sets */</span></span><br><span class="line"></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                sdsfree(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 差集算法1:</span></span><br><span class="line"><span class="comment">         * 通过迭代第一个集合的所有元素来进行差集判断，</span></span><br><span class="line"><span class="comment">         * 当第一个集合的元素不存在于其他所有的集合中时，</span></span><br><span class="line"><span class="comment">         * 才将元素插入到临时集合中。*/</span></span><br><span class="line">        si = setTypeInitIterator(sets[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* no key is an empty set. */</span></span><br><span class="line">                <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">break</span>; <span class="comment">/* same set! */</span></span><br><span class="line">                <span class="keyword">if</span> (setTypeIsMember(sets[j],ele)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">                <span class="comment">/* 当前元素不存在与其他集合中时，添加到临时集合dstset中 */</span></span><br><span class="line">                setTypeAdd(dstset,ele);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125;</span><br><span class="line">            sdsfree(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* 差集算法2:</span></span><br><span class="line"><span class="comment">         * 首先将第一个集合的元素插入到临时集合中，</span></span><br><span class="line"><span class="comment">         * 然后从中移除其他集合的所有元素。 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把第一个集合的元素添加到dstset中</span></span><br><span class="line">                    <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 从dstset中移除其他集合的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (setTypeRemove(dstset,ele)) cardinality--;</span><br><span class="line">                &#125;</span><br><span class="line">                sdsfree(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果临时集合dstset为空，则表示第一个集合的元素在其他集合中都存在，</span></span><br><span class="line"><span class="comment">             * 没有差集，直接退出循环 */</span></span><br><span class="line">            <span class="keyword">if</span> (cardinality == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        addReplySetLen(c,cardinality);</span><br><span class="line">        si = setTypeInitIterator(dstset);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyBulkCBuffer(c,ele,sdslen(ele));</span><br><span class="line">            sdsfree(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">        server.lazyfree_lazy_server_del ? freeObjAsync(dstset) :</span><br><span class="line">                                          decrRefCount(dstset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we have a target key where to store the resulting set</span></span><br><span class="line"><span class="comment">         * create this key with the result set inside */</span></span><br><span class="line">        <span class="keyword">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,</span><br><span class="line">                op == SET_OP_UNION ? <span class="string">&quot;sunionstore&quot;</span> : <span class="string">&quot;sdiffstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>其他命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br><span class="line">SCARD key</span><br><span class="line">SMOVE source destination member</span><br><span class="line">SPOP key [count]</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line">SREM key member [member ...]</span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：t_set.c/server.h&lt;/p&gt;
&lt;p&gt;set对象底层编码方式有两种，&lt;code&gt;intset&lt;/code&gt;或&lt;code&gt;hashtable&lt;/code&gt;。&lt;br&gt;使用intset编码的条件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集合对象中所有元素都是整数值。&lt;/li&gt;
&lt;li&gt;集合对象保存的元素个数不超过512个。（可通过redis.conf配置：set_max_intset_entries）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="2-object" scheme="http://example.com/categories/Redis/2-object/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-散列对象hash</title>
    <link href="http://example.com/Redis/2-object/redis-parse-hash/"/>
    <id>http://example.com/Redis/2-object/redis-parse-hash/</id>
    <published>2020-09-22T02:55:52.000Z</published>
    <updated>2020-09-22T03:30:11.644Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：t_hash.c/server.h  </p><p>hash对象底层编码方式有两种，<code>ziplist</code>或<code>hashtable</code>。<br>使用ziplist编码需要同时满足以下条件：  </p><ul><li>hash对象保存的键值对的键和值的字符串长度小于64字节（可通过redis.conf配置：hash_max_ziplist_value）</li><li>hash对象保存的键值对数小于512个（可通过redis.conf配置：hash_max_ziplist_entries）</li></ul><a id="more"></a><p>让我们来测试一下：<br><img src="/Redis/2-object/redis-parse-hash/t_hash_convert1.png" alt="hash_convert"><br>可以看到，当k2的value长度大于64字节时，不满足第一个条件，redis会将ziplist转为hashtable。<br>第二个条件可以自行测试。  </p><p>下面介绍一下hash对象是如何使用ziplist进行存储的：<br>当有新的键值对需要加入hash对象中时，程序会先将保存了键的节点推入到压缩列表的表尾，然后再将存有值的节点推入到压缩列表表尾。所以，同一个键值对的两个节点总是紧挨在一起的，键在前，值在后。<br><img src="/Redis/2-object/redis-parse-hash/t_hash_ziplist.png" alt="hash_ziplist"></p><p>ziplist的实现方式可查看<a href="../redis-parse-ziplist">Redis源码-压缩列表ziplist</a>。<br>hashtable的实现方式可查看<a href="../redis-parse-dict">Redis源码-字典dict</a>。</p><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th><th>时间复杂度</th></tr></thead><tbody><tr><td>HSET</td><td>设置key指定的哈希集中指定字段的值</td><td>O(1)</td></tr><tr><td>HSETNX</td><td>只在key指定的哈希集中不存在指定的字段时，设置字段的值</td><td>O(1)</td></tr><tr><td>HMSET</td><td>设置key指定的哈希集中指定多个字段的值</td><td>O(N)，N为字段数</td></tr><tr><td>HGET</td><td>返回key指定的哈希集中该字段所关联的值</td><td>O(1)</td></tr><tr><td>HMGET</td><td>返回key指定的哈希集中指定多个字段的值</td><td>O(N)，N为字段数</td></tr><tr><td>HGETALL</td><td>返回key指定的哈希集中所有的字段和值</td><td>O(N)，N为hash的size</td></tr><tr><td>HVALS</td><td>返回key指定的哈希集中所有字段的值</td><td>O(N)，N为hash的size</td></tr><tr><td>HDEL</td><td>从key指定的哈希集中移除指定的域</td><td>O(N)，N是被删除的字段数量</td></tr><tr><td>HEXISTS</td><td>返回hash里面field是否存在</td><td>O(1)</td></tr><tr><td>HKEYS</td><td>返回key指定的哈希集中所有字段的名字</td><td>O(N)，N为hash的size</td></tr><tr><td>HLEN</td><td>返回key指定的哈希集包含的字段的数量</td><td>O(1)</td></tr><tr><td>HSCAN</td><td>用于迭代Hash类型中的键值对</td><td>O(1)</td></tr><tr><td>HSTRLEN</td><td>返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0</td><td>O(1)</td></tr><tr><td>HINCRBY</td><td>增加key指定的哈希集中指定字段的数值</td><td>O(1)</td></tr><tr><td>HINCRBYFLOAT</td><td>为指定key的hash的field字段值执行float类型的increment加</td><td>O(1)</td></tr></tbody></table></div><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hset命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetnxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hsetnx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmsetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hmset命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hget命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hmgetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hmget命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetallCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hgetall命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hvalsCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hvals命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdelCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hdel命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexistsCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hexists命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hkeysCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hkeys命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hlenCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hlen命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hscanCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hscan命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hstrlenCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hstrlen命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hincrbyCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hincrby命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hincrbyfloatCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// hincrbyfloat命令</span></span><br></pre></td></tr></table></figure><h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr><p>插入命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, created = <span class="number">0</span>;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;wrong number of arguments for HMSET&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从db中查找hash对象，如果不存在则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,c-&gt;argc<span class="number">-1</span>); <span class="comment">// 判断是否需要转成hashtable编码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; c-&gt;argc; i += <span class="number">2</span>)</span><br><span class="line">        created += !hashTypeSet(o,c-&gt;argv[i]-&gt;ptr,c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,HASH_SET_COPY); <span class="comment">// 插入键值对</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HMSET (deprecated) and HSET return value is different. */</span></span><br><span class="line">    <span class="keyword">char</span> *cmdname = c-&gt;argv[<span class="number">0</span>]-&gt;ptr;</span><br><span class="line">    <span class="keyword">if</span> (cmdname[<span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span> || cmdname[<span class="number">1</span>] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">/* HSET */</span></span><br><span class="line">        addReplyLongLong(c, created);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* HMSET */</span></span><br><span class="line">        addReply(c, shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_HASH,<span class="string">&quot;hset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeTryConversion</span><span class="params">(robj *o, robj **argv, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != OBJ_ENCODING_ZIPLIST) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sdsEncodedObject(argv[i]) &amp;&amp;</span><br><span class="line">            sdslen(argv[i]-&gt;ptr) &gt; server.hash_max_ziplist_value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果插入的键值对单个字符大于hash_max_ziplist_value（默认64字节），则需要转成hashtable编码</span></span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeConvert</span><span class="params">(robj *o, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        hashTypeConvertZiplist(o, enc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Not implemented&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeConvertZiplist</span><span class="params">(robj *o, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    serverAssert(o-&gt;encoding == OBJ_ENCODING_ZIPLIST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="comment">/* Nothing to do... */</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enc == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        hashTypeIterator *hi;</span><br><span class="line">        dict *dict;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        hi = hashTypeInitIterator(o); <span class="comment">// 获取hash对象（不同编码的）迭代器</span></span><br><span class="line">        dict = dictCreate(&amp;hashDictType, <span class="literal">NULL</span>); <span class="comment">// 创建字典</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历ziplist取出键值对并存入dict中</span></span><br><span class="line">        <span class="keyword">while</span> (hashTypeNext(hi) != C_ERR) &#123;</span><br><span class="line">            sds key, value;</span><br><span class="line"></span><br><span class="line">            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);</span><br><span class="line">            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);</span><br><span class="line">            ret = dictAdd(dict, key, value);</span><br><span class="line">            <span class="keyword">if</span> (ret != DICT_OK) &#123;</span><br><span class="line">                serverLogHexDump(LL_WARNING,<span class="string">&quot;ziplist with dup elements dump&quot;</span>,</span><br><span class="line">                    o-&gt;ptr,ziplistBlobLen(o-&gt;ptr));</span><br><span class="line">                serverPanic(<span class="string">&quot;Ziplist corruption detected&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTypeReleaseIterator(hi);</span><br><span class="line">        zfree(o-&gt;ptr);</span><br><span class="line">        o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">        o-&gt;ptr = dict;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeSet</span><span class="params">(robj *o, sds field, sds value, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123; <span class="comment">// ziplist操作</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 查找是否存在field，如果存在，则更新value，不存在则将键值对推入ziplist尾部</span></span><br><span class="line">            fptr = ziplistFind(fptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Grab pointer to the value (fptr points to the field) */</span></span><br><span class="line">                vptr = ziplistNext(zl, fptr);</span><br><span class="line">                serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">                update = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Delete value */</span></span><br><span class="line">                zl = ziplistDelete(zl, &amp;vptr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Insert new value */</span></span><br><span class="line">                zl = ziplistInsert(zl, vptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value,</span><br><span class="line">                        sdslen(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!update) &#123; <span class="comment">// 不存在则将键值对推入ziplist尾部</span></span><br><span class="line">            <span class="comment">/* Push new field/value pair onto the tail of the ziplist */</span></span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value, sdslen(value),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;ptr = zl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the ziplist needs to be converted to a hash table */</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries) <span class="comment">// 插入键值对后，判断是否需要转换为hashtable编码</span></span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// hashtable操作</span></span><br><span class="line">        dictEntry *de = dictFind(o-&gt;ptr,field); <span class="comment">// 查找dict中是否存在field</span></span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            sdsfree(dictGetVal(de));</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                dictGetVal(de) = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 存在则更新value</span></span><br><span class="line">                dictGetVal(de) = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            update = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sds f,v;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD) &#123;</span><br><span class="line">                f = field;</span><br><span class="line">                field = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = sdsdup(field);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                v = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            dictAdd(o-&gt;ptr,f,v); <span class="comment">// 不存在则插入一条键值对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free SDS strings we did not referenced elsewhere if the flags</span></span><br><span class="line"><span class="comment">     * want this function to be responsible. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD &amp;&amp; field) sdsfree(field);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE &amp;&amp; value) sdsfree(value);</span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他与hset相关的命令不做代码解析了，可以自行查看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field value</span><br><span class="line">HMSET key field value [field value ...]</span><br></pre></td></tr></table></figure><hr><p>获取命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很简单，基本上就是调用ziplist或dict的find接口获取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.null[c-&gt;resp])) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_HASH)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    addHashFieldToReply(c, o, c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addHashFieldToReply</span><span class="params">(client *c, robj *o, sds field)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReplyNull(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen = UINT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vll = LLONG_MAX;</span><br><span class="line"></span><br><span class="line">        ret = hashTypeGetFromZiplist(o, field, &amp;vstr, &amp;vlen, &amp;vll);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                addReplyBulkCBuffer(c, vstr, vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkLongLong(c, vll);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        sds value = hashTypeGetFromHashTable(o, field);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyBulkCBuffer(c, value, sdslen(value));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他与hset相关的命令不做代码解析了，可以自行查看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure><hr><p>其他命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br><span class="line">HGETALL key</span><br><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hkeysCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    genericHgetallCommand(c,OBJ_HASH_KEY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hvalsCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    genericHgetallCommand(c,OBJ_HASH_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hgetallCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genericHgetallCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    hashTypeIterator *hi;</span><br><span class="line">    <span class="keyword">int</span> length, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymap[c-&gt;resp]))</span><br><span class="line">        == <span class="literal">NULL</span> || checkType(c,o,OBJ_HASH)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We return a map if the user requested keys and values, like in the</span></span><br><span class="line"><span class="comment">     * HGETALL case. Otherwise to use a flat array makes more sense. */</span></span><br><span class="line">    length = hashTypeLength(o);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; OBJ_HASH_KEY &amp;&amp; flags &amp; OBJ_HASH_VALUE) &#123;</span><br><span class="line">        addReplyMapLen(c, length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyArrayLen(c, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hi = hashTypeInitIterator(o);</span><br><span class="line">    <span class="keyword">while</span> (hashTypeNext(hi) != C_ERR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; OBJ_HASH_KEY) &#123;</span><br><span class="line">            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; OBJ_HASH_VALUE) &#123;</span><br><span class="line">            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashTypeReleaseIterator(hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we returned the right number of elements. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; OBJ_HASH_KEY &amp;&amp; flags &amp; OBJ_HASH_VALUE) count /= <span class="number">2</span>;</span><br><span class="line">    serverAssert(count == length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余的命令不做代码解析了，可自行查看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br><span class="line">HINCRBY key field increment</span><br><span class="line">HINCRBYFLOAT key field increment</span><br><span class="line">HLEN key</span><br><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">HSTRLEN key field</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：t_hash.c/server.h  &lt;/p&gt;
&lt;p&gt;hash对象底层编码方式有两种，&lt;code&gt;ziplist&lt;/code&gt;或&lt;code&gt;hashtable&lt;/code&gt;。&lt;br&gt;使用ziplist编码需要同时满足以下条件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hash对象保存的键值对的键和值的字符串长度小于64字节（可通过redis.conf配置：hash_max_ziplist_value）&lt;/li&gt;
&lt;li&gt;hash对象保存的键值对数小于512个（可通过redis.conf配置：hash_max_ziplist_entries）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="2-object" scheme="http://example.com/categories/Redis/2-object/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-列表对象list</title>
    <link href="http://example.com/Redis/2-object/redis-parse-list/"/>
    <id>http://example.com/Redis/2-object/redis-parse-list/</id>
    <published>2020-09-22T02:52:48.000Z</published>
    <updated>2020-09-22T03:30:30.820Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：t_list.c/server.h</p><p>Redis3.2版本之前，list对象底层是由 <a href="../redis-parse-ziplist">ziplist</a> 和 <a href="../redis-parse-adlist">linkedlist</a> 实现的。3.2版本之后，底层是由 <a href="../redis-parse-quicklist">quicklist</a> 来实现。<br><a id="more"></a></p><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th><th>时间复杂度</th></tr></thead><tbody><tr><td>LPUSH</td><td>从列表的最左边插入一个或多个元素（列表为空则创建）</td><td>O(1)</td></tr><tr><td>LRUSHX</td><td>从列表的最左边插入一个或多个元素（列表为空时不做操作）</td><td>O(1)</td></tr><tr><td>RPUSH</td><td>从列表的最右边插入一个或多个元素（列表为空则创建）</td><td>O(1)</td></tr><tr><td>RPUSHX</td><td>从列表的最右边插入一个或多个元素（列表为空时不做操作）</td><td>O(1)</td></tr><tr><td>LPOP</td><td>从列表的最左边弹出一个元素</td><td>O(1)</td></tr><tr><td>RPOP</td><td>从列表的最右边弹出一个元素</td><td>O(1)</td></tr><tr><td>BLPOP</td><td>弹出指定的多个列表中第一个元素（lpop阻塞版本）</td><td>O(1)</td></tr><tr><td>BRPOP</td><td>弹出指定的多个列表中最后一个元素（rpop阻塞版本）</td><td>O(1)</td></tr><tr><td>RPOPLPUSH</td><td>弹出列表A的最后一个元素，并将该元素插入到列表B的首位</td><td>O(1)</td></tr><tr><td>BRPOPLPUSH</td><td>弹出列表A的最后一个元素，并将该元素插入到列表B的首位（rpoplpush阻塞版本）</td><td>O(1)</td></tr><tr><td>LINDEX</td><td>获取索引位置的元素</td><td>平均O(N)，头尾O(1)</td></tr><tr><td>LRANGE</td><td>从列表中获取指定位置的元素</td><td>O(S+N)，S是距离列表头部的偏移位置，N为指定范围元素数</td></tr><tr><td>LINSERT</td><td>在列表中的另一个元素前或后插入一个元素</td><td>平均O(N)，头部O(1)</td></tr><tr><td>LSET</td><td>设置index位置元素的值为value</td><td>平均O(N)，头尾O(1)</td></tr><tr><td>LTRIM</td><td>修剪一个已存在的列表的大小</td><td>平均O(N)</td></tr><tr><td>LREM</td><td>从列表中移除count个值为value的元素</td><td>O(N)</td></tr><tr><td>LLEN</td><td>获得列表的长度</td><td>O(1)</td></tr></tbody></table></div><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blpopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// blpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// brpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpoplpushCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// brpoplpush命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lpush命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// rpush命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lpushx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// rpushx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linsertCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// linsert命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// rpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpoplpushCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// rpoplpush命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// llen命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lindexCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lindex命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrangeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lrange命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltrimCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// ltrim命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lremCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lrem命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// lset命令</span></span><br></pre></td></tr></table></figure><h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr><p>插入命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key value [value ...]</span><br><span class="line">RPUSH key value [value ...]</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    pushGenericCommand(c,LIST_HEAD); <span class="comment">// 列表头部插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    pushGenericCommand(c,LIST_TAIL); <span class="comment">// 列表尾部插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, pushed = <span class="number">0</span>;</span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]); <span class="comment">// db中查找key</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lobj &amp;&amp; lobj-&gt;type != OBJ_LIST) &#123; <span class="comment">// 判断对象类型</span></span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令解析</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">            lobj = createQuicklistObject(); <span class="comment">// 列表不存在，则创建新的列表对象</span></span><br><span class="line">            quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size,</span><br><span class="line">                                server.list_compress_depth); <span class="comment">// 设置列表压缩节点的大小和压缩深度</span></span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj); <span class="comment">// 加入到db中</span></span><br><span class="line">        &#125;</span><br><span class="line">        listTypePush(lobj,c-&gt;argv[j],where); <span class="comment">// 调用quicklistPush函数插入元素</span></span><br><span class="line">        pushed++;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : <span class="number">0</span>)); <span class="comment">// 返回列表长度</span></span><br><span class="line">    <span class="keyword">if</span> (pushed) &#123;</span><br><span class="line">        <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">&quot;lpush&quot;</span> : <span class="string">&quot;rpush&quot;</span>;</span><br><span class="line"></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]); <span class="comment">// 修改信号</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id); <span class="comment">// 事件通知</span></span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += pushed; <span class="comment">// 存储上次保存前所有数据变动的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他与插入相关的命令不做代码解析了，可自行查看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX key value <span class="comment">// 如果db中有该列表，则调用quicklistPush插入元素到列表头部，无列表则不做操作返回</span></span><br><span class="line">RPUSHX key value <span class="comment">// 如果db中有该列表，则调用quicklistPush插入元素到列表尾部，无列表则不做操作返回</span></span><br><span class="line">LINSERT key BEFORE|AFTER pivot value <span class="comment">// 使用quicklist迭代器查找到列表中对应的位置，然后在指定位置前或后插入元素</span></span><br><span class="line">RPOPLPUSH source destination <span class="comment">// 调用quicklistPopCustom从列表source中弹出最后一个元素，并调用quicklistPush插入到destination列表中</span></span><br><span class="line">BRPOPLPUSH source destination timeout <span class="comment">// timeout时间内，如果有source列表，则调用rpoplpushCommand函数，否则返回不做操作返回</span></span><br><span class="line">LSET key index value <span class="comment">// 调用quicklistReplaceAtIndex修改指定位置的值</span></span><br></pre></td></tr></table></figure><hr><p>弹出命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br><span class="line">RPOP key</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,LIST_HEAD); <span class="comment">// 列表头部弹出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,LIST_TAIL); <span class="comment">// 列表尾部弹出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.null[c-&gt;resp]); <span class="comment">// db中查找key</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    robj *value = listTypePop(o,where); <span class="comment">// 调用quicklistPopCustom弹出指定位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReplyNull(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">&quot;lpop&quot;</span> : <span class="string">&quot;rpop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        addReplyBulk(c,value);</span><br><span class="line">        decrRefCount(value); <span class="comment">// 元素value引用计数自减</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id); <span class="comment">// 事件通知</span></span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                                c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">            dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]); <span class="comment">// 如果列表长度为0，则删除改列表对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他与插入相关的命令不做代码解析了，可自行查看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure><hr><p>获取元素命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LINDEX</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lindexCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.null[c-&gt;resp]);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;index, <span class="literal">NULL</span>) != C_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        quicklistEntry entry;</span><br><span class="line">        <span class="keyword">if</span> (quicklistIndex(o-&gt;ptr, index, &amp;entry)) &#123; <span class="comment">// 获取列表中的指定index位置的元素</span></span><br><span class="line">            <span class="keyword">if</span> (entry.value) &#123;</span><br><span class="line">                value = createStringObject((<span class="keyword">char</span>*)entry.value,entry.sz); <span class="comment">// 创建字符串对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = createStringObjectFromLongLong(entry.longval); <span class="comment">// 创建longlong对象</span></span><br><span class="line">            &#125;</span><br><span class="line">            addReplyBulk(c,value);</span><br><span class="line">            decrRefCount(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRANGE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrangeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> start, end, llen, rangelen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptyarray)) == <span class="literal">NULL</span></span><br><span class="line">         || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    llen = listTypeLength(o); <span class="comment">// 获取列表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将start和end转为正数的索引 */</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        addReply(c,shared.emptyarray);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">    rangelen = (end-start)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the result in form of a multi-bulk reply */</span></span><br><span class="line">    addReplyArrayLen(c,rangelen);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="comment">// 获取列表的迭代器（从start位置开始）</span></span><br><span class="line">        listTypeIterator *iter = listTypeInitIterator(o, start, LIST_TAIL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123; <span class="comment">// 循环遍历获取数据</span></span><br><span class="line">            listTypeEntry entry;</span><br><span class="line">            listTypeNext(iter, &amp;entry);</span><br><span class="line">            quicklistEntry *qe = &amp;entry.entry;</span><br><span class="line">            <span class="keyword">if</span> (qe-&gt;value) &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,qe-&gt;value,qe-&gt;sz);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkLongLong(c,qe-&gt;longval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listTypeReleaseIterator(iter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;List encoding is not QUICKLIST!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>其他命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key start stop</span><br><span class="line">LREM key count value</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* LREM count参数：  </span></span><br><span class="line"><span class="comment">* count &gt; 0: 从头往尾移除值为 value 的元素。</span></span><br><span class="line"><span class="comment">* count &lt; 0: 从尾往头移除值为 value 的元素。</span></span><br><span class="line"><span class="comment">* count = 0: 移除所有值为 value 的元素。 */</span></span><br><span class="line"></span><br><span class="line">LLEN key</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltrimCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> start, end, llen, ltrim, rtrim;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.ok)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将start和end转为正数的索引</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要修剪的位置</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        <span class="comment">/* Out of range start or start &gt; end result in empty list */</span></span><br><span class="line">        ltrim = llen;</span><br><span class="line">        rtrim = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">        ltrim = start;</span><br><span class="line">        rtrim = llen-end<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉列表中需要修剪的范围</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        quicklistDelRange(o-&gt;ptr,<span class="number">0</span>,ltrim);</span><br><span class="line">        quicklistDelRange(o-&gt;ptr,-rtrim,rtrim);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_LIST,<span class="string">&quot;ltrim&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lremCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *subject, *obj;</span><br><span class="line">    obj = c-&gt;argv[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">long</span> toremove;</span><br><span class="line">    <span class="keyword">long</span> removed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;toremove, <span class="literal">NULL</span>) != C_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    subject = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (subject == <span class="literal">NULL</span> || checkType(c,subject,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    <span class="keyword">if</span> (toremove &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        toremove = -toremove;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">-1</span>,LIST_HEAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,LIST_TAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listTypeEqual(&amp;entry,obj)) &#123;</span><br><span class="line">            listTypeDelete(li, &amp;entry);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            removed++;</span><br><span class="line">            <span class="keyword">if</span> (toremove &amp;&amp; removed == toremove) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listTypeReleaseIterator(li);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,<span class="string">&quot;lrem&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(subject) == <span class="number">0</span>) &#123;</span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addReplyLongLong(c,removed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    addReplyLongLong(c,listTypeLength(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：t_list.c/server.h&lt;/p&gt;
&lt;p&gt;Redis3.2版本之前，list对象底层是由 &lt;a href=&quot;../redis-parse-ziplist&quot;&gt;ziplist&lt;/a&gt; 和 &lt;a href=&quot;../redis-parse-adlist&quot;&gt;linkedlist&lt;/a&gt; 实现的。3.2版本之后，底层是由 &lt;a href=&quot;../redis-parse-quicklist&quot;&gt;quicklist&lt;/a&gt; 来实现。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="2-object" scheme="http://example.com/categories/Redis/2-object/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-字符串对象string</title>
    <link href="http://example.com/Redis/2-object/redis-parse-string/"/>
    <id>http://example.com/Redis/2-object/redis-parse-string/</id>
    <published>2020-09-22T02:31:50.000Z</published>
    <updated>2020-09-22T03:31:36.995Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：t_string.c/server.h</p><p>字符串是redis中最常用的数据结构，在对象系统object一文中我们提到，字符串数据结构根据场景会有三种编码类型：<code>OBJ_ENCODING_RAW</code>、<code>OBJ_ENCODING_INT</code>、<code>OBJ_ENCODING_EMBSTR</code>，分别对应底层数据结构：sds、int、sds。下面说说这三种编码类型的使用场景。<br><a id="more"></a><br>根据redisObject数据结构可以得知，一般创建object对象时，object和数据本身在内存中是分开的，要进行两次内存分配。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS;</span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>而OBJ_ENCODING_EMBSTR的做法是，创建object之前，先计算object和数据的大小总和，然后一次性申请足够的内存空间，数据直接跟在object对象后面。这种编码是有大小限制的，因为redis采用jemalloc内存分配器，可以分配8，16，32，64字节大小的内存空间，所以申请内存时，redisObject占用16字节，sdshdr8占用3字节，数据结尾’\0’占用1字节，那么实际数据的长度限制为：64-16-8-1=44字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br></pre></td></tr></table></figure><p>所以当数据长度小于44时，用EMBSTR编码，否则使用OBJ_ENCODING_RAW编码。如果一个字符串对象保存的是整数值，并且可以用long类型来表示，则将字符串对象转为long，设置编码类型为OBJ_ENCODING_INT。  </p><p>下面让我们看看实例：<br><img src="/Redis/2-object/redis-parse-string/t_string.png" alt="t_string">  </p><p>INT和EMBSTR编码的字符串对象在条件满足的情况下，会转换为RAW编码。<br>比如INT编码对象在执行APPEND命令追加一段字符串时，将会转换为RAW编码，因为追加操作只支持字符串值，所以会把之前保存的整数值转为字符串后，再执行追加操作，这时就会转为RAW编码。<br><img src="/Redis/2-object/redis-parse-string/t_string_int_to_raw.png" alt="int_to_raw">  </p><p>而redis没有提供对EMBSTR编码的字符串对象的修改操作，所以当进行追加操作时，也会先转为RAW编码，然后再进行追加。<br><img src="/Redis/2-object/redis-parse-string/t_string_embstr_to_raw.png" alt="embstr_to_raw">  </p><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th><th>时间复杂度</th></tr></thead><tbody><tr><td>GET</td><td>获取key对应的value</td><td>O(1)</td></tr><tr><td>MGET</td><td>获取多个keys对应的values</td><td>O(N)，N为key的数量</td></tr><tr><td>GETRANGE</td><td>返回key对应的字符串value的子串，由start和end位移决定</td><td>O(N)，N为字符串长度</td></tr><tr><td>SET</td><td>设置一个key的value值</td><td>O(1)</td></tr><tr><td>MSET</td><td>设置多个keys的values值</td><td>O(1)</td></tr><tr><td>SETNX</td><td>key不存在时才设置value值（可通过set命令+NX参数实现）</td><td>O(1)</td></tr><tr><td>MSETNX</td><td>keys不存在时才设置values值</td><td>O(1)</td></tr><tr><td>SETEX</td><td>key存在时才设置值，到期时间以秒为单位（可通过set命令+XX参数实现）</td><td>O(1)</td></tr><tr><td>PSETEX</td><td>和setex唯一的区别是到期时间以毫秒为单位（可通过set命令+XX+PX参数实现）</td><td>O(1)</td></tr><tr><td>SETRANGE</td><td>覆盖key对应的string的一部分，从指定长度offset处开始，覆盖value的长度</td><td>O(1)</td></tr><tr><td>APPEND</td><td>指定key的值结尾追加字符串</td><td>O(1)</td></tr><tr><td>GETSET</td><td>自动将key对应到value并且返回原来key对应的value</td><td>O(1)</td></tr><tr><td>INCR</td><td>对存储在指定key的数值执行原子的加1操作</td><td>O(1)</td></tr><tr><td>INCRBY</td><td>将key对应的数字加上指定的整数值</td><td>O(1)</td></tr><tr><td>INCRBYFLOAT</td><td>将key对应的数字加上指定的浮点数值</td><td>O(1)</td></tr><tr><td>DECR</td><td>对key对应的数字做减1操作</td><td>O(1)</td></tr><tr><td>DECRBY</td><td>将key对应的数字减去指定的整数值</td><td>O(1)</td></tr><tr><td>STRLEN</td><td>获取指定key对应value的长度</td><td>O(1)</td></tr></tbody></table></div><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// set命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// setnx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setexCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// setex命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psetexCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// psetex命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// mset命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetnxCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// msetnx命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setrangeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// setrange命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrangeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// getrange命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// get命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mgetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// mget命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsetCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// getset命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// incr命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// decr命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// incrby命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrbyCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// decrby命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyfloatCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// incrbyfloat命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// append命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strlenCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// strlen命令</span></span><br></pre></td></tr></table></figure><h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr><p>插入命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [NX] [XX] [KEEPTTL] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;]</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>EX seconds – 设置键key的过期时间，单位时秒  </li><li>PX milliseconds – 设置键key的过期时间，单位时毫秒  </li><li>NX – 只有键key不存在的时候才会设置key的值  </li><li>XX – 只有键key存在的时候才会设置key的值  </li></ul><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj *expire = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</span><br><span class="line">    <span class="keyword">int</span> flags = OBJ_SET_NO_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析命令中的参数</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> *a = c-&gt;argv[j]-&gt;ptr;</span><br><span class="line">        robj *next = (j == c-&gt;argc<span class="number">-1</span>) ? <span class="literal">NULL</span> : c-&gt;argv[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>) &amp;&amp;</span><br><span class="line">            (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">            !(flags &amp; OBJ_SET_XX))</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_NX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_NX))</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_XX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">&quot;KEEPTTL&quot;</span>) &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_EX) &amp;&amp; !(flags &amp; OBJ_SET_PX))</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_KEEPTTL;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_KEEPTTL) &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_PX) &amp;&amp; next)</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_EX;</span><br><span class="line">            unit = UNIT_SECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_KEEPTTL) &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_EX) &amp;&amp; next)</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_PX;</span><br><span class="line">            unit = UNIT_MILLISECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断value是否可以进行整数编码，如果可以则使用INT编码</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 开始执行插入操作</span></span><br><span class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags, robj *key, robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply, robj *abort_reply)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> milliseconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123; <span class="comment">// 如果设定了过期时间，则将时间格式化为毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyErrorFormat(c,<span class="string">&quot;invalid expire time in %s&quot;</span>,c-&gt;cmd-&gt;name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断key是否存在，并根据NX/XX参数来决定是否插入value</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>) ||</span><br><span class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        addReply(c, abort_reply ? abort_reply : shared.null[c-&gt;resp]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将键值对插入到db中</span></span><br><span class="line">    genericSetKey(c-&gt;db,key,val,flags &amp; OBJ_SET_KEEPTTL);</span><br><span class="line">    server.dirty++; <span class="comment">// 存储上次保存前所有数据变动的长度+1</span></span><br><span class="line">    <span class="keyword">if</span> (expire) setExpire(c,c-&gt;db,key,mstime()+milliseconds); <span class="comment">// 设定过期时间</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">&quot;set&quot;</span>,key,c-&gt;db-&gt;id); <span class="comment">// 发送set事件通知</span></span><br><span class="line">    <span class="keyword">if</span> (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">        <span class="string">&quot;expire&quot;</span>,key,c-&gt;db-&gt;id); <span class="comment">// 发送定期事件通知</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok); <span class="comment">// 向客户端返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他与set相关的命令不做代码解析了，可以自行查看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br><span class="line">SETEX key value</span><br><span class="line">PSETEX key milliseconds value</span><br><span class="line">MSET key value [key value ...]</span><br><span class="line">MSETNX key value [key value ...]</span><br><span class="line">APPEND key value</span><br></pre></td></tr></table></figure><hr><p>获取命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    getGenericCommand(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGenericCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断key是否存在，存在则返回value，不存在则返回对应错误</span></span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.null[c-&gt;resp])) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != OBJ_STRING) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,o);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他与set相关的命令不做代码解析了，可以自行查看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MGET key [key ...]</span><br><span class="line">GETRANGE key start end</span><br><span class="line">GETSET key value</span><br></pre></td></tr></table></figure><hr><p>自增自减命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br><span class="line">DECR key</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// INCR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DECR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrDecrCommand</span><span class="params">(client *c, <span class="keyword">long</span> <span class="keyword">long</span> incr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value, oldvalue;</span><br><span class="line">    robj *o, *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取db中的键值对</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>; <span class="comment">// 类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;value,<span class="literal">NULL</span>) != C_OK) <span class="keyword">return</span>; <span class="comment">// 是否能转为整数型，不能则返回</span></span><br><span class="line"></span><br><span class="line">    oldvalue = value;</span><br><span class="line">    <span class="comment">// 值范围检查</span></span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span> &amp;&amp; oldvalue &lt; <span class="number">0</span> &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</span><br><span class="line">        (incr &gt; <span class="number">0</span> &amp;&amp; oldvalue &gt; <span class="number">0</span> &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;increment or decrement would overflow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value += incr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp; o-&gt;refcount == <span class="number">1</span> &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</span><br><span class="line">        (value &lt; <span class="number">0</span> || value &gt;= OBJ_SHARED_INTEGERS) &amp;&amp;</span><br><span class="line">        value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> = o;</span><br><span class="line">        o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> = createStringObjectFromLongLongForValue(value); <span class="comment">// 通过value的类型创建新的字符串对象</span></span><br><span class="line">        <span class="keyword">if</span> (o) &#123;</span><br><span class="line">            dbOverwrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="keyword">new</span>); <span class="comment">// db中已存在，则覆盖</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="keyword">new</span>); <span class="comment">// 不存在则插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]); <span class="comment">// 发送修改key的信号</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">&quot;incrby&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id); <span class="comment">// 事件通知</span></span><br><span class="line">    server.dirty++; <span class="comment">// 存储上次保存前所有数据变动的长度+1</span></span><br><span class="line">    <span class="comment">// 客户端回复</span></span><br><span class="line">    addReply(c,shared.colon);</span><br><span class="line">    addReply(c,<span class="keyword">new</span>);</span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他与INCR和DECR相关的命令不做代码解析了，可以自行查看源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key increment</span><br><span class="line">DECRBY key increment</span><br><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure><p>&lt;/br&gt;</p><hr><p>获取字符串长度命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strlenCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 从DB中获取键值对</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 返回给客户端字符串长度</span></span><br><span class="line">    addReplyLongLong(c,stringObjectLen(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：t_string.c/server.h&lt;/p&gt;
&lt;p&gt;字符串是redis中最常用的数据结构，在对象系统object一文中我们提到，字符串数据结构根据场景会有三种编码类型：&lt;code&gt;OBJ_ENCODING_RAW&lt;/code&gt;、&lt;code&gt;OBJ_ENCODING_INT&lt;/code&gt;、&lt;code&gt;OBJ_ENCODING_EMBSTR&lt;/code&gt;，分别对应底层数据结构：sds、int、sds。下面说说这三种编码类型的使用场景。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="2-object" scheme="http://example.com/categories/Redis/2-object/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
</feed>
