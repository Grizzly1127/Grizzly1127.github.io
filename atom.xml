<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grizzly</title>
  
  <subtitle>记录点点滴滴</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-21T08:23:48.718Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>李辉雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis源码-内存分配zmalloc</title>
    <link href="http://example.com/2020/09/21/Redis%E6%BA%90%E7%A0%81-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dzmalloc/"/>
    <id>http://example.com/2020/09/21/Redis%E6%BA%90%E7%A0%81-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dzmalloc/</id>
    <published>2020-09-21T08:09:22.000Z</published>
    <updated>2020-09-21T08:23:48.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：zmalloc.c/zmalloc.h  </p><p>因为Redis没有自己实现内存池，所以系统内存分配器的性能及碎片率会对redis造成一些性能上的影响。<br>Redis采用了3种内存分配器：tcmalloc、jemalloc、malloc。<br>Redis在编译时，首先会判断是否使用tcmalloc，其次是jemalloc，如果都没有使用，则使用libc中的内存管理函数malloc。<br><a id="more"></a></p><h2 id="功能函数总览"><a href="#功能函数总览" class="headerlink" title="功能函数总览"></a>功能函数总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用malloc函数申请size大小的内存空间（malloc不初始化，里边的数据是随机的）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用calloc函数申请size大小的内存空间（calloc系统会自动初始化内存为零）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用realloc函数重新分配size大小的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 调用free释放ptr的内存</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>; <span class="comment">// 深拷贝字符串s</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_used_memory</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取以分配的内存空间大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_set_oom_handler</span><span class="params">(<span class="keyword">void</span> (*oom_handler)(<span class="keyword">size_t</span>))</span></span>; <span class="comment">// 可自定义内存溢出的处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取rss信息（Resident Set Size 常驻内存集）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zmalloc_get_allocator_info</span><span class="params">(<span class="keyword">size_t</span> *allocated, <span class="keyword">size_t</span> *active, <span class="keyword">size_t</span> *resident)</span></span>; <span class="comment">// 获取jemalloc分配的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_jemalloc_bg_thread</span><span class="params">(<span class="keyword">int</span> enable)</span></span>; <span class="comment">// flushdb没有通信后，让jemalloc异步清除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jemalloc_purge</span><span class="params">()</span></span>; <span class="comment">// 手动清理内存碎片</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_private_dirty</span><span class="params">(<span class="keyword">long</span> pid)</span></span>; <span class="comment">// 获取smap中的Private_Dirty大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid)</span></span>; <span class="comment">// 获取smap中的某字段大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_memory_size</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取物理内存的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlibc_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 释放内存，不更新used_memory（不知道为啥，等以后看懂了再注释）</span></span><br></pre></td></tr></table></figure><h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录以使用的内存总大小，对该变量的操作都是原子操作</span></span><br><span class="line"><span class="comment">// 在redis-cli使用info命令可以查看</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用系统函数malloc申请size大小的内存空间，PREFIX_SIZE根据不同平台和HAVE_MALLOC_SIZE控制的。</span></span><br><span class="line"><span class="comment">// 如果分配失败，则调用zmalloc_oom_handler()函数来打印异常，并返回空值。</span></span><br><span class="line"><span class="comment">// 若分配成功，会在update_zmalloc_stat_alloc()宏定义函数中更新used_memory这个静态变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用系统函数calloc申请size大小的内存空间，功能函数与zmalloc()相同</span></span><br><span class="line"><span class="comment">// malloc与calloc的区别在于，malloc申请的内存不进行初始化，内存里的值是随机的，calloc申请的内存系统会讲其初始化为零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据新的size进行内存分配，并且更新used_memory变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        zfree(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = zmalloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放ptr的内存空间，并更新used_memory变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝字符串s，创建字符串副本</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取used_memory的值</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_used_memory</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line">    atomicGet(used_memory,um);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可自定义分配失败时的处理方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_set_oom_handler</span><span class="params">(<span class="keyword">void</span> (*oom_handler)(<span class="keyword">size_t</span>))</span> </span>&#123;</span><br><span class="line">    zmalloc_oom_handler = oom_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取rss信息（Resident Set Size 常驻内存集）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">size_t</span> rss;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">&quot;/proc/%d/stat&quot;</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    rss *= page;</span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取jemalloc分配的信息，在jemalloc前提下使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zmalloc_get_allocator_info</span><span class="params">(<span class="keyword">size_t</span> *allocated,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *active,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *resident)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> epoch = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> sz;</span><br><span class="line">    *allocated = *resident = *active = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Update the statistics cached by mallctl. */</span></span><br><span class="line">    sz = <span class="keyword">sizeof</span>(epoch);</span><br><span class="line">    je_mallctl(<span class="string">&quot;epoch&quot;</span>, &amp;epoch, &amp;sz, &amp;epoch, sz);</span><br><span class="line">    sz = <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="comment">/* Unlike RSS, this does not include RSS from shared libraries and other non</span></span><br><span class="line"><span class="comment">     * heap mappings. */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.resident&quot;</span>, resident, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Unlike resident, this doesn&#x27;t not include the pages jemalloc reserves</span></span><br><span class="line"><span class="comment">     * for re-use (purge will clean that). */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.active&quot;</span>, active, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Unlike zmalloc_used_memory, this matches the stats.resident by taking</span></span><br><span class="line"><span class="comment">     * into account all allocations done by this process (not only zmalloc). */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.allocated&quot;</span>, allocated, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flushdb没有通信后，让jemalloc异步清除，在jemalloc前提下使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_jemalloc_bg_thread</span><span class="params">(<span class="keyword">int</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* let jemalloc do purging asynchronously, required when there&#x27;s no traffic </span></span><br><span class="line"><span class="comment">     * after flushdb */</span></span><br><span class="line">    <span class="keyword">char</span> val = !!enable;</span><br><span class="line">    je_mallctl(<span class="string">&quot;background_thread&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;val, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整理内存碎片，在jemalloc前提下使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jemalloc_purge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* return all unused (reserved) pages to the OS */</span></span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> narenas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>);</span><br><span class="line">    <span class="keyword">if</span> (!je_mallctl(<span class="string">&quot;arenas.narenas&quot;</span>, &amp;narenas, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;arena.%d.purge&quot;</span>, narenas);</span><br><span class="line">        <span class="keyword">if</span> (!je_mallctl(tmp, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取smap中的Private_Dirty（映射中已由此进程写入但未被任何其他进程引用的页面）大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_private_dirty</span><span class="params">(<span class="keyword">long</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zmalloc_get_smap_bytes_by_field(<span class="string">&quot;Private_Dirty:&quot;</span>,pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取进程的smap文件中，某字段字节的大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">size_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flen = <span class="built_in">strlen</span>(field);</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        fp = fopen(<span class="string">&quot;/proc/self/smaps&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> filename[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(filename,<span class="keyword">sizeof</span>(filename),<span class="string">&quot;/proc/%ld/smaps&quot;</span>,pid);</span><br><span class="line">        fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fgets(line,<span class="keyword">sizeof</span>(line),fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line,field,flen) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> *p = <span class="built_in">strchr</span>(line,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                bytes += strtol(line+flen,<span class="literal">NULL</span>,<span class="number">10</span>) * <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取物理内存的大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_memory_size</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__unix) || defined(unix) || \</span></span><br><span class="line">    (defined(__APPLE__) &amp;&amp; defined(__MACH__))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CTL_HW) &amp;&amp; (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_MEMSIZE)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_MEMSIZE;            <span class="comment">/* OSX. --------------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PHYSMEM64)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM64;          <span class="comment">/* NetBSD, OpenBSD. --------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int64_t</span> size = <span class="number">0</span>;               <span class="comment">/* 64-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl( mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_SC_PHYS_PAGES) &amp;&amp; defined(_SC_PAGESIZE)</span></span><br><span class="line">    <span class="comment">/* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>)sysconf(_SC_PHYS_PAGES) * (<span class="keyword">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CTL_HW) &amp;&amp; (defined(HW_PHYSMEM) || defined(HW_REALMEM))</span></span><br><span class="line">    <span class="comment">/* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_REALMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_REALMEM;        <span class="comment">/* FreeBSD. ----------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PHYSMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM;        <span class="comment">/* Others. ------------------ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="number">0</span>;      <span class="comment">/* 32-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown method to get the data. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown OS. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用对应的内存分配器的free函数进行内存释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlibc_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：zmalloc.c/zmalloc.h  &lt;/p&gt;
&lt;p&gt;因为Redis没有自己实现内存池，所以系统内存分配器的性能及碎片率会对redis造成一些性能上的影响。&lt;br&gt;Redis采用了3种内存分配器：tcmalloc、jemalloc、malloc。&lt;br&gt;Redis在编译时，首先会判断是否使用tcmalloc，其次是jemalloc，如果都没有使用，则使用libc中的内存管理函数malloc。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-动态字符串sds</title>
    <link href="http://example.com/2020/09/21/Redis%E6%BA%90%E7%A0%81-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"/>
    <id>http://example.com/2020/09/21/Redis%E6%BA%90%E7%A0%81-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/</id>
    <published>2020-09-21T08:09:19.000Z</published>
    <updated>2020-09-21T08:19:36.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：sds.c/sds.h  </p><p>因为C语言没有实现动态字符串，所以redis实现了sds（simple dynamic string）简单动态字符串。既然是动态的，意味着它是能够支持修改的。​虽然是简单的动态字符串，但是redis为了省内存，快速获得字符串长度等需求，redis作者在结构上可是煞费苦心了。​<br><a id="more"></a><br>sds为了省内存，对不同长度的字符串，采用了不同的内存大小的结构体达到省内存的目的。为了减少内存的频繁分配，sds采用预分配冗余空间的方式来达到目的。<br>SDS结构一共有5种header定义，结构体主要包含以下几个部分：<br>len：字符串的实际长度<br>alloc：字符串的最大容量<br>flags：表示结构体的类型<br>buf：字符串<br><img src="/2020/09/21/Redis%E6%BA%90%E7%A0%81-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/sds.png" alt="sds结构"></p><h2 id="SDS结构体"><a href="#SDS结构体" class="headerlink" title="SDS结构体"></a>SDS结构体</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7 <span class="comment">// 类型掩码(通过(flags &amp; SDS_TYPE_MASK)可判断sdshdrXX)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); <span class="comment">// 获取header头指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) <span class="comment">// 获取header头指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS) <span class="comment">// 获取sdshdr5的长度</span></span></span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>; <span class="comment">// 生成新的sds字符串（返回sdshdrXX中的buf头指针）</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>; <span class="comment">// 生成新的sds字符串（调用sdsnewlen()）</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个空的sds字符串（调用sdsnewlen(&quot;&quot;, 0)）</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>; <span class="comment">// 复制（深拷贝）s（调用sdsnewlen(&quot;&quot;, 0)）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>; <span class="comment">// 释放sds字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 将字符串s增加到指定长度len（s的实际长度为len）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 字符串s增加len的长度（s的实际长度为len（s） + len）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>; <span class="comment">// 字符串拼接（调用sdscatlen()）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span>; <span class="comment">// 同上（调用sdscatlen()）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 字符串拷贝</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>; <span class="comment">// 字符串拷贝（调用sdscpylen()）</span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>; <span class="comment">// 字符串格式化，类似于sprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="comment">// 字符串格式化（调用sdscatvprintf()）</span></span></span><br><span class="line"><span class="function">    __<span class="title">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>; <span class="comment">// 字符串格式化（调用sdscatvprintf()）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>; <span class="comment">// 字符串格式化拼接</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>; <span class="comment">// 字符串s剔除指定的cset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">ssize_t</span> start, <span class="keyword">ssize_t</span> end)</span></span>; <span class="comment">// 选取指定长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>; <span class="comment">// 更新s的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>; <span class="comment">// 清空s的内容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span></span>; <span class="comment">// 字符串拷贝</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">ssize_t</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span>; <span class="comment">// 字符串分割，将字符串s根据sep分割符来进行分割，返回字符串数组，count为数组个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>; <span class="comment">// 释放字符串数组tokens</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>; <span class="comment">// 字符串转小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>; <span class="comment">// 字符串转大写</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>; <span class="comment">// long long 转为sds格式</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 将s里不可打印的字符(&#x27;\n&#x27;、&#x27;\t&#x27;等)转义为可用来打印的字符(&#x27;\\n&#x27;、&#x27;\\t&#x27;等)</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span></span>; <span class="comment">// 替换字符串，将s中为from的字符串替换为to</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span></span>; <span class="comment">// 字符串数组连接</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">size_t</span> seplen)</span></span>; <span class="comment">// sds格式的字符串连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level functions exposed to the user API */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span></span>; <span class="comment">// 字符串s增加扩大addlen个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">ssize_t</span> incr)</span></span>; <span class="comment">// 调整sds中len的大小</span></span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span></span>; <span class="comment">// 删除掉sds中的末端空间(local-len)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdsAllocSize</span><span class="params">(sds s)</span></span>; <span class="comment">// 返回整个结构的内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sdsAllocPtr</span><span class="params">(sds s)</span></span>; <span class="comment">// 返回结构体的头指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Export the allocator used by SDS to the program using SDS.</span></span><br><span class="line"><span class="comment"> * Sometimes the program SDS is linked to, may use a different set of</span></span><br><span class="line"><span class="comment"> * allocators, but may want to allocate or free things that SDS will</span></span><br><span class="line"><span class="comment"> * respectively free or allocate. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 分配内存size大小的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 重新分配内存大小为size的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sds_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：sds.c/sds.h  &lt;/p&gt;
&lt;p&gt;因为C语言没有实现动态字符串，所以redis实现了sds（simple dynamic string）简单动态字符串。既然是动态的，意味着它是能够支持修改的。​虽然是简单的动态字符串，但是redis为了省内存，快速获得字符串长度等需求，redis作者在结构上可是煞费苦心了。​&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
</feed>
