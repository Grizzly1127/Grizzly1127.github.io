<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grizzly</title>
  
  <subtitle>博观而约取，厚积而薄发</subtitle>
  <link href="https://blog.grizzlys.top/atom.xml" rel="self"/>
  
  <link href="https://blog.grizzlys.top/"/>
  <updated>2021-07-08T08:04:23.562Z</updated>
  <id>https://blog.grizzlys.top/</id>
  
  <author>
    <name>李辉雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>挖矿与矿池</title>
    <link href="https://blog.grizzlys.top/blockchain/minging-miningpool/"/>
    <id>https://blog.grizzlys.top/blockchain/minging-miningpool/</id>
    <published>2021-07-08T04:47:30.000Z</published>
    <updated>2021-07-08T08:04:23.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-挖矿"><a href="#1-挖矿" class="headerlink" title="1. 挖矿"></a>1. 挖矿</h2><h3 id="1-1-什么是挖矿"><a href="#1-1-什么是挖矿" class="headerlink" title="1.1 什么是挖矿"></a>1.1 什么是挖矿</h3><p>挖矿的本质就是构造符合规则（PoW共识机制）的区块并进行全网验证的过程。作为激励，矿工成功挖掘到区块后，可以从中获取区块奖励和交易费奖励。</p><p>下面以BTC为例，阐述挖矿的运作流程。</p><a id="more"></a><h3 id="1-2-BTC如何挖矿？"><a href="#1-2-BTC如何挖矿？" class="headerlink" title="1.2 BTC如何挖矿？"></a>1.2 BTC如何挖矿？</h3><p><img src="https://i.loli.net/2021/07/08/lgS1IYWGuPKbrTN.png" alt="block_package.png"></p><p>上面这张图描述了如何构造一个比特币区块。区块构造流程：</p><ol><li>从未确定交易池中选取交易，通常尽可能多的优先选择手续费高的交易。</li><li>构造coinbase交易，计算打包交易中的挖矿手续费和coinbase奖励。</li><li>矿工将所有交易（包含coinbase交易）添加到区块体中。</li><li>对所有交易（包含coinbase交易）进行hash计算，并构造出merkle树，得到merkle树根哈希值。</li><li>根据当前环境填充区块头中的当前版本、父区块哈希、时间戳和难度，自行填写nNonce，与得到的merkle树根哈希值一同构成区块头。</li></ol><p>完成以上步骤，一个比特币区块就构建好了。</p><h3 id="1-3-BTC挖矿过程"><a href="#1-3-BTC挖矿过程" class="headerlink" title="1.3 BTC挖矿过程"></a>1.3 BTC挖矿过程</h3><p><img src="https://i.loli.net/2021/07/08/Silnx2oewNPvURD.png" alt="block_verify.png"></p><p>下面我们来看一下比特币的挖矿验证过程：</p><ol><li>区块打包成功后，对区块中的区块头进行hash256运算并得到结果。</li><li><p>将区块头哈希值与当前target（由nBits解压得来的）比对，这时比对结果会有两种情况：</p><ul><li>若区块头哈希值大于target，则表明不符合规则，需要重新构造区块头继续循环验证。</li><li>若区块头哈希值小于等于target，则全网节点广播验证，节点验证成功后，成功加入到区块链中。<br>以上就是比特币挖矿的全过程。</li></ul></li></ol><p>在区块头中，当前版本、父区块哈希、难度是固定不可改变的，那么想要改变区块头哈希值，需要调整nNonce、nTime和coinbase交易，而交易merkle树根的哈希值会随着coinbase交易的改变而改变。</p><h3 id="1-4-BTC的coinbase结构"><a href="#1-4-BTC的coinbase结构" class="headerlink" title="1.4 BTC的coinbase结构"></a>1.4 BTC的coinbase结构</h3><p>我们来看一下coinbase交易的结构，在下面的表格中可以看到在coinbase交易中，唯一能改变的就是coinbase data这个字段。所以该字段数据可由矿工自定义，用于增加区块头哈希的搜索空间。</p><div class="table-container"><table><thead><tr><th>Size</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>32 bytes</td><td>Transaction Hash</td><td>32字节全部为0</td></tr><tr><td>4 bytes</td><td>Output Index</td><td>固定值：0xFFFFFFFF</td></tr><tr><td>1-9 bytes(VarInt)</td><td>Coinbase Data size</td><td>coinbase数据的长度</td></tr><tr><td>Variable</td><td>Coinbase Data</td><td>数据由矿工自定义，用于增加搜索空间</td></tr><tr><td>4 bytes</td><td>Sequence Number</td><td>固定值：0xFFFFFFFF</td></tr></tbody></table></div><h3 id="1-5-BTC中目标、难度概念理解"><a href="#1-5-BTC中目标、难度概念理解" class="headerlink" title="1.5 BTC中目标、难度概念理解"></a>1.5 BTC中目标、难度概念理解</h3><p>我们前面说过，比特币挖矿需要<code>区块头的哈希值</code>与<code>当前的目标</code>进行对比。所以我们需要理解一下什么是目标、什么是难度。</p><p><strong>目标（target）</strong>：矿工计算的区块HASH值需要小于等于目标值才能有效出块。<br><strong>难度（difficulty）</strong>：难度是对挖矿困难程度的度量，即指：计算符合给定目标的一个Hash值的困难程度。<br><strong>nBits</strong>：目标值被压缩在区块头的nBits字段中，nBits字段以十六进制表示，总共有4个字节，前1个字节为<code>指数（exponent）</code>，后3个字节为<code>系数（coefficient）</code>。</p><p>目标可由nBits计算得到，目标计算公式如下：</p><blockquote><p>target = coefficient * 256^(exponent - 0x03)</p></blockquote><p>而难度由目标计算得到，难度计算公式如下：</p><blockquote><p>difficulty = 创世区块target / 当前区块target</p></blockquote><p>从比特币区块浏览器中可以查到，创世区块的nBits为<code>0x1D00FFFF</code>，其中指数为<code>0x1D</code>，系数为<code>0x00FFFF</code>，将其代入到目标计算公式中，可得创世区块的目标值：</p><blockquote><p>target = 0x00FFFF * 256^(0x1D - 0x03)</p><p>target = 0x00000000FFFF0000000000000000000000000000000000000000000000000000</p></blockquote><p>我们以高度为<code>686,580</code>这个高度区块为例子：</p><p><img src="https://i.loli.net/2021/07/08/hsrc1zMva2n9tkI.png" alt="block_case.png"></p><p>通过公式，可以计算出：</p><blockquote><p>current_target = 0x0d5f7b * 256^(0x17 - 0x03)</p><p>current_target = 0x0000000000000000000d5f7b0000000000000000000000000000000000000000</p></blockquote><p>得到了当前的目标值与创世区块目标值，通过难度公式，可计算出高度<code>686,580</code>的难度为：</p><blockquote><p>difficulty = init_target / current_target = 21,047,730,572,451 ≈ 21.05T</p></blockquote><h3 id="1-6-能不能一次挖多个币呢？"><a href="#1-6-能不能一次挖多个币呢？" class="headerlink" title="1.6 能不能一次挖多个币呢？"></a>1.6 能不能一次挖多个币呢？</h3><p><strong>答案是肯定的。</strong></p><p>当前存在一种机制，可以使得矿工在不影响挖比特币的同时，还能顺带挖另外几种虚拟币，以增加额外的收入，该机制就是联合挖矿。</p><h2 id="2-联合挖矿"><a href="#2-联合挖矿" class="headerlink" title="2. 联合挖矿"></a>2. 联合挖矿</h2><h3 id="2-1-ViaBTC矿池联合挖矿赠币规则"><a href="#2-1-ViaBTC矿池联合挖矿赠币规则" class="headerlink" title="2.1 ViaBTC矿池联合挖矿赠币规则"></a>2.1 ViaBTC矿池联合挖矿赠币规则</h3><p>目前许多主流的矿池都上线了挖矿赠币业务，例如在我们的矿池服务中，挖BTC可以额外获得NMC、EMC、SYS和ELA的赠币，挖LTC可以额外获得DOGE的赠币。</p><p><img src="https://i.loli.net/2021/07/08/qQo8PCYU3BSwexy.png" alt="merge_mining_rule.png"></p><p>下面我们来看一下联合挖矿的实现原理。</p><h3 id="2-2-联合挖矿实现"><a href="#2-2-联合挖矿实现" class="headerlink" title="2.2 联合挖矿实现"></a>2.2 联合挖矿实现</h3><ol><li><p>通过 rpc 调用辅链节点的 <code>getauxblock</code> 或者 <code>createauxblock</code> 方法，创建新块。返回结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hash&quot;                (string) hash of the created block</span><br><span class="line">  &quot;chainid&quot;             (numeric) chain ID for this block</span><br><span class="line">  &quot;previousblockhash&quot;   (string) hash of the previous block</span><br><span class="line">  &quot;coinbasevalue&quot;       (numeric) value of the block&#x27;s coinbase</span><br><span class="line">  &quot;bits&quot;                (string) compressed target of the block</span><br><span class="line">  &quot;height&quot;              (numeric) height of the block</span><br><span class="line">  &quot;_target&quot;             (string) target in reversed byte order, deprecated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Bitcoin的coinbase交易中，coinbase data字段可以写入任意自定义数据，那么通过写入规定格式的数据。我们在coinbase的coinbase data中添加以下信息：</p><p><img src="https://i.loli.net/2021/07/08/mV6sGop1d4iY2nQ.png" alt="coinbase_structure.png"></p><p>当有多条辅链时，需要用多条辅链的block_hash来构建出merkle树。那么就需要考虑辅链在merkle树底部的插槽位置。使用以下算法将chain ID转换为辅链的block_hash所在的merkle树的插槽位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cal_merkle_index</span><span class="params">(<span class="keyword">int</span> chain_id, <span class="keyword">int</span> nonce, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rand = nonce;</span><br><span class="line">    rand = rand * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    rand += chain_id;</span><br><span class="line">    rand = rand * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> rand % size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>矿工照常以挖比特币的方式挖矿，但有一点不同的是，需要判断以下三种情况：</p><ul><li>btc_hash_value &lt;= btc_target：矿工广播区块，矿工可以得到BTC的挖矿奖励和NMC辅链的挖矿奖励。</li><li>btc_target &lt; btc_hash_value &lt;= aux_target：矿工广播区块，矿工不能获取BTC的挖矿奖励，但是能获取辅链的挖矿奖励。</li><li>btc_hash_value &gt; aux_target：矿工不会广播。</li></ul></li><li><p>当矿工挖出区块后，通过 rpc 调用辅链节点的 <code>submitauxblock</code> 方法提交区块验证，参数与结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arguments:</span><br><span class="line">1. hash       (string, required) Hash of the block to submit</span><br><span class="line">2. auxpow     (string, required) Serialised auxpow found</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">xxxxx         (boolean) whether the submitted block was correct</span><br></pre></td></tr></table></figure><p>其中，auxpow包含以下内容：</p></li></ol><div class="table-container"><table><thead><tr><th>Size</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>Variable</td><td>coinbase</td><td>主链的coinbase信息</td></tr><tr><td>32 bytes</td><td>block_hash</td><td>主链区块hash值</td></tr><tr><td>Variable</td><td>coinbase_branch</td><td>主链的交易merkle分支</td></tr><tr><td>Variable</td><td>blockchain_branch</td><td>多个辅链的merkle分支</td></tr><tr><td>80 bytes</td><td>parent_block</td><td>主链区块头信息</td></tr></tbody></table></div><h3 id="2-3-个人（solo）挖矿的劣势"><a href="#2-3-个人（solo）挖矿的劣势" class="headerlink" title="2.3 个人（solo）挖矿的劣势"></a>2.3 个人（solo）挖矿的劣势</h3><p><img src="https://i.loli.net/2021/07/08/YrjJdNhtVQcRFn2.png" alt="solo_mining.png"></p><p>随着挖矿的人越来越多，挖矿设备也从cpu到显卡gpu再到专业矿机，算力越来越大，独立矿工挖到区块的概率越来越小，收益也越来越低，如果继续投入资金购买电脑，显卡、矿机等硬件设备，会大大提高成本，风险也越来越大，所以很多矿工不会选择 Solo 挖矿这种投资方式。</p><p>劣势：</p><ol><li>硬盘和带宽要求大</li><li>挖矿成功概率极低</li></ol><p>于是就有人提出把大家的算力集中在一起挖矿，算力大了，挖到区块的概率就会大大提高，然后再根据每个参与的矿工所占算力配额来进行奖励分配。<br>使用这种方法建立的特殊节点，就是矿池。</p><h2 id="3-矿池"><a href="#3-矿池" class="headerlink" title="3 矿池"></a>3 矿池</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>我们来看一下这张图，左边是区块链网络，上面这个是solo矿工，相比于全网算力来说自身的算力非常小，挖矿成功的概率也极小，下面的是矿池。</p><p><img src="https://i.loli.net/2021/07/08/dyp6fKmPYNXLSCu.png" alt="pool.png"></p><p>矿池是矿工的<strong>集合地</strong>，任何矿工都可以加入，无论个体还是组织，无论专业还是业余，都能为矿池提供自己的一份算力。加入到矿池的矿工挖到矿后，获得的奖励会被分配到矿池，然后矿池再根据预先设定的分红规则并结合各个矿工的算力进行奖励发放。<br>加入到矿池的矿工，只需要做一件事，那就是不停的计算矿池下发的任务，算出符合矿池难度的区块就进行提交。<br>矿池的工作就是需要对矿工进行管理，统计矿工算力和贡献，挖矿任务管理等。<br>矿池与矿工之间使用的是stratum矿池协议进行交互的，这是很重要的交互协议。</p><h3 id="3-2-stratum矿池协议"><a href="#3-2-stratum矿池协议" class="headerlink" title="3.2 stratum矿池协议"></a>3.2 stratum矿池协议</h3><p>stratum矿池协议有很多方法，最重要的就是以下几种方法：</p><ul><li><p><strong>订阅消息（mining.subscribe）</strong></p><p>矿机想参与挖矿，需要主动连接到矿池，向矿池申请加入挖矿，一般会附带自己挖矿软件的版本。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">矿机消息：</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;method&quot;:&quot;mining.subscribe&quot;,&quot;params&quot;:[version]&#125;\n</span><br><span class="line">矿池响应消息：</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;result&quot;:[[[&quot;mining.set_difficulty&quot;,&quot;1&quot;],[&quot;mining.notify&quot;,&quot;1&quot;]],&quot;&#123;extraNonce1&#125;&quot;,&#123;extraNonce2_len&#125;],“error”:null&#125;\n</span><br></pre></td></tr></table></figure><p><strong>extraNonce1</strong>：该字段由矿池为矿工分配，为了确保每个矿工不会做重复工作。<br><strong>extraNonce2_len</strong>：设定extraNonce2字段的长度，一般为4或8个字节，矿工挖矿时，通过该字段增加搜索空间。<br>现在，我们至少有了8个字节的搜索空间，即<code>nNonce</code>的4个字节，以及<code>extraNonce2</code>的4个字节。</p></li><li><p><strong>授权消息（mining.authorize）</strong></p><p>矿机使用帐号和密码登录到矿池，矿池返回true则登录成功。该方法必须是在初始化连接之后马上进行，否则矿机得不到矿池任务。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">矿机消息：</span><br><span class="line">&#123;&quot;id&quot;:2,&quot;method&quot;:&quot;mining.authorize&quot;,&quot;params&quot;:[&quot;&#123;account&#125;&quot;,&quot;&#123;password&#125;&quot;]&#125;\n</span><br><span class="line">矿池响应消息：</span><br><span class="line">&#123;&quot;id&quot;:2,&quot;result&quot;:true,&quot;error&quot;:null&#125;\n</span><br></pre></td></tr></table></figure></li><li><p><strong>下发难度（mining.set_difficulty）</strong></p><p>矿机被授权后，那么矿池会下发任务难度给矿机，后面矿机的挖矿，必须达到任务难度要后，矿池才登记贡献。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">矿池发送消息：</span><br><span class="line">&#123;&quot;id&quot;:null,&quot;method&quot;:&quot;mining.set_difficulty&quot;,&quot;params&quot;:[&#123;难度值&#125;]&#125;\n</span><br></pre></td></tr></table></figure></li><li><p><strong>下发任务（mining.notify）</strong></p><p>矿池会不断向矿机下发任务，矿机接到任务后，根据任务的标示，可以继续挖上一个任务，还是立即开始新的任务挖矿。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">矿池发送消息：</span><br><span class="line">&#123;&quot;id&quot;:null,&quot;method&quot;:&quot;mining.notify&quot;,&quot;params&quot;:[&quot;&#123;jobId&#125;&quot;,&quot;&#123;prev hash&#125;&quot;,&quot;&#123;coinbase1&#125;&quot;,&quot;&#123;coinbase2&#125;&quot;,[&#123;区块交易merkle_branch&#125;],&quot;&#123;version&#125;&quot;,&quot;&#123;nBits&#125;&quot;,&quot;&#123;nTime&#125;&quot;,&#123;是否立即更换任务&#125;]&#125;\n</span><br></pre></td></tr></table></figure></li><li><p><strong>提交消息（mining.submit）</strong></p><p>矿机根据挖矿任务开始挖矿，直到发现了满足矿池难度的区块后，将构造区块头必要的信息提交给矿池验证并广播。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">矿机消息：</span><br><span class="line">&#123;&quot;id&quot;:3,&quot;method&quot;:&quot;mining.submit&quot;,&quot;params&quot;:[&quot;&#123;account&#125;&quot;,&quot;&#123;jobId&#125;&quot;,&quot;&#123;extraNonce2&#125;&quot;,&quot;&#123;time&#125;&quot;,&quot;&#123;nonce&#125;&quot;]&#125;\n</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-如何增加矿工的搜索空间"><a href="#3-3-如何增加矿工的搜索空间" class="headerlink" title="3.3 如何增加矿工的搜索空间"></a>3.3 如何增加矿工的搜索空间</h3><p>如果仅仅给矿工可以改变nNonce（4字节，搜索空间4294967296大约43亿）和nTime（可变动范围很小）字段，则交互的数据量很少，但这点搜索空间肯定是不够的。<br>想要增加搜索，只能从<code>hashMerkleRoot</code>下功夫，如果让矿工自己构造coinbase，进而影响hashMerkleRoot值，那么搜索空间的问题将迎刃而解。<br>而构造Merkle树并不需要所有的交易数据，只需要某几个节点上的hash值，即可计算出修改coinbase后的hashMerkleRoot值。如下图：</p><p><img src="https://i.loli.net/2021/07/08/7mdoVCrY1W8xTOk.png" alt="merkle_branch.png"></p><p>我们将交易列表顺序固定下来后，只需要将merkle树中的一小部分节点的哈希值发给矿工，矿工就可以根据这些节点进行计算得到merkle树根。</p><h3 id="3-4-矿工的挖矿步骤"><a href="#3-4-矿工的挖矿步骤" class="headerlink" title="3.4 矿工的挖矿步骤"></a>3.4 矿工的挖矿步骤</h3><ol><li><p>构造coinbase交易</p><blockquote><p>coinbase = coinbase1 + extraNonce1 + extraNonce2 + coinbase2</p></blockquote><p>对于矿工来说，<code>coinbase1</code>、<code>extraNonce1</code>、<code>coinbase2</code>都是固定的，这是由矿池来填写，矿工只关心 <code>extraNonce2</code> 的长度。矿工生成指定长度的<code>extraNonce2</code>来增加搜索空间。</p></li><li><p>构建hashMerkleRoot</p><p>利用coinbase和merkle_branch，生成hashMerkleRoot。</p></li><li><p>构建区块头</p><p>填充余下的5个字段，现在，矿工可以在 nTime、nNonce 和 extraNonce2 里搜索进行挖矿，如果嫌搜索空间还不够，只要增加Extranonce2_size为多几个字节就可轻而易举解决。</p></li></ol><h2 id="4-ViaBTC矿池实现"><a href="#4-ViaBTC矿池实现" class="headerlink" title="4. ViaBTC矿池实现"></a>4. ViaBTC矿池实现</h2><p>项目路径：<a href="https://github.com/viabtc/viabtc_mining_server">https://github.com/viabtc/viabtc_mining_server</a></p><h3 id="4-1-ViaBTC矿池架构图"><a href="#4-1-ViaBTC矿池架构图" class="headerlink" title="4.1 ViaBTC矿池架构图"></a>4.1 ViaBTC矿池架构图</h3><p><img src="https://i.loli.net/2021/07/08/cawiHMVkBtgWI4N.png" alt="mining_pool_arch.png"></p><p>这张图是viabtc矿池的server层架构图，接下来我将讲解每个服务的作用与功能。</p><h3 id="4-2-bitpeer"><a href="#4-2-bitpeer" class="headerlink" title="4.2 bitpeer"></a>4.2 bitpeer</h3><p><img src="https://i.loli.net/2021/07/08/AyrhiqYwXGoP15k.png" alt="bitpeer.png"></p><ul><li>bitpeer实现了btc的p2p网络协议，可以把它当成是一个简化版的BTC节点，实现了p2p的部分功能。</li><li>部署多个bitpeer，可加速区块在btc网络中的广播。</li><li>当区块高度更新时，需要通知jobmaster放弃旧块的挖掘转而开始新块任务</li></ul><h3 id="4-3-blockmaster"><a href="#4-3-blockmaster" class="headerlink" title="4.3 blockmaster"></a>4.3 blockmaster</h3><p><img src="https://i.loli.net/2021/07/08/cnFzt4Khwe8HU7g.png" alt="blockmaster.png"></p><p>blockmaster的主要功能有：</p><ol><li><p>将矿工挖掘到的区块发送给bitpeer进行广播。</p></li><li><p>为了更快的进行区块广播，blockmaster将区块处理成瘦块广播。</p></li></ol><p><strong>瘦块原理：</strong></p><p>为了更快的进行区块广播，blockmaster将区块处理成瘦块，原理是剔除掉区块交易（不包括coinbase交易）中除了交易哈希值之外的交易信息，因为交易详细信息可通过交易哈希值向节点查询，所以大大减少了区块的大小，瘦块在网络上传输将会加快，将瘦块发送给其他地区的blockmaster组装成完整的区块进行广播。</p><p><img src="https://i.loli.net/2021/07/08/cxTVYO489NPHmnF.png" alt="thin_block.png"></p><p><code>bitpeer</code> 和 <code>blockmaster</code> 这两个服务的主要功能是为了加速区块的广播，毕竟比别人先一步将区块进行广播到全网验证，就能抢先一步将区块加到链中，获得奖励。</p><h3 id="4-3-jobmaster"><a href="#4-3-jobmaster" class="headerlink" title="4.3 jobmaster"></a>4.3 jobmaster</h3><p>主要功能：</p><ol><li><p>构造区块信息给gateway发送挖矿任务。</p></li><li><p>接收gateway提交的区块，并进行广播。</p></li></ol><h3 id="4-4-gateway"><a href="#4-4-gateway" class="headerlink" title="4.4 gateway"></a>4.4 gateway</h3><p>主要功能：</p><ol><li>管理矿工、矿场管理员。</li><li>矿工难度值动态调整。</li><li>实现stratum矿池协议与矿工交互。</li><li><p>测算各个矿工的算力。</p></li><li><p>验证矿工提交的share，并进行验证统计。</p></li></ol><h3 id="4-5-poolbench"><a href="#4-5-poolbench" class="headerlink" title="4.5 poolbench"></a>4.5 poolbench</h3><p>监控其他矿池的状态，如果其他矿池的区块高度有更新，则通知jobmaster开始挖新块。</p><h3 id="4-6-mineragent"><a href="#4-6-mineragent" class="headerlink" title="4.6 mineragent"></a>4.6 mineragent</h3><ol><li>gateway代理，从gateway接收挖块任务。</li><li><p>实现stratum协议，为矿工分配任务。</p></li><li><p>主要用于矿机数量庞大的矿场，部署在矿场中，可以有效节省带宽，提升性能。</p></li></ol><h3 id="4-7-算力统计"><a href="#4-7-算力统计" class="headerlink" title="4.7 算力统计"></a>4.7 算力统计</h3><p>为统计矿工的算力贡献，矿池会为每个矿工设置难度值，当矿工挖掘的区块达到难度值要求时，就提交一次share，矿池可通过矿工难度测算出矿工的算力。<br>矿池要求矿工大约每4秒提交一次share，那么，如何控制矿工难度来达到该要求呢？</p><ol><li>新的矿工连接到矿池，矿池会为矿工分配一个默认难度值（1024）。</li><li>矿池给矿工下发任务和该难度值，矿工开始挖矿。</li><li>矿工挖出区块达到该难度值的要求后，提交share给矿池。</li><li>矿池收到后，判断矿工此次提交的share是否有效，有效则记录此次提交的时间间隔，计算此次矿工的工作量与挖矿难度的比例（goal），矿池计算矿工多次提交share的平均时间（avg）后，进行如下判断：<ul><li>如果avg大于4s，并且（avg / 4s）大于1.5，则矿工难度值需要<strong>减半</strong>。</li><li>如果avg小于4s，并且（avg / 4s）小于0.7，则矿工难度值需要<strong>增加一倍</strong>。</li></ul></li><li>每次有效提交share，矿池会将矿工的<code>难度值</code>、<code>有效提交share次数</code>和 <code>goal</code> 收集起来，每隔60秒将数据提交给metawriter，metawriter会将数据记录到redis，用于计算矿工的收益。</li></ol><h3 id="4-8-收益结算"><a href="#4-8-收益结算" class="headerlink" title="4.8 收益结算"></a>4.8 收益结算</h3><p>矿池常用的分红规则如下：</p><ul><li><p><strong>PPS（pay per share）</strong></p><p>矿池对矿工提交的每一个工作量证明 (share) 按照理论收益付费，相当于矿工给矿池打工，根据提供的算力稳定获取收益。 由于矿工不承担风险，矿池承担了运气风险和孤块风险，所以收取相对较高的费用。</p></li><li><p><strong>PPLNS（Pay Per Last N Shares）</strong></p><p>矿池每发现有效的区块， 根据过去 N 个难度周期中用户算力占矿池算力的比例进行分配，矿工费也参与分配。 矿池收取相对较少的费用，用于矿池的运营和维护。 这种方式下矿工的收益和矿池的出块相关，矿工收益不稳定，但长期平均收益更高。</p></li><li><p><strong>PPS+（Pay Per Share Plus）</strong></p><p>对传统 PPS 结算方式的一种改进，在传统的 PPS 结算方式基础上，增加了矿工费的分配。 在这种方式下，矿池对矿工提交的每一个工作量证明 (share) 按照理论收益付费，相当于矿工给矿池打工，根据提供的算力稳定获取收益。 由于矿工不承担风险，矿池承担了运气风险和孤块风险，所以收取相对较高的费用。 矿工费另外通过下述的 PPLNS 方式分配给矿工。</p></li><li><p><strong>SOLO</strong></p><p>全部收益分配给挖出该块的矿工，其他矿工不参与分配，矿池收取极少手续费，用于矿池运营和维护。</p></li></ul><p>ViaBTC矿池支持三种结算方式：PPS+、PPLNS和SOLO。默认为PPS+结算方式。</p><p><strong>PPS+模式：</strong></p><div class="table-container"><table><thead><tr><th>挖矿收益</th><th>块奖励</th><th>交易费（不固定）</th></tr></thead><tbody><tr><td>结算方式</td><td>PPS</td><td>PPLNS</td></tr><tr><td>费率</td><td>4%</td><td>2%</td></tr><tr><td>计算公式</td><td>工作量 / 挖矿难度 <em> 块奖励 </em> (1 - 费率)</td><td>用户算力 / 矿池算力 <em> 块收益 </em> (1 - 费率)</td></tr><tr><td>分配规则</td><td>每个小时根据当前难度结算一次</td><td>区块得到6次确认后，根据过去5个难度周期内用户算力占矿池算力的比例进行分配</td></tr></tbody></table></div><p><strong>PPLNS 模式：</strong></p><div class="table-container"><table><thead><tr><th>挖矿收益</th><th>块奖励 + 交易费（不固定）</th></tr></thead><tbody><tr><td>费率</td><td>2%</td></tr><tr><td>计算方式</td><td>用户算力／矿池算力 <em> 挖矿收益 </em>（1 - 费率）</td></tr><tr><td>分配规则</td><td>区块得到6次确认后，根据过去5个难度周期内用户算力占矿池算力的比例进行分配</td></tr></tbody></table></div><p><strong>SOLO 模式：</strong></p><div class="table-container"><table><thead><tr><th>挖矿收益</th><th>块奖励 + 交易费（不固定）</th></tr></thead><tbody><tr><td>费率</td><td>1%</td></tr></tbody></table></div><p><strong>联合挖矿：</strong></p><div class="table-container"><table><thead><tr><th>币</th><th>规则</th></tr></thead><tbody><tr><td>BTC</td><td>每挖 1 个 BTC 赠送 1 个 NMC</td></tr><tr><td>BTC</td><td>每挖 1 个 BTC 赠送 5 个 SYS</td></tr><tr><td>BTC</td><td>每挖 1 个 BTC 赠送 0.1 个 EMC</td></tr><tr><td>BTC</td><td>每挖 1 个 BTC 赠送 1 个 ELA</td></tr><tr><td>BCH</td><td>每挖 1 个 BCH 赠送 1 个 SYS</td></tr><tr><td>LTC</td><td>挖 LTC 送 DOGE，按 PPLNS 模式结算</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-挖矿&quot;&gt;&lt;a href=&quot;#1-挖矿&quot; class=&quot;headerlink&quot; title=&quot;1. 挖矿&quot;&gt;&lt;/a&gt;1. 挖矿&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是挖矿&quot;&gt;&lt;a href=&quot;#1-1-什么是挖矿&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是挖矿&quot;&gt;&lt;/a&gt;1.1 什么是挖矿&lt;/h3&gt;&lt;p&gt;挖矿的本质就是构造符合规则（PoW共识机制）的区块并进行全网验证的过程。作为激励，矿工成功挖掘到区块后，可以从中获取区块奖励和交易费奖励。&lt;/p&gt;
&lt;p&gt;下面以BTC为例，阐述挖矿的运作流程。&lt;/p&gt;</summary>
    
    
    
    <category term="blockchain" scheme="https://blog.grizzlys.top/categories/blockchain/"/>
    
    
    <category term="blockchain" scheme="https://blog.grizzlys.top/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前中后序递归法和迭代法</title>
    <link href="https://blog.grizzlys.top/DataStructure/binary-tree-traversal/"/>
    <id>https://blog.grizzlys.top/DataStructure/binary-tree-traversal/</id>
    <published>2021-02-04T03:57:25.000Z</published>
    <updated>2021-07-08T02:33:40.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的前中后序递归法和迭代法"><a href="#二叉树的前中后序递归法和迭代法" class="headerlink" title="二叉树的前中后序递归法和迭代法"></a>二叉树的前中后序递归法和迭代法</h1><p>二叉树根据遍历方式，分为<strong>深度优先搜索（DFS）</strong>和<strong>广度优先搜索（BFS）</strong>。</p><p>二叉树的深度优先搜索：</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><p>二叉树的广度优先搜索：</p><ul><li>层序遍历<a id="more"></a></li></ul><p><img src="https://i.loli.net/2021/02/04/e1dnxwVrZ2oLyEu.png" alt="binary-tree-traversal.png"></p><p>以上二叉树中，深度优先搜索结果：</p><ul><li>前序遍历（<strong>中</strong>左右）：1 2 4 5 8 3 6 7 9</li><li>中序遍历（左<strong>中</strong>右）：4 2 5 8 1 6 3 9 7</li><li>后续遍历（左右<strong>中</strong>）：4 8 5 2 6 9 7 3 1</li></ul><p>广度优先搜索结果：</p><ul><li>层序遍历：1 2 3 4 5 6 7 8 9</li></ul><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>递归算法三要素：</p><ol><li><p>确定递归的返回值和参数：</p><p>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li><p>确定递归的终止条件：</p><p>操作系统通过栈结构来存储每一层递归的信息，而栈空间是有限的，如果递归没有终止，则会一直递归下去，操作系统的内存栈必然会溢出，导致程序崩溃。</p><p>所以何时终止？如何终止？这都是必须要考虑到的。</p></li><li><p>确定单层递归的处理逻辑：</p><p>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><p>下面以<strong>返回前序遍历的数组</strong>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> v) : val(v), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>确定递归的返回值和参数：要求返回前序遍历的数组，所以递归函数不需要返回值，参数里需要传入二叉树的当前节点和 vector 用于存放遍历的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></table></figure></li><li><p>确定递归的终止条件:在递归过程中，为了防止无限递归下去，需要一个终止条件，本例子中，当前节点为空时，不需要（也不能）处理任何信息，所以直接返回就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></li><li><p>确定单层递归的处理逻辑:前序遍历是以<code>中-&gt;左-&gt;右</code>来进行遍历的，所以优先处理中节点信息，然后再往左节点和右节点递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.push_back(node-&gt;val);</span><br><span class="line">traversal(node-&gt;left, vec);</span><br><span class="line">traversal(node-&gt;right, vec);</span><br></pre></td></tr></table></figure></li></ol><p>根据以上要素，完成前序遍历的完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        vec.push_back(node-&gt;val);</span><br><span class="line">        traversal(node-&gt;left, vec);</span><br><span class="line">        traversal(node-&gt;right, vec);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据三要素的思想，不难写出中序遍历和后续遍历，如下：</p><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    traversal(node-&gt;left, vec);</span><br><span class="line">    vec.push_back(node-&gt;val);</span><br><span class="line">    traversal(node-&gt;right, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    traversal(node-&gt;left, vec);</span><br><span class="line">    traversal(node-&gt;right, vec);</span><br><span class="line">    vec.push_back(node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>递归法的实现就是每一次递归调用都会把函数的局部变量，参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>所以通过栈结构，无需递归也可以实现二叉树的前中后序遍历。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历就是优先处理中间节点，然后再进行左右节点的处理。所以入栈顺序应该是先压入根节点，接着将右节点压入栈中，再加入左节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;<span class="comment">// 辅助栈</span></span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(node-&gt;val);<span class="comment">// 中节点处理</span></span><br><span class="line">            <span class="comment">// 根据栈的特性（先进后出），需要先压入右节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                st.push(node-&gt;right);<span class="comment">// 右节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                st.push(node-&gt;left);<span class="comment">// 左节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进 result 数组中），这就造成了处理顺序和访问顺序是不一致的。</p><p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">midOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;    <span class="comment">// 辅助栈</span></span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur) &#123;  <span class="comment">// 先访问到二叉树的最底层</span></span><br><span class="line">                st.push(cur);   <span class="comment">// 将访问到的节点压入栈中</span></span><br><span class="line">                cur = cur-&gt;left;            <span class="comment">// 左节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 此时当前节点为空（无左节点）</span></span><br><span class="line">                cur = st.top();<span class="comment">// 从栈里弹出节点</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val); <span class="comment">// 中节点的数据处理</span></span><br><span class="line">                cur = cur-&gt;right;           <span class="comment">// 右节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>前序遍历的遍历顺序是：<code>左右中</code>，后序遍历的顺序是：<code>中左右</code>。</p><p>那么我只需要在前序遍历时，将<code>左右中</code>改为<code>右左中</code>，然后再将数组反转（<code>中左右</code>），即可得到后序遍历的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;    <span class="comment">// 辅助栈</span></span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            result.push_back(node-&gt;val);    <span class="comment">// 中节点处理</span></span><br><span class="line">            <span class="comment">// 此时先压入左节点，将前序遍历改为 右左中</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                st.push(node-&gt;left);        <span class="comment">// 左节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                st.push(node-&gt;right);       <span class="comment">// 右节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代方式统一写法"><a href="#迭代方式统一写法" class="headerlink" title="迭代方式统一写法"></a>迭代方式统一写法</h2><p>因为迭代法实现的前中后序风格不统一，除了前序和后序有关联，中序完全就是另一种写法了。</p><p>针对三种遍历方式，使用迭代法是可以写出统一风格的代码的。</p><p>不统一的问题是：无法同时解决访问节点和处理节点不一致的情况。</p><p>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</p><p>如何标记呢？<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p><p>完整代码如下：</p><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">                st.pop();   <span class="comment">// 将该节点弹出，避免重复操作，下面再将右左中节点添加到栈中</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.push(node-&gt;right);  <span class="comment">// 添加右节点</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.push(node-&gt;left);    <span class="comment">// 添加左节点</span></span><br><span class="line"></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">nullptr</span>);   <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();   <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.top();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(node-&gt;val);    <span class="comment">// 处理节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">midOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.push(node-&gt;right);  <span class="comment">// 添加右节点</span></span><br><span class="line"></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.push(node-&gt;left);    <span class="comment">// 添加左节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                node = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();</span><br><span class="line">            <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line"></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.push(node-&gt;right);  <span class="comment">// 添加右节点</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.push(node-&gt;left);    <span class="comment">// 添加左节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                node = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;二叉树的前中后序递归法和迭代法&quot;&gt;&lt;a href=&quot;#二叉树的前中后序递归法和迭代法&quot; class=&quot;headerlink&quot; title=&quot;二叉树的前中后序递归法和迭代法&quot;&gt;&lt;/a&gt;二叉树的前中后序递归法和迭代法&lt;/h1&gt;&lt;p&gt;二叉树根据遍历方式，分为&lt;strong&gt;深度优先搜索（DFS）&lt;/strong&gt;和&lt;strong&gt;广度优先搜索（BFS）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;二叉树的深度优先搜索：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历&lt;/li&gt;
&lt;li&gt;中序遍历&lt;/li&gt;
&lt;li&gt;后序遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉树的广度优先搜索：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;层序遍历&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="DataStructure" scheme="https://blog.grizzlys.top/categories/DataStructure/"/>
    
    
    <category term="DataStructure" scheme="https://blog.grizzlys.top/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>C++实现高性能日志框架</title>
    <link href="https://blog.grizzlys.top/c/cpp-asynclogging/"/>
    <id>https://blog.grizzlys.top/c/cpp-asynclogging/</id>
    <published>2020-10-28T08:31:43.000Z</published>
    <updated>2021-07-08T02:33:40.855Z</updated>
    
    <content type="html"><![CDATA[<p>在一个优秀的系统中，日志是不可或缺的组成部分。尤其是在服务端编程中，日志更是必不可少的，如果没有日志，我们将不得不依赖客户或支持团队，让他们描述在什么情况下发生了什么。随后在开发环境中重现问题，并进行各种调试，直至完全修复错误为止，然而这一般耗费很长时间。如果有了日志的帮助，可以从日志中快速的定位异常，并解决问题。<br>使用日志的好处并不止以上一点，还包括：<br><a id="more"></a></p><ol><li>采集和分析用户行为</li><li>可用于数据统计及分析</li><li>追踪程序执行的过程</li><li>程序性能检测</li><li>等等。</li></ol><h2 id="关于重复造轮子"><a href="#关于重复造轮子" class="headerlink" title="关于重复造轮子"></a>关于重复造轮子</h2><p>在开源技术大爆发的时代，每一个领域中都有很多很好的解决方案。C++ 日志框架也很等多成熟的方案，如：Boost.Log、glog、Log4cpp、log4cplus、loguru、Easylogging++ 等等的优秀日志框架可以使用。<br>那么已经有了这么多成熟的方案下，还有必要去重新造轮子吗？没有必要。话虽如此，但是还是有必要去了解关于轮子的各个细节。在学习轮子的过程中，也能提高我们自己的编程能力和各种技术的理解。</p><h2 id="高性能的日志库"><a href="#高性能的日志库" class="headerlink" title="高性能的日志库"></a>高性能的日志库</h2><p>在陈硕先生的《Linux多线程服务端编程》一书中提到，一个高性能的日志库应具备以下需求：</p><ul><li>功能需求：<ol><li>日志消息多种级别（level）。（必须）</li><li>日志消息可能有多个目的地（文件、socket、SMTP等）。（非必须）</li><li>日志消息格式可配置。（非必须）</li><li>可以设置运行时过滤器。（非必须）</li></ol></li><li>性能需求：<ol><li>每秒写几千上万条日志的时候没有明显的性能损失。</li><li>能应对一个进程产生大量日志数据的场景。</li><li>不阻塞正常的执行流程。</li><li>在多线程程序中，不造成争用。</li></ol></li></ul><p>在一个复杂的系统环境中，每一条日志应该对应不同的级别，比如 INFO、WARNING、ERROR 等，在开发环境中应增加 TRACE、DEBUG 等，这有助于开发人员快速定位问题和后续对日志数据进行统计以及分析。在不同的环境中调整不同级别的日志等级，还可减少日志的数目，如在生产环境中，可关闭掉 TRACE 和 DEBUG 日志的输出，只留下重要的日志。<br>性能要求是重中之重，一个程序的大部分资源应该用于处理业务，只有少部分资源来用做日志输出，所有只有日志库足够高效，程序员才敢在代码中输出足够多的诊断信息。</p><h2 id="如何实现高性能的日志框架"><a href="#如何实现高性能的日志框架" class="headerlink" title="如何实现高性能的日志框架"></a>如何实现高性能的日志框架</h2><p>我所设想的日志库应该满足以下需求：</p><ol><li>多线程程序并发写日志，即线程安全。</li><li>一个进程的多线程只写到一个文件中。</li><li>文件滚动，在日志文件满足特定需求（文件大小、特定时间等）后，需要将后续日志写入到新的日志文件中。</li><li>只能占用程序少量资源。</li></ol><p>为了满足以上需求，异步日志是必须的，因为在业务处理线程中直接往磁盘写数据的话，写操作可能会阻塞业务线程，这将导致程序性能下降。<br>一个解决方案是，将日志进行分离，专门启动一条线程用于写磁盘的操作，业务线程发来的数据插入到一个队列中（或者一个buffer块中），后端线程取出数据并写入磁盘，这样就不会影响到业务线程了。<br>那么使用队列还是双缓冲技术呢？<br>这里我采用双缓冲技术，因为使用队列的话，每次产生一条日志消息都需要通知(notify_one())后端线程。<br>双缓冲技术的基本思路是，使用两块 buffer，其中，buffer A 专门用于前端业务填充数据，后端线程负责将 buffer B 中的数据写入到文件中，当 buffer A 写满后，交换 A 和 B，让后端将 A 中的数据写入到文件中，而前端则往 B 中填数据。实际编写过程中，将不止用到两块 buffer，如果两块 buffer 都满了，并且后端线程还在进行磁盘 IO 操作的话，则需要临时申请 buffer 用来填充数据。当后端线程能正常处理数据后，将临时申请的 buffer 销毁，只保留两块 buffer。<br>这样做的好处是，创建日志消息时不需要等待磁盘文件操作，也避免了每条日志都需要触发后端日志线程。</p><p>如下图所示，异步日志的框架图：</p><p><img src="https://i.loli.net/2020/10/29/1HQT9A4Z2iranfV.png" alt="AsyncLogging.png"></p><p>根据以上的大致思路，我实现了一个异步日志库 <a href="https://github.com/Grizzly1127/momoko-log">momoko-log</a>，已托管到 github 上。</p><h2 id="momoko-log"><a href="#momoko-log" class="headerlink" title="momoko-log"></a>momoko-log</h2><p>momoko-log 是基于 C++11 开发的高性能异步日志框架，该框架只能用于 Linux 中，不支持跨平台。<br>momoko-log 日志库特点如下：</p><ol><li>每秒可写百万条数据到磁盘中。</li><li>多线程程序并发写日志到一个日志文件中。</li><li>文件滚动。</li><li>日志多级别输出。</li><li>接口简单(重载了多种数据类型的 <code>&lt;&lt;</code> 操作符)，使用方便。</li><li>采用批处理方式记录日志。</li></ol><p>momoko-log 日志输出格式固定，以避免频繁改动日志格式对后面日志数据分析加强难度。<br>日志格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp threadId logLevel file:line -&gt;  content</span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;momoko-log/logger.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set log level</span></span><br><span class="line">    <span class="comment">//SET_LOGLEVEL(momoko::Logger::INFO)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set to asynchronous logger</span></span><br><span class="line">    LOG_SET_ASYNC(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;info message, num.&quot;</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;warning message, num.&quot;</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">&quot;error message, num.&quot;</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个优秀的系统中，日志是不可或缺的组成部分。尤其是在服务端编程中，日志更是必不可少的，如果没有日志，我们将不得不依赖客户或支持团队，让他们描述在什么情况下发生了什么。随后在开发环境中重现问题，并进行各种调试，直至完全修复错误为止，然而这一般耗费很长时间。如果有了日志的帮助，可以从日志中快速的定位异常，并解决问题。&lt;br&gt;使用日志的好处并不止以上一点，还包括：&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://blog.grizzlys.top/categories/c/"/>
    
    
    <category term="c++" scheme="https://blog.grizzlys.top/tags/c/"/>
    
    <category term="async" scheme="https://blog.grizzlys.top/tags/async/"/>
    
    <category term="logging" scheme="https://blog.grizzlys.top/tags/logging/"/>
    
  </entry>
  
  <entry>
    <title>select/poll/epoll之间的区别</title>
    <link href="https://blog.grizzlys.top/net/net-io-multiplexing/"/>
    <id>https://blog.grizzlys.top/net/net-io-multiplexing/</id>
    <published>2020-09-25T07:53:27.000Z</published>
    <updated>2021-07-08T02:33:40.864Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍了 <a href="../net-io-multiplexing-select">《IO多路复用 - select》</a>、<a href="../net-io-multiplexing-poll">《IO多路复用 - poll》</a>和<a href="../net-io-multiplexing-epoll">《IO多路复用 - epoll》</a>，那么这三者之间有什么优缺点呢？下面我们来看看</p><a id="more"></a><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>优点：</p><ul><li>select 遵循 POSIX 的规范，支持跨平台，具有良好的兼容性，可以在不同操作系统上使用 select 实现高性能服务器。</li></ul><p>缺点：</p><ul><li>单个进程能打开的最大连接数有限制，只能打开最大为 FD_SETSIZE 宏定义大小的连接数。</li><li>当有新的连接时，每次都需要将所有的 fd 集合从用户空间拷贝到内核空间，开销大。</li><li>当有新的 IO 事件发生时，每次都需要将所有的 fd 集合从内核空间拷贝到用户空间，开销大。</li><li>需要轮询遍历所有 fd 集合，才能知道哪些 fd 就绪，时间复杂度为 O(N)。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>优点：</p><ul><li>相较于 select，poll 是基于链表来存储 fd 集合的，所以并不会像 select 那样存在最大的连接数限制（受服务器资源限制）。</li></ul><p>缺点：</p><ul><li>非跨平台，只能在 Unix/Linux 操作系统上开发。</li><li>同 select 一样，都会有大量的 fd 集合被整体复制于用户空间和内核空间之间，开销大。</li><li>IO 效率与 select 一样，都需要轮询遍历所有 fd 集合，才能知道哪些 fd 就绪，时间复杂度为 O(N)。</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>优点：</p><ul><li>理论上同样不存在最大连接数限制（受服务器资源限制）。</li><li>效率提升，只有活跃的 fd 才会主动调用 callback 回调函数，时间复杂度为 O(1)。</li><li>底层由红黑树来管理 fd 集合，通过就绪队列链表将就绪的 fds 拷贝到用户空间，而不需要将所有 fd 集合全部拷贝，省去了不必要的内存拷贝。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>epoll 对 select/poll 的缺点进行了改进。在 select/poll 中，进程只有在调用一定的方法后，内核才对所有监视的 fd 集合进行扫描，而 epoll 事先通过 epoll_ctl 来注册一个 fd，一旦某个 fd 就绪时，内核会采用 callback 的回调机制，迅速激活这个 fd，当进程调用 epoll_wait 时便能得到通知。<br>在高并发的场景下 epoll 一切都很好，是 Linux 目前大规模网络并发程序开发的首选模型。但是因为 epoll 底层的回调机制，在低并发、高活跃 fd 的场景下，select/poll 并不会比 epoll 差，可能性能会更高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面介绍了 &lt;a href=&quot;../net-io-multiplexing-select&quot;&gt;《IO多路复用 - select》&lt;/a&gt;、&lt;a href=&quot;../net-io-multiplexing-poll&quot;&gt;《IO多路复用 - poll》&lt;/a&gt;和&lt;a href=&quot;../net-io-multiplexing-epoll&quot;&gt;《IO多路复用 - epoll》&lt;/a&gt;，那么这三者之间有什么优缺点呢？下面我们来看看&lt;/p&gt;</summary>
    
    
    
    <category term="net" scheme="https://blog.grizzlys.top/categories/net/"/>
    
    
    <category term="I/O多路复用" scheme="https://blog.grizzlys.top/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
    <category term="epoll" scheme="https://blog.grizzlys.top/tags/epoll/"/>
    
    <category term="select" scheme="https://blog.grizzlys.top/tags/select/"/>
    
    <category term="poll" scheme="https://blog.grizzlys.top/tags/poll/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用 - epoll</title>
    <link href="https://blog.grizzlys.top/net/net-io-multiplexing-epoll/"/>
    <id>https://blog.grizzlys.top/net/net-io-multiplexing-epoll/</id>
    <published>2020-09-25T07:47:20.000Z</published>
    <updated>2021-07-08T02:33:40.862Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲了 select 和 poll 的原理，接下来我们学习它们改进后的增强版本：epoll。<br><a id="more"></a></p><h2 id="epoll介绍"><a href="#epoll介绍" class="headerlink" title="epoll介绍"></a>epoll介绍</h2><h3 id="epoll相关函数"><a href="#epoll相关函数" class="headerlink" title="epoll相关函数"></a>epoll相关函数</h3><p>在 <code>man</code> 手册中，可以查到 epoll 的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>具体参数详解：</p><ul><li>epoll_create : 创建 epoll 句柄。<ul><li>size : 并没有什么用，但是必须要大于 0，否则创建 epoll 句柄失败。</li></ul></li><li>epoll_ctl : epoll 事件注册函数。<ul><li>epfd : 由 epoll_create 创建的 epoll 句柄。</li><li>op : fd 的操作类型：<ul><li>EPOLL_CTL_ADD : 注册新的 fd 到 epfd 中。</li><li>EPOLL_CTL_MOD : 修改已注册的 fd 的监听事件。</li><li>EPOLL_CTL_DEL : 从 epfd 中删除一个 fd。</li></ul></li><li>fd : 监听的文件描述符。</li><li>event : 要监听的事件，事件属性可以查看下表。</li></ul></li><li>epoll_wait : 等待 epoll 事件的产生。<ul><li>epfd : 由 epoll_create 创建的 epoll 句柄。</li><li>events : 内核得到的就绪事件集合。</li><li>maxevents : 内核events的大小。</li><li>timeout : 设定超时时间：<ul><li>0 : 立即返回。</li><li>-1 : 阻塞。</li><li>正数 : 设定超时时间。</li></ul></li></ul></li></ul><p>epoll_event 结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span>   u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span>   u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span>   events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>event 中指定的位掩码的值如下：</p><div class="table-container"><table><thead><tr><th>事件</th><th>描述</th><th style="text-align:center">是否可作为 epoll_ctl() 的输入</th><th style="text-align:center">是否可作为 epoll_wait() 的输出</th></tr></thead><tbody><tr><td>EPOLLIN</td><td>表示对应的文件描述符可读</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>EPOLLOUT</td><td>表示对应的文件描述符可写</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>EPOLLRDHUP</td><td>Linux 2.6.17 版本后添加的事件，表示对端断开连接</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>EPOLLPRI</td><td>表示对应的文件描述符有紧急数据可读（外带数据）</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>EPOLLERR</td><td>表示对应的文件描述符发生错误</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td>EPOLLHUP</td><td>表示对应的文件描述符被挂断</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td>EPOLLET</td><td>采用边缘触发事件通知</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td>EPOLLONESHOT</td><td>在完成事件通知之后禁用检查</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr></tbody></table></div><p><strong>工作模式：</strong><br>epoll 除了提供 select/poll 那种 IO 事件的水平触发（level-triggered）外，还提供了边缘触发模式（edge-triggered），这就是的用户空间程序有可能缓存 IO 状态，减少 <code>epoll_wait/epoll_pwait</code> 的调用，提高应用程序效率。</p><ul><li>水平触发（LT） : 默认工作模式，即当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次通知此事件。</li><li>边缘触发（ET） : 当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。</li></ul><p><strong>epoll 工作在 ET 模式的时候，必须使用非阻塞套接字，以避免由于一个文件句柄的阻塞读/写操作把处理多个文件描述符的任务饿死。</strong></p><h2 id="epoll使用"><a href="#epoll使用" class="headerlink" title="epoll使用"></a>epoll使用</h2><p>使用流程图如下：<br><img src="https://i.loli.net/2020/10/29/7wIhkVXonSJ6j3g.png" alt="epoll.png"></p><p>实现简单的服务代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 10240</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opts = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (opts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl(F_GETFL)\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    opts |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, opts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fcntl(F_SETFL)\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = event;</span><br><span class="line">    ev.data.fd = epollfd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = event;</span><br><span class="line">    ev.data.fd = epollfd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = event;</span><br><span class="line">    ev.data.fd = epollfd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_sockfd, client_sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> client_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立服务器端socket</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_address.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    bind(server_sockfd, (struct sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>); <span class="comment">//监听队列最多容纳5个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epollfd = epoll_create(<span class="number">1</span>);     <span class="comment">//这个参数已经被忽略，但是仍然要大于0</span></span><br><span class="line">    <span class="keyword">if</span> (epollfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create epoll error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_event(epollfd, server_sockfd, EPOLLIN|EPOLLET); <span class="comment">// 设置为边缘触发模式</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取已经准备好的描述符事件</span></span><br><span class="line">        <span class="keyword">int</span> count = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            fd = events[i].data.fd;</span><br><span class="line">            <span class="comment">// 新的客户端连接</span></span><br><span class="line">            <span class="keyword">if</span> ((fd == server_sockfd) &amp;&amp;(events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                client_len = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                <span class="comment">// 接受新的客户端连接</span></span><br><span class="line">                client_sockfd = accept(server_sockfd, (struct sockaddr *)&amp;client_address, (<span class="keyword">socklen_t</span> *)&amp;client_len);</span><br><span class="line">                <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 边缘模式必须要设置为非阻塞模式fd</span></span><br><span class="line">                set_nonblocking(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有可读事件</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> nread;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 边缘触发模式需要讲数据读取完，否则下次不会再通知</span></span><br><span class="line">                <span class="keyword">while</span> ((nread = read(fd, buf + len, BUFSIZ - <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    len += nread;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client %d exit\n&quot;</span>, fd);</span><br><span class="line">                    close(fd);</span><br><span class="line">                    delete_event(epollfd, fd, EPOLLIN);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;recv: %d\n&quot;</span>, errno);</span><br><span class="line">                    close(fd);</span><br><span class="line">                    delete_event(epollfd, fd, EPOLLIN);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll实现原理"><a href="#epoll实现原理" class="headerlink" title="epoll实现原理"></a>epoll实现原理</h3><p>epoll 的源码也在 <code>fs/eventpoll.c</code> 文件中。</p><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create()"></a>epoll_create()</h4><p>系统调用宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) <span class="comment">// 此处已经遗弃 size 参数，只要 size 大于 0 即可</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要调用函数</span></span><br><span class="line">    <span class="keyword">return</span> sys_epoll_create1(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户调用 epoll_create 时，检查完 size 参数后，直接调用了 sys_epoll_create1() 函数来完成主要的工作。<br>sys_epoll_create1() 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the EPOLL_* constant for consistency.  */</span></span><br><span class="line">    <span class="comment">// 检查 EPOLL_* 常量的一致性</span></span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 为 ep 分配内存并初始化，存储在file结构的private_data成员中。</span></span><br><span class="line"><span class="comment">     * private_data成员用来存储文件描述符真正对应的对象。例如</span></span><br><span class="line"><span class="comment">     * 如果文件描述符是一个套接字的话，其对应的file实例的private_data</span></span><br><span class="line"><span class="comment">     * 成员存储的就是一个socket实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = ep_alloc(&amp;ep);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 创建eventpoll文件，这个文件的file_operations为eventpoll_fops，</span></span><br><span class="line"><span class="comment">     * 私有的数据为eventpoll实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = anon_inode_getfd(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                 flags &amp; O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        ep_free(ep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，有一个很重要的结构体 <code>eventpoll</code>，其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock; <span class="comment">// 自旋锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq; <span class="comment">// sys_epoll_wait()使用的等待队列</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll_wait; <span class="comment">// file-&gt;poll()使用的等待队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 文件描述符就绪列表，用户调用 epoll_wait 的时候，将 rdllist 中的 epitem 出列，</span></span><br><span class="line"><span class="comment">     * 将触发的事件拷贝到用户空间，之后判断 epitem 是否需要重新添加回 rdllist。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 红黑树根节点，用于存储监听的文件描述符。一个 fd 被添加（EPOLL_CTL_ADD）到 epoll 中之后，</span></span><br><span class="line"><span class="comment">     * 内核会为它生成对应的 epitem 结构对象，epitem 被添加到 rbr 中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span> <span class="comment">// 红黑树，用于存储监听的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 单链表，就绪事件拷贝到用户空间时，将所有 epitem 链接起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 epoll 的用户 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的结构体中可以看出，epoll 底层两个重要的数据结构是 <code>红黑树</code> 和 <code>单链表的就绪队列</code>，其中红黑树用于管理所有监听的 fd，就绪队列用于将产生了事件的 fd 传回给用户。</p><p>那么，创建 epoll 完成后，就需要对文件描述符进行监听、删除、修改等操作，这将会使用到 <code>epoll_ctr()</code> 函数。</p><h4 id="epoll-ctr"><a href="#epoll-ctr" class="headerlink" title="epoll_ctr()"></a>epoll_ctr()</h4><p>系统调用宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">        struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要从用户空间拷贝 event 参数，如果需要拷贝则调用 copy_from_user 来拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 epoll_create1 创建了 file 实例来存储 eventpoll 并生成了 epfd，此时通过 epfd 来获取</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要操作的文件描述符对应的 file 实例</span></span><br><span class="line">    tfile = fget(fd);</span><br><span class="line">    <span class="keyword">if</span> (!tfile)</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查对应的文件是否支持 poll</span></span><br><span class="line">    error = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 fd 对应的文件是否是一个 eventpoll 文件</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (file == tfile || !is_file_epoll(file))</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面说过，eventpoll 是存储在 private_data 当中的，所以此时取出</span></span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 eventpoll 中存储文件描述符的红黑树中查找 fd 对应的 epitem 实例</span></span><br><span class="line">    epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">        <span class="comment">// 如果要添加的 fd 不存在，则调用 ep_insert 插入到红黑树中</span></span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// 如果存在则返回 EEXIST 错误</span></span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">        <span class="comment">// 如果要删除的 fd 存在，则调用 ep_remove 从红黑树中删除</span></span><br><span class="line">        <span class="keyword">if</span> (epi)</span><br><span class="line">            error = ep_remove(ep, epi);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 如果不存在则返回 ENOENT 错误</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">        <span class="comment">// 如果要修改的 fd 存在，则调用 ep_modify 修改红黑树中对应 fd 的感兴趣的事件</span></span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">    fput(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">error_return:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll_ctl() 函数支持三种操作：添加、删除和修改，这些操作是基于存储文件描述符的红黑树上的，都是对红黑树进行相应的操作。<br>接下来我们看看最重要的函数 <code>epoll_wait()</code>。</p><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait()"></a>epoll_wait()</h4><p>系统调用宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_wait, <span class="keyword">int</span>, epfd, struct epoll_event __user *, events,</span><br><span class="line">        <span class="keyword">int</span>, maxevents, <span class="keyword">int</span>, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 maxevents 参数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证用户空间传入的 events 指向的内存是否可写</span></span><br><span class="line">    <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, events, maxevents * <span class="keyword">sizeof</span>(struct epoll_event))) &#123;</span><br><span class="line">        error = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 epoll_create 中创建的文件</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 fd 对应的文件是否是一个 eventpoll 文件</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(file))</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 private_data 中获取 eventpoll</span></span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要函数</span></span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">error_return:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll_wait 的主要工作在 ep_poll() 函数中完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res, eavail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">long</span> jtimeout;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timeout 是以毫秒为单位</span></span><br><span class="line">    jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We don&#x27;t have any available event to return to the caller.</span></span><br><span class="line"><span class="comment">         * We need to sleep here, and we will be wake up by</span></span><br><span class="line"><span class="comment">         * ep_poll_callback() when events will become available.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">        wait.flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">        <span class="comment">// 将当前进程加入到 eventpoll 的等待队列中，等待文件状态就绪或者超时或者被信号中断</span></span><br><span class="line">        __add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * We don&#x27;t want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment">             * a wakeup in between. That&#x27;s why we set the task state</span></span><br><span class="line"><span class="comment">             * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">            <span class="comment">// 如果就绪队列不为空，也就是说已经有文件的状态就绪或者超时，则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果当前进程收到信号，则退出循环，返回 EINTR</span></span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 等待 ep_poll_callback() 将当前进程唤醒或者超时，返回值是剩余的时间。</span></span><br><span class="line"><span class="comment">             * 从这里开始进程会进入睡眠状态，让出处理器，直到某些文件的状态就绪或者超时。</span></span><br><span class="line"><span class="comment">             * 当文件状态就绪时，eventpoll 的回调函数 ep_poll_callback() 会唤醒</span></span><br><span class="line"><span class="comment">             * 在 ep-&gt;wq 指向的等待队列中的进程。</span></span><br><span class="line"><span class="comment">             * （ep_poll_callback() 回调函数在 ep_insert() 时注册）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ep-&gt;ovflist 链表存储的向用户传递事件时暂存就绪的文件。</span></span><br><span class="line"><span class="comment">     * 所以不管是就绪队列 ep-&gt;rdllist 不为空，或者 ep-&gt;ovflist 不等于</span></span><br><span class="line"><span class="comment">     * EP_UNACTIVE_PTR，都有可能现在已经有文件的状态就绪。</span></span><br><span class="line"><span class="comment">     * ep-&gt;ovflist 不等于 EP_UNACTIVE_PTR 有两种情况，一种是 NULL，此时</span></span><br><span class="line"><span class="comment">     * 可能正在向用户传递事件，不一定就有文件状态就绪，</span></span><br><span class="line"><span class="comment">     * 一种情况时不为 NULL，此时可以肯定有文件状态就绪，</span></span><br><span class="line"><span class="comment">     * 参见 ep_send_events()。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    eavail = !list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果没有被信号中断，并且有事件就绪，</span></span><br><span class="line"><span class="comment">     * 但是没有获取到事件(有可能被其他进程获取到了)，</span></span><br><span class="line"><span class="comment">     * 并且没有超时，则跳转到retry标签处，重新等待</span></span><br><span class="line"><span class="comment">     * 文件状态就绪。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回获取到的事件的个数或者错误码</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ep_poll() 如果有事件发生，则调用 <code>ep_send_events()/ep_scan_ready_list()</code> 将发生的事件拷贝到用户空间中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">              struct epoll_event __user *events, <span class="keyword">int</span> maxevents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> <span class="title">esed</span>;</span></span><br><span class="line"></span><br><span class="line">    esed.maxevents = maxevents;</span><br><span class="line">    esed.events = events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*sproc)(struct eventpoll *,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">    LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="comment">     * eventpoll_release_file() and epoll_ctl().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// 将就绪队列中就绪的文件链表暂存在临时表头 txlist 中，并且初始化就绪队列。</span></span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * 将 ovflist 置为 NULL，表示此时正在向用户空间传递</span></span><br><span class="line"><span class="comment">     * 事件。如果此时有文件状态就绪，不会放在</span></span><br><span class="line"><span class="comment">     * 就绪队列中，而是放在 ovflist 链表中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ep-&gt;ovflist = <span class="literal">NULL</span>;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 sproc 指向的函数 ep_send_events_proc() 将就绪队列中的事件存入用户传入的内存中。</span></span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在调用 ep_send_events_proc() 的过程中，可能有文件状态就绪，这些事件</span></span><br><span class="line"><span class="comment">     * 会暂存在 ovflist 链表中，所以这里要将 ovflist 中的事件移到就绪队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (nepi = ep-&gt;ovflist; (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">        nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新初始化 ovflist，表示传递事件已完成</span></span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 ep_send_events_proc() 中处理出错或者某些文件的触发方式设置为 LT，</span></span><br><span class="line"><span class="comment">     * txlist 中可能还有事件，需要将这些就绪的事件重新添加到 eventpoll 的就绪度列中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对轮询等待队列执行安全唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> *<span class="title">esed</span> = <span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> eventcnt;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> revents;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">uevent</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (eventcnt = <span class="number">0</span>, uevent = esed-&gt;events;</span><br><span class="line">         !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) &#123;</span><br><span class="line">        epi = list_first_entry(head, struct epitem, rdllink);</span><br><span class="line"></span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 调用文件的poll函数有两个作用，一是在文件的唤醒</span></span><br><span class="line"><span class="comment">         * 队列上注册回调函数，二是返回文件当前的事件状</span></span><br><span class="line"><span class="comment">         * 态，如果第二个参数为NULL，则只是查看文件当前</span></span><br><span class="line"><span class="comment">         * 状态。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="literal">NULL</span>) &amp;</span><br><span class="line">            epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (revents) &#123;</span><br><span class="line">            <span class="comment">// 向用户空间内存传值，如果失败，将当前的 epitem 实例重新放回到链表中。</span></span><br><span class="line">            <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">                __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">                list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">                <span class="comment">// 如果此时已经获取了部分事件，则返回已经获取的事件个数，否则返回 EFAULT</span></span><br><span class="line">                <span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">            eventcnt++;</span><br><span class="line">            uevent++;</span><br><span class="line">            <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果是水平触发模式，需要将当前的 epitem 实例添加回链表中，</span></span><br><span class="line"><span class="comment">             * 下次读取事件时会再次上报</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line"></span><br><span class="line">                list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eventcnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面讲了 select 和 poll 的原理，接下来我们学习它们改进后的增强版本：epoll。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="net" scheme="https://blog.grizzlys.top/categories/net/"/>
    
    
    <category term="I/O多路复用" scheme="https://blog.grizzlys.top/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
    <category term="epoll" scheme="https://blog.grizzlys.top/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用 - poll</title>
    <link href="https://blog.grizzlys.top/net/net-io-multiplexing-poll/"/>
    <id>https://blog.grizzlys.top/net/net-io-multiplexing-poll/</id>
    <published>2020-09-25T02:52:36.000Z</published>
    <updated>2021-07-08T02:33:40.862Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="../net-io-multiplexing-select">《IO多路复用 - select》</a>介绍了 select。接下来我们来解析一下 poll。<br><a id="more"></a></p><h2 id="poll介绍"><a href="#poll介绍" class="headerlink" title="poll介绍"></a>poll介绍</h2><h3 id="poll相关函数"><a href="#poll相关函数" class="headerlink" title="poll相关函数"></a>poll相关函数</h3><p>通过 <code>man poll</code> 命令可以查看 poll 的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>具体参数详解：</p><ul><li>fds: 指向 pollfd 结构体数组的指针。</li><li>nfds: 表示 fds 结构体数组的长度。</li><li>timeout: 设定 poll 的超时时间，单位为毫秒，其中：<ul><li>值为 -1 ：poll 永远阻塞。</li><li>值为 0 ：poll 立即返回。</li><li>值为正数： 设定超时时间。</li></ul></li></ul><p>函数返回：</p><ul><li>返回值大于 0 ：表示poll由于监听的文件描述符就绪返回，并且返回结果就是就绪的文件描述符的个数。</li><li>返回值等于 0 ：poll 超时。</li><li>返回值小于 0 ：发生错误。</li></ul><p>pollfd 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;        <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;  <span class="comment">// 等待的事件（POLLIN/POLLOUT/POLLERR）</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">// 实际发生的事件，不需赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>events &amp; revents 取值如下：</p><div class="table-container"><table><thead><tr><th>事件</th><th>描述</th><th style="text-align:center">是否可作为输入(events)</th><th style="text-align:center">是否可作为输出(revents)</th></tr></thead><tbody><tr><td>POLLIN</td><td>数据可读（包括普通数据&amp;优先数据）</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>POLLOUT</td><td>数据可写（普通数据&amp;优先数据）</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>POLLRDNORM</td><td>普通数据可读</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>POLLRDBAND</td><td>优先级带数据可读（linux不支持）</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>POLLPRI</td><td>高优先级数据可读，比如TCP带外数据</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>POLLWRNORM</td><td>普通数据可写</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>POLLWRBAND</td><td>优先级带数据可写</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>POLLRDHUP</td><td>TCP连接被对端关闭，或者关闭了写操作，由GNU引入</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>POPPHUP</td><td>挂起</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td>POLLERR</td><td>错误</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td>POLLNVAL</td><td>文件描述符没有打开</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr></tbody></table></div><p><strong>注意：</strong><br>pollfd 结构体中的 events 由用户来设置，告诉内核我们关注的事件，而 revents 是返回时内核设置的，以说明文件描述符发生了什么事件。</p><h3 id="poll使用"><a href="#poll使用" class="headerlink" title="poll使用"></a>poll使用</h3><p>使用流程图如下：<br><img src="https://i.loli.net/2020/10/29/kMKpA9uj2yLmcvi.png" alt="poll.png"></p><p>实现简单的服务代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 10240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> server_sockfd, client_sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> client_len = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">clients</span>[<span class="title">CLIENT_SIZE</span>];</span></span><br><span class="line">    <span class="keyword">int</span> conn_count = <span class="number">0</span>; <span class="comment">// 当前客户端连接数</span></span><br><span class="line"></span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立服务器端socket</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_address.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    bind(server_sockfd, (struct sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>); <span class="comment">//监听队列最多容纳5个</span></span><br><span class="line"></span><br><span class="line">    clients[<span class="number">0</span>].fd = server_sockfd;</span><br><span class="line">    clients[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有客户端</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; CLIENT_SIZE; ++i) &#123;</span><br><span class="line">        clients[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server start\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ret = poll(clients, conn_count + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; conn_count + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 客户端关闭或者其他错误</span></span><br><span class="line">            <span class="keyword">if</span> ((clients[i].revents &amp; POLLRDHUP) || (clients[i].revents &amp; POLLERR)) &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = clients[i].fd;</span><br><span class="line">                clients[i] = clients[conn_count];</span><br><span class="line">                --i;</span><br><span class="line">                --conn_count;</span><br><span class="line">                close(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新的客户端连接</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((clients[i].fd == server_sockfd) &amp;&amp; (clients[i].revents &amp; POLLIN)) &#123;</span><br><span class="line">                client_len = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                <span class="comment">// 接受新的客户端连接</span></span><br><span class="line">                client_sockfd = accept(server_sockfd, (struct sockaddr *)&amp;client_address, (<span class="keyword">socklen_t</span> *)&amp;client_len);</span><br><span class="line">                <span class="keyword">if</span> (client_sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++conn_count;</span><br><span class="line">                clients[conn_count].fd = client_sockfd;</span><br><span class="line">                clients[conn_count].events = POLLIN | POLLERR;</span><br><span class="line">                clients[conn_count].revents = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有可读数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (clients[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> len = recv(clients[i].fd, buf, BUF_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client %d exit\n&quot;</span>, clients[i].fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;recv: %d\n&quot;</span>, errno);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll实现原理"><a href="#poll实现原理" class="headerlink" title="poll实现原理"></a>poll实现原理</h3><p>poll 的源码也在 <code>fs/select.c</code> 文件中。<br>poll() 的系统调用宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds,</span><br><span class="line">        <span class="keyword">long</span>, timeout_msecs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        <span class="comment">// 设定超时时间</span></span><br><span class="line">        poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,</span><br><span class="line">            NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要函数</span></span><br><span class="line">    ret = do_sys_poll(ufds, nfds, to);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == -EINTR) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart_block</span>;</span></span><br><span class="line"></span><br><span class="line">        restart_block = &amp;current_thread_info()-&gt;restart_block;</span><br><span class="line">        restart_block-&gt;fn = do_restart_poll;</span><br><span class="line">        restart_block-&gt;poll.ufds = ufds;</span><br><span class="line">        restart_block-&gt;poll.nfds = nfds;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            restart_block-&gt;poll.tv_sec = end_time.tv_sec;</span><br><span class="line">            restart_block-&gt;poll.tv_nsec = end_time.tv_nsec;</span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ret = -ERESTART_RESTARTBLOCK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要处理函数在 do_sys_poll() 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sys_poll</span><span class="params">(struct pollfd __user *ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err = -EFAULT, fdcount, len, size;</span><br><span class="line">    <span class="comment">/* Allocate small arguments on the stack to save memory and be</span></span><br><span class="line"><span class="comment">       faster - use long to make sure the buffer is aligned properly</span></span><br><span class="line"><span class="comment">       on 64 bit archs to avoid unaligned access */</span></span><br><span class="line">    <span class="comment">/* 为了加快处理速度和提高系统性能，这里优先定义好一个大小为POLL_STACK_ALLOC的栈空间，</span></span><br><span class="line"><span class="comment">       该栈空间转换为poll_list结构体，以存储需要被检测的socket描述符 */</span></span><br><span class="line">    <span class="keyword">long</span> stack_pps[POLL_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">const</span> <span class="title">head</span> = (<span class="title">struct</span> <span class="title">poll_list</span> *)<span class="title">stack_pps</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> todo = nfds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nfds &gt; current-&gt;signal-&gt;rlim[RLIMIT_NOFILE].rlim_cur)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过计算得到前面分配的栈空间能存储多少个pollfd结构</span></span><br><span class="line">    len = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds, N_STACK_PPS);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        walk-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        walk-&gt;len = len;</span><br><span class="line">        <span class="keyword">if</span> (!len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从用户态空间复制len个pollfd拷贝到内核空间中</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct pollfd) * walk-&gt;len))</span><br><span class="line">            <span class="keyword">goto</span> out_fds;</span><br><span class="line"></span><br><span class="line">        todo -= walk-&gt;len;</span><br><span class="line">        <span class="keyword">if</span> (!todo)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* POLLFD_PER_PAGE表示一页能存储多少个pollfd，可以计算出来，一页是4K，</span></span><br><span class="line"><span class="comment">           而pollfd的大小为8个字节，也就是一页能存储512个pollfd。</span></span><br><span class="line"><span class="comment">           如果在分配一页内存之后，还不够nfds使用，则继续下一个循环进行分配 */</span></span><br><span class="line">        len = min(todo, POLLFD_PER_PAGE);</span><br><span class="line">        size = <span class="keyword">sizeof</span>(struct poll_list) + <span class="keyword">sizeof</span>(struct pollfd) * len;</span><br><span class="line">        walk = walk-&gt;next = kmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!walk) &#123;</span><br><span class="line">            err = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> out_fds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    <span class="comment">// 最重要的处理部分</span></span><br><span class="line">    fdcount = do_poll(nfds, head, &amp;table, end_time);</span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表上的所有pollfd中revents状态写入到用户空间</span></span><br><span class="line">    <span class="keyword">for</span> (walk = head; walk; walk = walk-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">fds</span> = <span class="title">walk</span>-&gt;<span class="title">entries</span>;</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; walk-&gt;len; j++, ufds++)</span><br><span class="line">            <span class="keyword">if</span> (__put_user(fds[j].revents, &amp;ufds-&gt;revents))</span><br><span class="line">                <span class="keyword">goto</span> out_fds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = fdcount;</span><br><span class="line">out_fds:</span><br><span class="line">    <span class="comment">// 之前调用kmalloc分配的内存现在进行释放</span></span><br><span class="line">    walk = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (walk) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">pos</span> = <span class="title">walk</span>;</span></span><br><span class="line">        walk = walk-&gt;next;</span><br><span class="line">        kfree(pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是重中之重的 do_poll() 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_poll</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,  struct poll_list *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">           struct poll_wqueues *wait, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poll_table* pt = &amp;wait-&gt;pt;</span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> timed_out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimise the no-wait case */</span></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        pt = <span class="literal">NULL</span>;</span><br><span class="line">        timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">        slack = estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对所有的struct pollfd循环，以调用do_pollfd函数。</span></span><br><span class="line">        <span class="keyword">for</span> (walk = <span class="built_in">list</span>; walk != <span class="literal">NULL</span>; walk = walk-&gt;next) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> * <span class="title">pfd</span>, * <span class="title">pfd_end</span>;</span></span><br><span class="line"></span><br><span class="line">            pfd = walk-&gt;entries;</span><br><span class="line">            pfd_end = pfd + walk-&gt;len;</span><br><span class="line">            <span class="keyword">for</span> (; pfd != pfd_end; pfd++) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Fish for events. If we found one, record it</span></span><br><span class="line"><span class="comment">                 * and kill the poll_table, so we don&#x27;t</span></span><br><span class="line"><span class="comment">                 * needlessly register any other waiters after</span></span><br><span class="line"><span class="comment">                 * this. They&#x27;ll get immediately deregistered</span></span><br><span class="line"><span class="comment">                 * when we break out and return.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 调用 do_pollfd() 以检查socket文件描述符的状态变化，如果有变化，则count加1</span></span><br><span class="line">                <span class="keyword">if</span> (do_pollfd(pfd, pt)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    pt = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * All waiters have already been registered, so don&#x27;t provide</span></span><br><span class="line"><span class="comment">         * a poll_table to them on the next loop iteration.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pt = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">            count = wait-&gt;error;</span><br><span class="line">            <span class="comment">/* 检查是否有需要处理的信号，这里的意思是就算是poll调用进入到sys_poll系统调用之后，</span></span><br><span class="line"><span class="comment">             * 也可以接收外部信号，从而退出当前系统调用（因为我们知道一般的系统调用都不会被中断的，</span></span><br><span class="line"><span class="comment">             * 所以系统调用一般都尽量很快的返回）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">                count = -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for循环退出的条件：如果有文件描述符发生变化，则退出，或者超时退出</span></span><br><span class="line">        <span class="keyword">if</span> (count || timed_out)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">         * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">         * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇&lt;a href=&quot;../net-io-multiplexing-select&quot;&gt;《IO多路复用 - select》&lt;/a&gt;介绍了 select。接下来我们来解析一下 poll。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="net" scheme="https://blog.grizzlys.top/categories/net/"/>
    
    
    <category term="I/O多路复用" scheme="https://blog.grizzlys.top/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
    <category term="poll" scheme="https://blog.grizzlys.top/tags/poll/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用 - select</title>
    <link href="https://blog.grizzlys.top/net/net-io-multiplexing-select/"/>
    <id>https://blog.grizzlys.top/net/net-io-multiplexing-select/</id>
    <published>2020-09-24T02:52:36.000Z</published>
    <updated>2021-07-08T02:33:40.863Z</updated>
    
    <content type="html"><![CDATA[<p>在服务器的编程中经常会需要构造高性能的 I/O 模型，最常用的就是多路复用 I/O 模型。<br>多路复用的本质是同步非阻塞 I/O，多路复用的优势并不是单个连接处理的更快，而是在于能处理更多的链接。<br><a id="more"></a><br>在服务端的网络 I/O 编程过程中，需要同时处理多个客户端的数据时，可以利用多线程或者 I/O 多路复用技术进行处理。<br>在<a href="../net-io-model">《I/O模型浅析》</a>中已经简单介绍过多路复用I/O，接下来介绍 select、poll 和 epoll。<br>这三者的源码在 Linux kernel 源码中，想要查看源码需要下载，两种下载方式：</p><ol><li>官方链接： <a href="https://www.kernel.org/">https://www.kernel.org/</a></li><li>如果不能科学上网，下载速度将会很慢，可以使用上海交大的源下载：<br><a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/">http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/</a></li></ol><p><img src="https://i.loli.net/2020/10/29/PFJYs8yI6VMlaBv.png" alt="kernel.png"><br>因为我使用的系统是 <code>CentOS release 6.8 (Final)</code>，其中 linux 内核版本为 <code>2.6.32</code>，所以我下载了 <code>linux-2.6.32.9.tar.gz</code>。<br>其它版本可自行选择下载。</p><hr><h2 id="select介绍"><a href="#select介绍" class="headerlink" title="select介绍"></a>select介绍</h2><h3 id="select相关函数"><a href="#select相关函数" class="headerlink" title="select相关函数"></a>select相关函数</h3><p>通过 <code>man select</code> 命令可以查看 select 的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要包含的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>具体参数详解：</p><ul><li>nfds: 整数值，指集合中所有文件描述符的范围，即所有文件描述符的最大值加1。</li><li>readfds: 指向 fd_set 结构的指针，文件描述符集合，检查该组文件描述符的可读性。</li><li>writefds: 指向 fd_set 结构的指针，文件描述符集合，检查该组文件描述符的可写性。</li><li>exceptfds: 指向 fd_set 结构的指针，文件描述符集合，检查该组文件描述符的异常条件。</li><li>timeout: 设定 select 的超时时间，其中：<ul><li>值为NULL，则将 select() 设置为阻塞状态，当监视的文件描述符集合中的某一个描述符发生变化才会返回结果并向下执行。</li><li>值等于0，则将 select() 置为非阻塞状态，执行 select() 后立即返回，无论文件描述符是否发生变化。</li><li>值大于0，则将select()函数的超时时间设为这个值，在超时时间内阻塞，超时后返回结果。</li></ul></li></ul><p>函数返回：</p><ul><li>正数：表示发生变化的文件描述符数量。</li><li>0：select 超时。</li><li>-1：发生错误，将所有文件描述符集合清0，并通过 errno 输出错误详情。</li></ul><p>以下是与 select() 函数相关的几个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//一个 fd_set类型变量的所有位都设为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">//清除某个位时可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//设置变量的某个位置位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">//测试某个位是否被置位</span></span><br></pre></td></tr></table></figure><h3 id="select使用"><a href="#select使用" class="headerlink" title="select使用"></a>select使用</h3><p>使用流程图如下：<br><img src="https://i.loli.net/2020/10/29/7RFfJjZzT3sKSWh.png" alt="select.png"></p><p>实现简单的服务代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_sockfd, client_sockfd;</span><br><span class="line">    <span class="keyword">int</span> server_len, client_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    fd_set readfds, testfds;</span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立服务器端socket</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_address.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    server_len = <span class="keyword">sizeof</span>(server_address);</span><br><span class="line">    bind(server_sockfd, (struct sockaddr *)&amp;server_address, server_len);</span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>); <span class="comment">//监听队列最多容纳5个</span></span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_SET(server_sockfd, &amp;readfds);<span class="comment">//将服务器端socket加入到集合中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">int</span> nread;</span><br><span class="line">        testfds = readfds;<span class="comment">//将需要监视的描述符集copy到select查询队列中，select会对其修改，所以一定要分开使用变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server waiting\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*无限期阻塞，并测试文件描述符变动 */</span></span><br><span class="line">        result = select(FD_SETSIZE, &amp;testfds, (fd_set *)<span class="number">0</span>,(fd_set *)<span class="number">0</span>, (struct timeval *) <span class="number">0</span>); <span class="comment">//FD_SETSIZE：系统默认的最大文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(result &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;server5&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*扫描所有的文件描述符*/</span></span><br><span class="line">        <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; FD_SETSIZE; fd++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*找到相关文件描述符*/</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(fd,&amp;testfds))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*判断是否为服务器套接字，是则表示为客户请求连接。*/</span></span><br><span class="line">                <span class="keyword">if</span>(fd == server_sockfd)</span><br><span class="line">                &#123;</span><br><span class="line">                    client_len = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                    client_sockfd = accept(server_sockfd, (struct sockaddr *)&amp;client_address, (<span class="keyword">socklen_t</span> *)&amp;client_len);</span><br><span class="line">                    FD_SET(client_sockfd, &amp;readfds);<span class="comment">//将客户端socket加入到集合中</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;adding client on fd %d\n&quot;</span>, client_sockfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*客户端socket中有数据请求时*/</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ioctl(fd, FIONREAD, &amp;nread);<span class="comment">//取得数据量交给nread</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*客户数据请求完毕，关闭套接字，从集合中清除相应描述符 */</span></span><br><span class="line">                    <span class="keyword">if</span>(nread == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        close(fd);</span><br><span class="line">                        FD_CLR(fd, &amp;readfds); <span class="comment">//去掉关闭的fd</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;removing client on fd %d\n&quot;</span>, fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*处理客户数据请求*/</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        read(fd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">                        sleep(<span class="number">5</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;serving client on fd %d\n&quot;</span>, fd);</span><br><span class="line">                        ch++;</span><br><span class="line">                        write(fd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select实现原理"><a href="#select实现原理" class="headerlink" title="select实现原理"></a>select实现原理</h3><p>select 的源码在 <code>fs/select.c</code> 文件中。<br>Linux 中的系统函数调用入口都是由宏 <code>SYSCALL_DEFINEx</code> 定义的，其中 <code>x</code> 为函数参数个数。在 <code>select.c</code> 中可以找到 select() 的系统调用宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">        fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否设置超时时间</span></span><br><span class="line">    <span class="keyword">if</span> (tvp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv))) <span class="comment">// 从用户空间拷贝数据到内核空间</span></span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        <span class="keyword">if</span> (poll_select_set_timeout(to,</span><br><span class="line">                tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</span><br><span class="line">                (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to); <span class="comment">// 主要函数</span></span><br><span class="line">    ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret); <span class="comment">// 如果有超时值, 并拷贝离超时时刻还剩的时间到用户空间的timeval中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要处理函数在 core_sys_select() 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">               fd_set __user *<span class="built_in">exp</span>, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set_bits fds; <span class="comment">// fd_set_bits结构体中定义的全是指针，这些指针是用来指向描述符集合的</span></span><br><span class="line">    <span class="keyword">void</span> *bits;</span><br><span class="line">    <span class="keyword">int</span> ret, max_fds;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="comment">/* Allocate small arguments on the stack to save memory and be faster */</span></span><br><span class="line">    <span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    fdt = files_fdtable(current-&gt;files); <span class="comment">// 获取当前进程的文件描述符表</span></span><br><span class="line">    max_fds = fdt-&gt;max_fds;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; max_fds) <span class="comment">// 如果传入的n大于当前进程最大的文件描述符，给予修正</span></span><br><span class="line">        n = max_fds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span></span><br><span class="line"><span class="comment">     * since we used fdset we need to allocate memory in units of</span></span><br><span class="line"><span class="comment">     * long-words.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    size = FDS_BYTES(n);</span><br><span class="line">    <span class="comment">// 以一个文件描述符占一bit来计算，传递进来的这些fd_set需要用掉多少个字</span></span><br><span class="line">    bits = stack_fds;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="comment">// 除6，为什么？因为每个文件描述符需要6个bitmaps</span></span><br><span class="line">        <span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL); <span class="comment">// stack中分配的太小，直接kmalloc</span></span><br><span class="line">        <span class="keyword">if</span> (!bits)</span><br><span class="line">            <span class="keyword">goto</span> out_nofds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里就可以明显看出struct fd_set_bits结构体的用处了。</span></span><br><span class="line">    fds.in      = bits;</span><br><span class="line">    fds.out     = bits +   size;</span><br><span class="line">    fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">    fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">    fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">    fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get_fd_set仅仅调用copy_from_user从用户空间拷贝了fd_se</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">        (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">        (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    zero_fd_set(n, fds.res_in); <span class="comment">// 对这些存放返回状态的字段清0</span></span><br><span class="line">    zero_fd_set(n, fds.res_out);</span><br><span class="line">    zero_fd_set(n, fds.res_ex);</span><br><span class="line"></span><br><span class="line">    ret = do_select(n, &amp;fds, end_time); <span class="comment">// 关键函数，完成主要的工作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="comment">// 有错误</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123; <span class="comment">// 超时返回，无设备就绪</span></span><br><span class="line">        ret = -ERESTARTNOHAND;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把结果集,拷贝回用户空间</span></span><br><span class="line">    <span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">        set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">        set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">        kfree(bits); <span class="comment">// 如果有申请空间，那么释放fds对应的空间</span></span><br><span class="line">out_nofds:</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是主角 <code>do_select()</code> 登场：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    poll_table *wait;</span><br><span class="line">    <span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">// 根据已经设置好的fd bitmap检查用户打开的fd, 要求对应fd必须打开, 并且返回最大的fd</span></span><br><span class="line">    retval = max_select_fd(n, fds);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    n = retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些重要的初始化:</span></span><br><span class="line">    <span class="comment">// poll_wqueues.poll_table.qproc函数指针初始化，该函数是驱动程序中poll函数实现中必须要调用的poll_wait()中使用的函数</span></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    wait = &amp;table.pt;</span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        wait = <span class="literal">NULL</span>;</span><br><span class="line">        timed_out = <span class="number">1</span>;  <span class="comment">// 如果系统调用带进来的超时时间为0，那么设置timed_out = 1，表示不阻塞，直接返回。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">        slack = estimate_accuracy(end_time); <span class="comment">// 超时时间转换</span></span><br><span class="line"></span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">        inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有n个fd的循环</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先取出当前循环周期中的32个文件描述符对应的bitmaps</span></span><br><span class="line">            in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">            all_bits = in | out | ex;  <span class="comment">// 组合一下，有的fd可能只监测读，或者写，或者err，或者同时都监测</span></span><br><span class="line">            <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123; <span class="comment">// 这32个描述符没有任何状态被监测，就跳入下一个32个fd的循环中</span></span><br><span class="line">                i += __NFDBITS; <span class="comment">//每32个文件描述符一个循环，正好一个long型数</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本次32个fd的循环中有需要监测的状态存在</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123; <span class="comment">// 初始bit = 1</span></span><br><span class="line">                <span class="keyword">int</span> fput_needed;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n) <span class="comment">// i用来检测是否超出了最大待监测的fd</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// bit每次循环后左移一位的作用在这里，用来跳过没有状态监测的fd</span></span><br><span class="line">                file = fget_light(i, &amp;fput_needed); <span class="comment">// 得到file结构指针，并增加引用计数字段f_count</span></span><br><span class="line">                <span class="keyword">if</span> (file) &#123; <span class="comment">// 如果file存在</span></span><br><span class="line">                    f_op = file-&gt;f_op;</span><br><span class="line">                    mask = DEFAULT_POLLMASK;</span><br><span class="line">                    <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;</span><br><span class="line">                        wait_key_set(wait, in, out, bit); <span class="comment">// 设置当前fd待监测的事件掩码</span></span><br><span class="line">                        mask = (*f_op-&gt;poll)(file, wait);</span><br><span class="line">                         <span class="comment">/* 调用驱动程序中的poll函数，以evdev驱动中的evdev_poll()为例该函数会调用函数poll_wait(file, &amp;evdev-&gt;wait, wait)，</span></span><br><span class="line"><span class="comment">                         继续调用__pollwait()回调来分配一个poll_table_entry结构体，该结构体有一个内嵌的等待队列项，</span></span><br><span class="line"><span class="comment">                         设置好wake时调用的回调函数后将其添加到驱动程序中的等待队列头中。*/</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    fput_light(file, fput_needed);</span><br><span class="line">                    <span class="comment">// 释放file结构指针，实际就是减小他的一个引用计数字段f_count。</span></span><br><span class="line">                    <span class="comment">// mask是每一个fop-&gt;poll()程序返回的设备状态掩码。</span></span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">                        res_in |= bit; <span class="comment">// fd对应的设备可读</span></span><br><span class="line">                        retval++;</span><br><span class="line">                        wait = <span class="literal">NULL</span>; <span class="comment">// 后续有用，避免重复执行__pollwait()</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">                        res_out |= bit; <span class="comment">// fd对应的设备可写</span></span><br><span class="line">                        retval++;</span><br><span class="line">                        wait = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">                        res_ex |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据poll的结果写回到输出位图里,返回给上级函数</span></span><br><span class="line">            <span class="keyword">if</span> (res_in)</span><br><span class="line">                *rinp = res_in;</span><br><span class="line">            <span class="keyword">if</span> (res_out)</span><br><span class="line">                *routp = res_out;</span><br><span class="line">            <span class="keyword">if</span> (res_ex)</span><br><span class="line">                *rexp = res_ex;</span><br><span class="line">             <span class="comment">// 这里的目的纯粹是为了增加一个抢占点。在支持抢占式调度的内核中（定义了CONFIG_PREEMPT），cond_resched是空操作。</span></span><br><span class="line">            cond_resched();</span><br><span class="line">        &#125;</span><br><span class="line">        wait = <span class="literal">NULL</span>; <span class="comment">// 后续有用，避免重复执行__pollwait()</span></span><br><span class="line">        <span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (table.error) &#123;</span><br><span class="line">            retval = table.error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳出这个大循环的条件有: 有设备就绪或有异常(retval!=0), 超时(timed_out = 1), 或者有中止信号出现</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">         * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">         * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次循环中，当前用户进程从这里进入休眠，上面传下来的超时时间只是为了用在睡眠超时这里而已超时，poll_schedule_timeout()返回0；被唤醒时返回-EINTR</span></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">                       to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>; <span class="comment">/* 超时后，将其设置成1，方便后面退出循环返回到上层 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理各个驱动程序的等待队列头，同时释放掉所有空出来的page页(poll_table_entry)</span></span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval; <span class="comment">// 返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select 使用 bitmap 的方式来传递文件描述符集合，所以就会有最大长度限制，在 Linux 平台下 select 限制文件描述符只能有 <code>1024</code> 个，如果需要超过 1024，就需要修改内核代码并重新编译。<br>select 使用 bitmap 的方式来回传就绪的文件描述符集合，调用者需要循环遍历每一个位判断是否就绪。当文件描述符很多，但是空闲的文件描述符大大多于就绪的文件描述符的时候，效率就很低了，所以一般不建议修改文件描述符的限制数量。<br>在 <code>include/linux/posix_types.h</code> 中可以看到宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __FD_SETSIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE    1024</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在服务器的编程中经常会需要构造高性能的 I/O 模型，最常用的就是多路复用 I/O 模型。&lt;br&gt;多路复用的本质是同步非阻塞 I/O，多路复用的优势并不是单个连接处理的更快，而是在于能处理更多的链接。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="net" scheme="https://blog.grizzlys.top/categories/net/"/>
    
    
    <category term="I/O多路复用" scheme="https://blog.grizzlys.top/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
    <category term="select" scheme="https://blog.grizzlys.top/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 vim个人配置</title>
    <link href="https://blog.grizzlys.top/vim/vim-configuration/"/>
    <id>https://blog.grizzlys.top/vim/vim-configuration/</id>
    <published>2020-09-22T08:54:00.000Z</published>
    <updated>2021-07-08T02:33:40.880Z</updated>
    
    <content type="html"><![CDATA[<p>因为最终想要安装YCM插件，而最新的YCM插件只支持 python3.6 和 vim8.1 以上的版本，所以需要更新系统自带的 python 和 vim（如果以安装最新的环境，则可忽略）。<br><a id="more"></a></p><p>全文最底下添加了vimrc配置的信息可自行下载。</p><h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><p>安装相关编译环境：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make</span><br></pre></td></tr></table></figure><p>下载 python 安装包，此处我下载的是 3.7.4 版本的 python，可自行选择最新的版本下载安装：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/download</span><br><span class="line">cd ~/download</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxzf Python-3.7.4.tgz</span><br></pre></td></tr></table></figure><p>编译安装：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.7.4</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/python3 --with-ssl --enable-shared --enable-optimizations</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>此处的添加 —enable-shared 参数是因为YCM插件需要。<br>安装完毕后，添加软链接：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line">ln -sf /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>执行命令验证 python 版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br><span class="line">Python 2.7.12</span><br><span class="line"></span><br><span class="line">python3 --version</span><br><span class="line">Python 3.7.4</span><br></pre></td></tr></table></figure><hr><h2 id="安装vim8"><a href="#安装vim8" class="headerlink" title="安装vim8"></a>安装vim8</h2><p>下载vim：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/download</span><br><span class="line">git clone https://github.com/vim/vim.git</span><br></pre></td></tr></table></figure><p>编译安装支持 python3 的 vim8：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd vim</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--with-features=huge \</span><br><span class="line">--enable-multibyte \</span><br><span class="line">--enable-rubyinterp=yes \</span><br><span class="line">--enable-python3interp=yes \</span><br><span class="line">--with-python-config-dir=/usr/local/python3/lib/python3.7/config-3.7m-x86_64-linux-gnu \</span><br><span class="line">--enable-perlinterp=yes \</span><br><span class="line">--enable-luainterp=yes \</span><br><span class="line">--enable-gui=gtk2 \</span><br><span class="line">--enable-cscope \</span><br><span class="line">--prefix=/usr/local/vim8</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完毕后，添加软链接：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/local/vim8/bin/vim /usr/bin/vim # 覆盖旧版本的vim</span><br></pre></td></tr></table></figure><p>验证vim：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --version</span><br></pre></td></tr></table></figure><p>查看结果：<br><img src="/vim/vim-configuration/vim-version.png" alt="vim-version"></p><p>如果红框中 python3 前面显示 <code>+</code> ，则表示 vim 成功支持 python3。<br>至此以安装完毕python3 + vim8。<br>接下来对 vim 进行相关配置。</p><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><h3 id="vim基础配置"><a href="#vim基础配置" class="headerlink" title="vim基础配置"></a>vim基础配置</h3><p>首先对 vim 进行一个基础配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">set number          &quot; 显示行号</span><br><span class="line">syntax on           &quot; 语法高亮</span><br><span class="line">set showcmd         &quot; 输入的命令显示出来，看的清楚些</span><br><span class="line">set cursorline      &quot; 当前行显示</span><br><span class="line">set autoindent      &quot; 自动缩进</span><br><span class="line">set cindent</span><br><span class="line">set tabstop=4       &quot; tab缩进4个空格</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set expandtab</span><br><span class="line">set incsearch       &quot; 开启实时搜索功能</span><br><span class="line">set ignorecase      &quot; 搜索时大小写不敏感</span><br><span class="line">set hlsearch        &quot; 高亮显示搜索结果</span><br><span class="line">set foldenable      &quot; 允许折叠</span><br><span class="line">set foldmethod=manual   &quot; 手动折叠</span><br><span class="line">set nocompatible    &quot; 去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限</span><br><span class="line">set clipboard+=unnamed  &quot; 共享剪贴板</span><br><span class="line">set autowrite       &quot; 自动保存</span><br><span class="line">set confirm         &quot; 在处理未保存或只读文件的时候，弹出确认</span><br><span class="line">set ruler           &quot; 打开状态栏标尺</span><br><span class="line">set langmenu=zh_CN.UTF-8    &quot; 语言设置</span><br><span class="line">set helplang=cn</span><br><span class="line">set laststatus=2    &quot; 总是显示状态行</span><br><span class="line">set linespace=0     &quot; 字符间插入的像素行数目</span><br><span class="line">set backspace=2     &quot; 使回格键（backspace）正常处理indent, eol, start等</span><br><span class="line">set showmatch       &quot; 高亮显示匹配的括号</span><br><span class="line">set scrolloff=3     &quot; 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line">set completeopt=menu</span><br><span class="line">&quot; 相关颜色替换</span><br><span class="line">hi Search term=standout cterm=bold ctermfg=7 ctermbg=1</span><br><span class="line">hi SpellBad term=reverse ctermfg=15 ctermbg=9 guifg=White guibg=Red</span><br><span class="line">let mapleader=&#x27;,&#x27;</span><br></pre></td></tr></table></figure><h3 id="vim插件安装"><a href="#vim插件安装" class="headerlink" title="vim插件安装"></a>vim插件安装</h3><h4 id="安装vim插件管理器-vim-plug"><a href="#安装vim插件管理器-vim-plug" class="headerlink" title="安装vim插件管理器(vim-plug)"></a>安装vim插件管理器(vim-plug)</h4><p>因为需要安装的 vim 插件很多，所以需要有一个管理工具来对这些插件进行统一管理。目前主流使用的是 <a href="https://github.com/junegunn/vim-plug">vim-plug</a> 插件管理器，该插件能够异步并行进行快速安装、更新和卸载插件。</p><p>下载 plug.vim 文件到 <code>~/.vim/autoload/</code> 文件夹中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>执行命令的时候，发现 raw.githubusercontent.com 地址可能访问不了，需要配置 hosts 才能进行访问，配置的方法网上很多，可自行查询解决。<br>下载完成后，在 vim 的配置文件( <code>~/.vimrc</code> )中添加以下代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot; Specify a directory for plugins</span><br><span class="line">&quot; - For Neovim: stdpath(&#x27;data&#x27;) . &#x27;/plugged&#x27;</span><br><span class="line">&quot; - Avoid using standard Vim directory names like &#x27;plugin&#x27;</span><br><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line">&quot; 以下添加需要安装的插件</span><br><span class="line">&quot; 可在github上查找需要安装的插件，以 Plug &#x27;xxx/xxx&#x27; 的形式来添加，如下：</span><br><span class="line"></span><br><span class="line">&quot; YCM插件</span><br><span class="line">Plug &#x27;Valloric/YouCompleteMe&#x27;</span><br><span class="line"></span><br><span class="line">&quot; Initialize plugin system</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><p>配置完成后，打开vim，输入<code>:PlugInstall</code>进行安装。</p><p>vim-plug操作命令：</p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>PlugInstall [name …] [#threads]</td><td>安装插件</td></tr><tr><td>PlugUpdate [name …] [#threads]</td><td>更新插件</td></tr><tr><td>PlugClean[!]</td><td>卸载插件</td></tr><tr><td>PlugUpgrade</td><td>更新vim-plug</td></tr><tr><td>PlugStatus</td><td>查看插件状态</td></tr><tr><td>PlugDiff</td><td>审查插件</td></tr><tr><td>PlugSnapshot[!] [output path]</td><td>生成用于恢复插件当前快照的脚本</td></tr></tbody></table></div><p>下面安装vim实用的插件。</p><hr><h4 id="NERDTree文件树目录"><a href="#NERDTree文件树目录" class="headerlink" title="NERDTree文件树目录"></a>NERDTree文件树目录</h4><p><a href="https://github.com/preservim/nerdtree">NERDTree</a>是一款可以提供树形目录的插件，方便浏览目录结构和进行文件跳转等。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;preservim/nerdtree&#x27;</span><br></pre></td></tr></table></figure><p>相关配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot; nerdtree</span><br><span class="line">autocmd vimenter * NERDTree  &quot;自动开启Nerdtree</span><br><span class="line">&quot; 关闭所有文本窗口时自动退出vim,否则需要两次退出才可</span><br><span class="line">autocmd BufEnter * if 0 == len(filter(range(1, winnr(&#x27;$&#x27;)), &#x27;empty(getbufvar(winbufnr(v:val), &quot;&amp;bt&quot;))&#x27;)) | qa! | endif</span><br><span class="line">let NERDTreeShowHidden=1    &quot; 是否显示隐藏文件</span><br><span class="line">let NERDTreeIgnore=[&#x27;\.pyc&#x27;,&#x27;\~$&#x27;,&#x27;\.swp&#x27;]  &quot; 忽略文件的显示</span><br><span class="line"></span><br><span class="line">&quot; 设置NerdTree 按f2打开或关闭NERDTree</span><br><span class="line">map &lt;F2&gt; :NERDTreeMirror&lt;CR&gt;</span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure><h4 id="nerdtree-git-plugin目录树git文件状态"><a href="#nerdtree-git-plugin目录树git文件状态" class="headerlink" title="nerdtree-git-plugin目录树git文件状态"></a>nerdtree-git-plugin目录树git文件状态</h4><p><a href="https://github.com/Xuyuanp/nerdtree-git-plugin">nerdtree-git-plugin</a>能显示git管理的项目文件的变更状态。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;Xuyuanp/nerdtree-git-plugin&#x27;</span><br></pre></td></tr></table></figure><p>相关配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let g:NERDTreeIndicatorMapCustom = &#123;</span><br><span class="line">            \ &quot;Modified&quot;  : &quot;✹&quot;,</span><br><span class="line">            \ &quot;Staged&quot;    : &quot;✚&quot;,</span><br><span class="line">            \ &quot;Untracked&quot; : &quot;✭&quot;,</span><br><span class="line">            \ &quot;Renamed&quot;   : &quot;➜&quot;,</span><br><span class="line">            \ &quot;Unmerged&quot;  : &quot;═&quot;,</span><br><span class="line">            \ &quot;Deleted&quot;   : &quot;✖&quot;,</span><br><span class="line">            \ &quot;Dirty&quot;     : &quot;✗&quot;,</span><br><span class="line">            \ &quot;Clean&quot;     : &quot;✔︎&quot;,</span><br><span class="line">            \ &#x27;Ignored&#x27;   : &#x27;☒&#x27;,</span><br><span class="line">            \ &quot;Unknown&quot;   : &quot;?&quot;</span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><h4 id="tagbar函数列表"><a href="#tagbar函数列表" class="headerlink" title="tagbar函数列表"></a>tagbar函数列表</h4><p><a href="https://github.com/preservim/tagbar">tagbar</a>能显示出所写代码的函数、变量、类等等。<br>安装 taglist 之前，需要先安装 ctags。<br>ctags 的功能：扫描指定的源文件，找出其中所包含的语法元素，并将找到的相关内容记录下来。<br>安装ctags：</p><blockquote><p>到 <a href="http://ctags.sourceforge.net/">http://ctags.sourceforge.net/</a> 下载最新的ctags源码(当前最新版本为 ctags-5.8.tar.gz)<br>解压并安装：<br>tar vxzf ctags-5.8.tar.gz<br>cd ctags-5.8<br>./configure &amp;&amp; make &amp;&amp; make install</p></blockquote><p>ctags的使用方法可以自行百度查询。</p><p>接下来安装tagbar：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;preservim/tagbar&#x27;</span><br></pre></td></tr></table></figure><p>相关配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot; [tagbar]</span><br><span class="line">&quot; 设置tagbar使用的ctags的插件,必须要设置对</span><br><span class="line">let g:tagbar_ctags_bin=&#x27;/usr/bin/ctags&#x27;</span><br><span class="line">&quot; 设置tagbar的窗口宽度</span><br><span class="line">let g:tagbar_width=35</span><br><span class="line">&quot; 设置tagbar的窗口显示的位置,默认右边</span><br><span class="line">let g:tagbar_right=1</span><br><span class="line">&quot; 打开文件自动 打开tagbar</span><br><span class="line">&quot; autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()</span><br><span class="line">&quot; 这是tagbar一打开，光标即在tagbar页面内，默认在vim打开的文件内</span><br><span class="line">let g:tagbar_autofocus = 1</span><br><span class="line">&quot;设置标签不排序，默认排序</span><br><span class="line">let g:tagbar_sort = 0</span><br><span class="line">&quot; 映射tagbar的快捷键</span><br><span class="line">nnoremap &lt;silent&gt; &lt;F3&gt; :TagbarToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure><h4 id="vim-airline状态栏美化"><a href="#vim-airline状态栏美化" class="headerlink" title="vim-airline状态栏美化"></a>vim-airline状态栏美化</h4><p><a href="https://github.com/vim-airline/vim-airline">vim-airline</a> 和 <a href="https://github.com/vim-airline/vim-airline-themes">vim-airline-themes</a> 搭配能将vim的底部状态增强/美化。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;vim-airline/vim-airline&#x27;</span><br><span class="line">Plug &#x27;vim-airline/vim-airline-themes&#x27;</span><br></pre></td></tr></table></figure><p>相关配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set t_Co=256      &quot;在windows中用xshell连接打开vim可以显示色彩</span><br><span class="line">let g:airline#extensions#tabline#enabled = 1   &quot; 是否打开tabline</span><br><span class="line">&quot;这个是安装字体后 必须设置此项</span><br><span class="line">let g:airline_powerline_fonts = 1</span><br><span class="line">set laststatus=2  &quot;永远显示状态栏</span><br><span class="line">let g:airline_theme=&#x27;bubblegum&#x27; &quot;选择主题</span><br><span class="line">let g:airline#extensions#tabline#enabled=1    &quot;Smarter tab line:显示窗口tab和buffer</span><br><span class="line">&quot;let g:airline#extensions#tabline#left_sep = &#x27; &#x27;  &quot;separater</span><br><span class="line">&quot;let g:airline#extensions#tabline#left_alt_sep = &#x27;|&#x27;  &quot;separater</span><br><span class="line">&quot;let g:airline#extensions#tabline#formatter = &#x27;default&#x27;  &quot;formater</span><br><span class="line">let g:airline_left_sep = &#x27;▶&#x27;</span><br><span class="line">let g:airline_left_alt_sep = &#x27;❯&#x27;</span><br><span class="line">let g:airline_right_sep = &#x27;◀&#x27;</span><br><span class="line">let g:airline_right_alt_sep = &#x27;❮&#x27;</span><br></pre></td></tr></table></figure><h4 id="nerdcommenter批量注释"><a href="#nerdcommenter批量注释" class="headerlink" title="nerdcommenter批量注释"></a>nerdcommenter批量注释</h4><p><a href="https://github.com/preservim/nerdcommenter">nerdcommenter</a>是一款对代码进行批量注释的插件。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;preservim/nerdcommenter&#x27;</span><br></pre></td></tr></table></figure><p>相关配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let g:NERDSpaceDelims = 1   &quot; 注释中间加一个空格  </span><br><span class="line">let g:NERDDefaultAlign = &#x27;left&#x27; &quot; 多行注释向左对齐</span><br></pre></td></tr></table></figure><p>使用方法：<br>在 Normal 和 Visual 模式下：</p><ul><li>\<leader>ca在可选的注释方式之间切换，比如C/C++ 的块注释/<em> </em>/和行注释//  </leader></li><li>\<leader>cc注释当前行</leader></li><li>\<leader>c\<space> 切换注释/非注释状态</space></leader></li><li>\<leader>cs 以”性感”的方式注释</leader></li><li>\<leader>cA 在当前行尾添加注释符，并进入Insert模式</leader></li><li>\<leader>cu 取消注释</leader></li><li>\<leader>c$ 从光标开始到行尾注释  ，这个要说说因为c$也是从光标到行尾的快捷键，这个按过逗号（，）要快一点按c$</leader></li><li>2\<leader>cc 光标以下count行添加注释</leader></li><li>2\<leader>cu 光标以下count行取消注释</leader></li><li>2\<leader>cm:光标以下count行添加块注释(2,cm)</leader></li><li>Normal模式下，几乎所有命令前面都可以指定行数</li><li>Visual模式下执行命令，会对选中的特定区块进行注释/反注释</li></ul><h4 id="golang相关插件"><a href="#golang相关插件" class="headerlink" title="golang相关插件"></a>golang相关插件</h4><p><a href="https://github.com/fatih/vim-go">vim-go</a> 是一款go代码高亮和语法检查的插件。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;fatih/vim-go&#x27;, &#123; &#x27;do&#x27;: &#x27;:GoUpdateBinaries&#x27; &#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/nsf/gocode">gocode</a> 是一款go的代码提示插件。<br>首先要正确设置GOROOT、GOPATH、GOBIN等几个环境变量。<br>下载gocode：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $GOPATH/src/github.com/nsf</span><br><span class="line"></span><br><span class="line">cd $GOPATH/src/github.com/nsf</span><br><span class="line"></span><br><span class="line">git clone https://github.com/nsf/gocode.git</span><br></pre></td></tr></table></figure><p>编译安装gocode：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd gocode</span><br><span class="line"></span><br><span class="line">go build</span><br><span class="line"></span><br><span class="line">go install</span><br></pre></td></tr></table></figure><p>编译完成后生成一个 gocode 的可执行文件，并被放到 $GOBIN 目录下。<br>接下来安装vim-gocode插件:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;nsf/gocode&#x27;, &#123; &#x27;rtp&#x27;: &#x27;vim&#x27;, &#x27;do&#x27;: &#x27;~/.vim/plugged/gocode/vim/symlink.sh&#x27; &#125;</span><br></pre></td></tr></table></figure><h4 id="YouCompleteMe代码补全插件"><a href="#YouCompleteMe代码补全插件" class="headerlink" title="YouCompleteMe代码补全插件"></a>YouCompleteMe代码补全插件</h4><p><a href="https://github.com/ycm-core/YouCompleteMe">YouCompleteMe</a> 是一款非常强大的异步代码自动补全，支持非常多的编程语言，如：C/C++, Golang, Python, Rust, Java等。</p><p>准备依赖环境：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install cmake</span><br><span class="line"></span><br><span class="line">yum install python-devel libffi-devel graphviz-devel elfutils-libelf-devel readline-devel libedit-devel libxml2-devel protobuf-devel gtext-devel doxygen swig</span><br></pre></td></tr></table></figure><p>下载安装：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ycm-core/YouCompleteMe.git ~/.vim/plugged/YouCompleteMe</span><br><span class="line"></span><br><span class="line">cd ~/.vim/plugged/YouCompleteMe</span><br><span class="line"></span><br><span class="line">python3 install.py --all</span><br></pre></td></tr></table></figure><p>相关配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let g:ycm_confirm_extra_conf=0      &quot; 关闭加载.ycm_extra_conf.py提示</span><br><span class="line">let g:ycm_complete_in_comments = 1  &quot;在注释输入中也能补全</span><br><span class="line">let g:ycm_complete_in_strings = 1   &quot;在字符串输入中也能补全</span><br><span class="line">let g:ycm_collect_identifiers_from_tags_files=1                 &quot; 开启 YCM 基于标签引擎</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 1   &quot;注释和字符串中的文字也会被收入补全</span><br><span class="line">let g:ycm_seed_identifiers_with_syntax=1   &quot;语言关键字补全, 不过python关键字都很短，所以，需要的自己打开</span><br><span class="line">let g:ycm_min_num_of_chars_for_completion=2                     &quot; 从第2个键入字符就开始罗列匹配项</span><br><span class="line">&quot; 引入，可以补全系统，以及python的第三方包 针对新老版本YCM做了兼容</span><br><span class="line">if !empty(glob(&quot;~/..vim/plugged/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py&quot;))</span><br><span class="line">    let g:ycm_global_ycm_extra_conf = &quot;~/..vim/plugged/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py&quot;</span><br><span class="line">endif</span><br><span class="line">&quot;mapping</span><br><span class="line">nmap &lt;leader&gt;gd :YcmDiags&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;gl :YcmCompleter GoToDeclaration&lt;CR&gt;           &quot; 跳转到申明处</span><br><span class="line">nnoremap &lt;leader&gt;gf :YcmCompleter GoToDefinition&lt;CR&gt;            &quot; 跳转到定义处</span><br><span class="line">nnoremap &lt;leader&gt;gg :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">&quot; 直接触发自动补全</span><br><span class="line">let g:ycm_key_invoke_completion = &#x27;&lt;C-Space&gt;&#x27;</span><br><span class="line">&quot; 黑名单,不启用</span><br><span class="line">      \ &#x27;tagbar&#x27; : 1,</span><br><span class="line">      \ &#x27;gitcommit&#x27; : 1,</span><br><span class="line">      \&#125;</span><br></pre></td></tr></table></figure><hr><p>此处还没有结束，未来如果碰到好用的插件，会继续更新。。。<br>以上所有的配置我将它上传到了github上，有需要的可自行下载 <a href="https://github.com/Grizzly1127/vim-config">vimrc</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为最终想要安装YCM插件，而最新的YCM插件只支持 python3.6 和 vim8.1 以上的版本，所以需要更新系统自带的 python 和 vim（如果以安装最新的环境，则可忽略）。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="vim" scheme="https://blog.grizzlys.top/categories/vim/"/>
    
    
    <category term="vim" scheme="https://blog.grizzlys.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>gohbase二次封装</title>
    <link href="https://blog.grizzlys.top/golang/go-hbase-encapsulation/"/>
    <id>https://blog.grizzlys.top/golang/go-hbase-encapsulation/</id>
    <published>2020-09-10T07:58:30.000Z</published>
    <updated>2021-07-08T02:33:40.857Z</updated>
    
    <content type="html"><![CDATA[<p>对 <a href="https://github.com/tsuna/gohbase">gohbase</a> 进行封装，提供简单的 API 接口以方便使用。<br><a id="more"></a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hbase</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/golang/glog&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/tsuna/gohbase&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/tsuna/gohbase/hrpc&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HbaseClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    host        <span class="keyword">string</span></span><br><span class="line">    option      <span class="keyword">string</span></span><br><span class="line">    client      gohbase.Client</span><br><span class="line">    adminClient gohbase.AdminClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工厂模式创建实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHbaseClient</span><span class="params">(host <span class="keyword">string</span>)</span> *<span class="title">HbaseClient</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;HbaseClient&#123;</span><br><span class="line">        host: host,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接hbase</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">Connect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hb.client = gohbase.NewClient(hb.host)</span><br><span class="line">    hb.adminClient = gohbase.NewAdminClient(hb.host)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">CreateTable</span><span class="params">(table <span class="keyword">string</span>, families <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    createRequest := hrpc.NewCreateTable(context.Background(), []<span class="keyword">byte</span>(table), families)</span><br><span class="line">    <span class="keyword">if</span> err = hb.adminClient.CreateTable(createRequest); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[CreateTable] CreateTable error! table-&gt;%s, error-&gt;%v&quot;</span>, table, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">DeleteTable</span><span class="params">(table <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    delRequest := hrpc.NewDeleteTable(context.Background(), []<span class="keyword">byte</span>(table))</span><br><span class="line">    <span class="keyword">if</span> err = hb.adminClient.DeleteTable(delRequest); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[DeleteTable] DeleteTable error! table-&gt;%s, error-&gt;%v&quot;</span>, table, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">PutsByRowkey</span><span class="params">(table, rowKey <span class="keyword">string</span>, values <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    putRequest, err := hrpc.NewPutStr(context.Background(), table, rowKey, values)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[PutsByRowkey] NewPutStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = hb.client.Put(putRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[PutsByRowkey] Put error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">UpdateByRowkey</span><span class="params">(table, rowKey <span class="keyword">string</span>, values <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    putRequest, err := hrpc.NewPutStr(context.Background(), table, rowKey, values)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[UpdateByRowkey] NewPutStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = hb.client.Put(putRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[UpdateByRowkey] Put error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查rowkey</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">GetsByRowkey</span><span class="params">(table, rowKey <span class="keyword">string</span>)</span> <span class="params">(*hrpc.Result, error)</span></span> &#123;</span><br><span class="line">    getRequest, err := hrpc.NewGetStr(context.Background(), table, rowKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[GetsByRowkey] NewGetStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := hb.client.Get(getRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[GetsByRowkey] Get error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查rowkkey的某些列族</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">GetsByRowkeyCF</span><span class="params">(table, rowKey <span class="keyword">string</span>, families <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span> <span class="params">(*hrpc.Result, error)</span></span> &#123;</span><br><span class="line">    getRequest, err := hrpc.NewGetStr(context.Background(), table, rowKey, hrpc.Families(families))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[GetsByRowkeyCF] NewGetStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := hb.client.Get(getRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[GetsByRowkeyCF] Get error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">DeleteByRowkey</span><span class="params">(table, rowKey <span class="keyword">string</span>, value <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    delRequest, err := hrpc.NewDelStr(context.Background(), table, rowKey, value)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[DeleteByRowkey] NewDelStr error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err = hb.client.Delete(delRequest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[DeleteByRowkey] Delete error! table-&gt;%s, rowKey-&gt;%s, error-&gt;%v&quot;</span>, table, rowKey, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">ScanByTable</span><span class="params">(table, startRow, stopRow <span class="keyword">string</span>)</span> <span class="params">([]*hrpc.Result, error)</span></span> &#123;</span><br><span class="line">    scanRequest, err := hrpc.NewScanRangeStr(context.Background(), table, startRow, stopRow)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Errorf(<span class="string">&quot;[ScanByTable] NewScanRangeStr error! table-&gt;%s, startRow-&gt;%s, endRow-&gt;%s, error-&gt;%v&quot;</span>, table, startRow, stopRow, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    scan := hb.client.Scan(scanRequest)</span><br><span class="line">    <span class="keyword">var</span> res []*hrpc.Result</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        getRsp, err := scan.Next()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF || getRsp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Errorf(<span class="string">&quot;[ScanByTable] scan.Next error! table-&gt;%s, error-&gt;%v&quot;</span>, table, err)</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, getRsp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hb *HbaseClient)</span> <span class="title">IsExistRowKey</span><span class="params">(table, rowKey <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    res, err := hb.GetsByRowkey(table, rowKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(res.Cells) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;对 &lt;a href=&quot;https://github.com/tsuna/gohbase&quot;&gt;gohbase&lt;/a&gt; 进行封装，提供简单的 API 接口以方便使用。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="https://blog.grizzlys.top/categories/golang/"/>
    
    
    <category term="hbase" scheme="https://blog.grizzlys.top/tags/hbase/"/>
    
    <category term="gohbase" scheme="https://blog.grizzlys.top/tags/gohbase/"/>
    
    <category term="go" scheme="https://blog.grizzlys.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-网络通信</title>
    <link href="https://blog.grizzlys.top/Redis/4-net/redis-parse-networking/"/>
    <id>https://blog.grizzlys.top/Redis/4-net/redis-parse-networking/</id>
    <published>2020-07-15T02:06:08.000Z</published>
    <updated>2021-07-08T02:33:40.869Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：anet.c/anet.h/networking.c</p><p><strong>1. 简介</strong><br>Redis在<code>anet.c</code>中对TCP/IP网络中socket api接口和状态设置进行了封装。状态设置主要包括socket连接的阻塞性、tcp的保活定时器的设置、设置发送缓冲区、tcp的nagle算法设置、设置发送/接收超时时间、地址重用的设置和IPv6/IPv4的设置等。<br>Redis网络通讯的具体实现在<code>networking.c</code>中，主要包括如何建立和客户端的连接，并且接收其命令，返回给客户端。</p><a id="more"></a><p><strong>2. 回顾tcp socket编程</strong><br>2.1 TCP客户/服务器程序socket编程流程如下：<br><img src="https://i.loli.net/2020/10/29/5diHCr9l4joFegw.png" alt="socket.png"></p><p>2.2 TCP的三次握手<br><img src="https://i.loli.net/2020/10/29/o5zhlJdUMWrGpC3.png" alt="tcp_handshake.png"></p><p>2.3 TCP的四次挥手<br>TCP的断开连接操作可由<strong>任意一端发起</strong><br><img src="https://i.loli.net/2020/10/29/miRLwn5sPd63Ycb.png" alt="tcp_close.png"></p><p><strong>3. anet解析</strong><br>anet.h中定义的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port)</span></span>; <span class="comment">// tcp连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port)</span></span>; <span class="comment">// TCP非阻塞连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockBindConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *source_addr)</span></span>; <span class="comment">// TCP非阻塞绑定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpNonBlockBestEffortBindConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *source_addr)</span></span>; <span class="comment">// TCP非阻塞绑定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">// unix socket连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixNonBlockConnect</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">// unix socket非阻塞连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetRead</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span>; <span class="comment">// socket读数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetResolve</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *host, <span class="keyword">char</span> *ipbuf, <span class="keyword">size_t</span> ipbuf_len)</span></span>; <span class="comment">// 解析所有的东西</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetResolveIP</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *host, <span class="keyword">char</span> *ipbuf, <span class="keyword">size_t</span> ipbuf_len)</span></span>; <span class="comment">// 解析IP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// IPv4下创建socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcp6Server</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// IPv6下创建socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> perm, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// unix创建socket和bind</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> serversock, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// tcp socket接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetUnixAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> serversock)</span></span>; <span class="comment">// unix tcp socket接收</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetWrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span>; <span class="comment">// socket写数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetNonBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置socket为非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置socket为阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetEnableTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 启用tcp_nodelay选项（关闭Nagle算法）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetDisableTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 禁用tcp_nodelay选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span>; <span class="comment">// 设置tcp keepalive选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetSendTimeout</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> ms)</span></span>; <span class="comment">// 设置发送超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetRecvTimeout</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> ms)</span></span>; <span class="comment">// 设置接收超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetPeerToString</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// 获取客户端的ip、port</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">int</span> interval)</span></span>; <span class="comment">// 设置tcp keepalive选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetSockName</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span></span>; <span class="comment">// 获取套接字的名字</span></span><br><span class="line"><span class="comment">/* 格式化操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatAddr</span><span class="params">(<span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len, <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatPeer</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetFormatSock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *fmt, <span class="keyword">size_t</span> fmt_len)</span></span>;</span><br></pre></td></tr></table></figure><p>Redis服务启动后会调用<code>server.c/listenToPort()</code>进行socket相关的设置和端口监听。如果服务器配置不包含要绑定的特定地址，则该函数会尝试IPv6（调用<code>anetTcp6Server()</code>）和IPv4（调用<code>anetTcpServer()</code>）协议进行绑定。<br>不管是使用IPv6还是IPv4协议，最终调用的都是<code>_anetTcpServer()</code>来创建socket并进行绑定监听，以下是该函数的实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _anetTcpServer(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> af, <span class="keyword">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">-1</span>, rv;</span><br><span class="line">    <span class="keyword">char</span> _port[<span class="number">6</span>];  <span class="comment">/* strlen(&quot;65535&quot;) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">servinfo</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(_port,<span class="number">6</span>,<span class="string">&quot;%d&quot;</span>,port);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = af;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE;    <span class="comment">/* No effect if bindaddr != NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将域名解析成ip地址</span></span><br><span class="line">    <span class="keyword">if</span> ((rv = getaddrinfo(bindaddr,_port,&amp;hints,&amp;servinfo)) != <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;%s&quot;</span>, gai_strerror(rv));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = servinfo; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = socket(p-&gt;ai_family,p-&gt;ai_socktype,p-&gt;ai_protocol)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (af == AF_INET6 &amp;&amp; anetV6Only(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// 设置SO_REUSEADDR允许我们重复bind相同的本地地址</span></span><br><span class="line">        <span class="keyword">if</span> (anetSetReuseAddr(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// bind &amp;&amp; listen</span></span><br><span class="line">        <span class="keyword">if</span> (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;unable to bind socket, errno: %d&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">-1</span>) close(s);</span><br><span class="line">    s = ANET_ERR;</span><br><span class="line">end:</span><br><span class="line">    freeaddrinfo(servinfo);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. networking解析</strong><br>新版本Redis增加了多线程I/O来改进读写缓冲区的性能，而不是改进命令执行的性能主要原因是：</p><ol><li>读写缓冲区在命令执行的生命周期中是占了比较大的比重</li><li>Redis更倾向于保持简单的设计，如果在命令执行部分改用多线程会不得不处理各种问题，例如并发写入、加锁等</li></ol><p>那么将读写缓冲区改为多线程后整个模型大致如下：<br><img src="https://i.loli.net/2020/10/29/AXlEnyOF3qk7vbg.png" alt="thread-io.png"></p><p>4.1 线程初始化<br>首先，如果用户没有开启多线程IO，也就是io_threads_num == 1时直接按照单线程模型处理，如果超过线程数IO_THREADS_MAX_NUM上限则异常退出。</p><p>紧接着Redis使用listCreate()创建io_threads_num个线程，并且对主线程（id=0）以外的线程进行处理：</p><ul><li>初始化线程的等待任务数为0</li><li>获取锁，使得线程不能进行操作</li><li>将线程tid与Redis中的线程id（for循环生成）进行映射</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    io_threads_active = <span class="number">0</span>; <span class="comment">/* We start with threads not active. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果io_threads_num为1，则按照单线程模型处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程数设置超过上限</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num &gt; IO_THREADS_MAX_NUM) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal: too many I/O threads configured. &quot;</span></span><br><span class="line">                             <span class="string">&quot;The maximum number is %d.&quot;</span>, IO_THREADS_MAX_NUM);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 生成并初始化对应 io_threads_num 个I/O线程 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; server.io_threads_num; i++) &#123;</span><br><span class="line">        io_threads_list[i] = listCreate();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* 0为主线程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 非主线程则需要以下处理 */</span></span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">// 为线程初始化对应的锁</span></span><br><span class="line">        pthread_mutex_init(&amp;io_threads_mutex[i],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 线程等待状态初始化为0</span></span><br><span class="line">        io_threads_pending[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化后将线程暂时锁住</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[i]); <span class="comment">/* Thread will be stopped. */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid,<span class="literal">NULL</span>,IOThreadMain,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Fatal: Can&#x27;t initialize IO thread.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将index和对应线程ID加以映射</span></span><br><span class="line">        io_threads[i] = tid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2 建立连接<br>Redis服务端会初始化一个socket端口来监听客户端的连接，当一个连接建立后，服务端会对客户端的socket进行设置：</p><ol><li>客户端socket设置为非阻塞模式，因为Redis采用的是非阻塞I/O多路复用模型。</li><li>客户端socket设置为 TCP_NODELAY 属性，禁用 Nagle 算法。</li><li>将该socket绑定读事件到时间loop，用于监听这个客户端socket的数据发送。</li><li>建立连接后如果发现已经超过最大连接数，则关闭连接，删除该客户端socket。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当conn为NULL时，创建无网络连接的伪客户端</span></span><br><span class="line"><span class="comment">     * 当conn不为NULL时，创建带网络连接的客户端</span></span><br><span class="line"><span class="comment">     * 因为 Redis 的命令必须在客户端的上下文中使用，所以在执行 Lua 环境中的命令时</span></span><br><span class="line"><span class="comment">     * 需要用到这种伪终端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (conn) &#123;</span><br><span class="line">        <span class="comment">// 设置非阻塞</span></span><br><span class="line">        connNonBlock(conn);</span><br><span class="line">        <span class="comment">// 禁用tcp_nodelay</span></span><br><span class="line">        connEnableTcpNoDelay(conn);</span><br><span class="line">        <span class="comment">// 设置 keep alive</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            connKeepAlive(conn,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 绑定读事件和处理函数到事件loop（开始接收命令请求）</span></span><br><span class="line">        connSetReadHandler(conn, readQueryFromClient);</span><br><span class="line">        <span class="comment">// 将私有数据指针与连接相关联</span></span><br><span class="line">        connSetPrivateData(conn, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化客户端参数</span></span><br><span class="line">    selectDb(c,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> client_id = ++server.next_client_id;</span><br><span class="line">    c-&gt;id = client_id;</span><br><span class="line">    c-&gt;resp = <span class="number">2</span>;</span><br><span class="line">    c-&gt;conn = conn;</span><br><span class="line">    c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">    c-&gt;qb_pos = <span class="number">0</span>;</span><br><span class="line">    c-&gt;querybuf = sdsempty();</span><br><span class="line">    c-&gt;pending_querybuf = sdsempty();</span><br><span class="line">    c-&gt;querybuf_peak = <span class="number">0</span>;</span><br><span class="line">    c-&gt;reqtype = <span class="number">0</span>;</span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    c-&gt;argv = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;user = DefaultUser;</span><br><span class="line">    c-&gt;multibulklen = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">    c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">    c-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">/* If the default user does not require authentication, the user is</span></span><br><span class="line"><span class="comment">     * directly authenticated. */</span></span><br><span class="line">    c-&gt;authenticated = (c-&gt;user-&gt;flags &amp; USER_FLAG_NOPASS) != <span class="number">0</span>;</span><br><span class="line">    c-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line">    c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    c-&gt;reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;read_reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_off = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_time = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_listening_port = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_ip[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    c-&gt;slave_capa = SLAVE_CAPA_NONE;</span><br><span class="line">    c-&gt;reply = listCreate();</span><br><span class="line">    c-&gt;reply_bytes = <span class="number">0</span>;</span><br><span class="line">    c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line">    listSetFreeMethod(c-&gt;reply,freeClientReplyValue);</span><br><span class="line">    listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span><br><span class="line">    c-&gt;btype = BLOCKED_NONE;</span><br><span class="line">    c-&gt;bpop.timeout = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.keys = dictCreate(&amp;objectKeyHeapPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_group = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_consumer = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.xread_group_noack = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.numreplicas = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.reploffset = <span class="number">0</span>;</span><br><span class="line">    c-&gt;woff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;watched_keys = listCreate();</span><br><span class="line">    c-&gt;pubsub_channels = dictCreate(&amp;objectKeyPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    c-&gt;pubsub_patterns = listCreate();</span><br><span class="line">    c-&gt;peerid = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;client_list_node = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;client_tracking_redirection = <span class="number">0</span>;</span><br><span class="line">    c-&gt;client_tracking_prefixes = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_callback = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_callback_privdata = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;auth_module = <span class="literal">NULL</span>;</span><br><span class="line">    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</span><br><span class="line">    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</span><br><span class="line">    <span class="keyword">if</span> (conn) linkClient(c); <span class="comment">// 如果不是伪客户端，那么添加到服务器的客户端链表中</span></span><br><span class="line">    initClientMultiState(c); <span class="comment">// 初始化客户端的事务状态</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.3 读事件到来<br>读事件到来，Redis需要判断是否满足Threaded IO条件。如果符合，则将client放到等待读取的队列中，并将client的flag设置为等待读取；如果不符合，则按照单线程模型往下继续处理。<br>等待读取队列由server维护，包含了所有处于读事件pending的客户端列表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取客户端结构体</span></span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果启动了 I/O 线程，则将客户端加到server.clients_pending_read列表中 */</span></span><br><span class="line">    <span class="keyword">if</span> (postponeClientRead(c)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    readlen = PROTO_IOBUF_LEN; <span class="comment">// 通用缓冲区大小 1024*16</span></span><br><span class="line">    <span class="comment">/* 如果是批量请求，则需要提高缓冲区的大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> remaining = (<span class="keyword">size_t</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在某些边缘情况下，“remaining”变量可能为零，例如，在客户端暂停后恢复被阻塞的客户端。 */</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &gt; <span class="number">0</span> &amp;&amp; remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取缓冲区内当前内容的长度</span></span><br><span class="line"><span class="comment">     * 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span></span><br><span class="line"><span class="comment">     * 这些滞留内容也许不能完整构成一个符合协议的命令 */</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen); <span class="comment">// 扩容querybuf的大小</span></span><br><span class="line">    nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen); <span class="comment">// 读取内容到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取错误</span></span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE, <span class="string">&quot;Reading from client: %s&quot;</span>,connGetLastError(c-&gt;conn));</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF</span></span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">&quot;Client closed connection&quot;</span>);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) &#123;</span><br><span class="line">        <span class="comment">/* 将缓冲区内的内容追加到pending缓冲区中，稍后将使用这个缓冲区，以便在执行最后一个命令时应用字符串的副本 */</span></span><br><span class="line">        c-&gt;pending_querybuf = sdscatlen(c-&gt;pending_querybuf,</span><br><span class="line">                                        c-&gt;querybuf+qblen,nread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据内容，更新查询缓冲区（SDS） free 和 len 属性</span></span><br><span class="line">    <span class="comment">// 并将 &#x27;\0&#x27; 正确地放到内容的最后</span></span><br><span class="line">    sdsIncrLen(c-&gt;querybuf,nread);</span><br><span class="line">    <span class="comment">// 记录服务器和客户端最后一次互动的时间</span></span><br><span class="line">    c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 如果客户端是 master 的话，更新它的复制偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) c-&gt;read_reploff += nread;</span><br><span class="line">    server.stat_net_input_bytes += nread;</span><br><span class="line">    <span class="comment">// 查询缓冲区长度超出服务器最大缓冲区长度</span></span><br><span class="line">    <span class="comment">// 清空缓冲区并释放客户端</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;</span>, ci, bytes);</span><br><span class="line">        sdsfree(ci);</span><br><span class="line">        sdsfree(bytes);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 客户端输入缓冲区中有更多数据，继续分析以防有完整的命令要执行. */</span></span><br><span class="line">     processInputBufferAndReplicate(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开启了Threaded-IO，如何分配读取pending的client给thread呢？<code>handleClientsWithPendingReadsUsingThreads()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingReadsUsingThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!io_threads_active || !server.io_threads_do_reads) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查有多少等待读的client</span></span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;%d TOTAL READ pending clients\n&quot;</span>, processed);</span><br><span class="line"></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将每个等待的client分配给线程，当等待长度超过线程数时，每个线程分配到的client可能会超过1个</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改每个线程需要完成的数量 */</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_READ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        io_threads_pending[j] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 也可以使用主线程来处理客户端的一部分 */</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        readQueryFromClient(c-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待线程处理直到没有剩余任务 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += io_threads_pending[j];</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;I/O READ All threads finshed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次运行客户端列表以处理新的缓冲区 */</span></span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) &#123;</span><br><span class="line">            c-&gt;flags &amp;= ~ CLIENT_PENDING_COMMAND;</span><br><span class="line">            processCommandAndResetClient(c);</span><br><span class="line">        &#125;</span><br><span class="line">        processInputBufferAndReplicate(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空client_pending_read</span></span><br><span class="line">    listEmpty(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何处理读请求？<br>在上面的过程中，当任务分发完毕后，每个线程按照正常流程将自己负责的Client的读取缓冲区的内容进行处理，和原来的单线程没有太大差异。</p><p>每轮处理中，需要将各个线程的锁开启，打开标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) &#123; <span class="built_in">printf</span>(<span class="string">&quot;S&quot;</span>); fflush(<span class="built_in">stdout</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;--- STARTING THREADED IO ---\n&quot;</span>);</span><br><span class="line">    serverAssert(io_threads_active == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">        <span class="comment">// 解开线程的锁定状态</span></span><br><span class="line">        pthread_mutex_unlock(&amp;io_threads_mutex[j]);</span><br><span class="line">    <span class="comment">// 现在可以开始多线程IO执行对应读/写任务</span></span><br><span class="line">    io_threads_active = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样结束时，首先需要检查是否有剩余待读的IO，如果没有，将线程锁定，标志关闭：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要停止的时候可能还有等待读的Client 在停止前进行处理</span></span><br><span class="line">    handleClientsWithPendingReadsUsingThreads();</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) &#123; <span class="built_in">printf</span>(<span class="string">&quot;E&quot;</span>); fflush(<span class="built_in">stdout</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;--- STOPPING THREADED IO [R%d] [W%d] ---\n&quot;</span>,</span><br><span class="line">        (<span class="keyword">int</span>) listLength(server.clients_pending_read),</span><br><span class="line">        (<span class="keyword">int</span>) listLength(server.clients_pending_write));</span><br><span class="line">    serverAssert(io_threads_active == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">        <span class="comment">// 本轮IO结束 将所有线程上锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[j]);</span><br><span class="line">    <span class="comment">// IO状态设置为关闭</span></span><br><span class="line">    io_threads_active = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.3 写入返回缓冲区<br>众多的<code>addReply*()</code>方法最终会调用<code>_addReplyToBuffer()</code>函数在缓冲区中添加回复数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _addReplyToBuffer(client *c, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> available = <span class="keyword">sizeof</span>(c-&gt;buf)-c-&gt;bufpos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正准备关闭客户端，无需回复任何内容</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果回复列表中已经有内容，则无法向静态缓冲区添加更多内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;reply) &gt; <span class="number">0</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查缓冲区是否有足够的空间用于该字符串 */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; available) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内容追加到c-&gt;buf中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;buf+c-&gt;bufpos,s,len);</span><br><span class="line">    c-&gt;bufpos+=len;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用<code>_addReplyToBuffer()</code>函数失败，将会调用另一个函数<code>_addReplyProtoToList()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _addReplyProtoToList(client *c, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    listNode *ln = listLast(c-&gt;reply);</span><br><span class="line">    clientReplyBlock *tail = ln? listNodeValue(ln): <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that &#x27;tail&#x27; may be NULL even if we have a tail node, becuase when</span></span><br><span class="line"><span class="comment">     * addDeferredMultiBulkLength() is used, it sets a dummy node to NULL just</span></span><br><span class="line"><span class="comment">     * fo fill it later, when the size of the bulk length is set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Append to tail string when possible. */</span></span><br><span class="line">    <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">        <span class="comment">/* Copy the part we can fit into the tail, and leave the rest for a</span></span><br><span class="line"><span class="comment">         * new node */</span></span><br><span class="line">        <span class="keyword">size_t</span> avail = tail-&gt;size - tail-&gt;used;</span><br><span class="line">        <span class="keyword">size_t</span> copy = avail &gt;= len? len: avail;</span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf + tail-&gt;used, s, copy);</span><br><span class="line">        tail-&gt;used += copy;</span><br><span class="line">        s += copy;</span><br><span class="line">        len -= copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        <span class="comment">/* Create a new node, make sure it is allocated to at</span></span><br><span class="line"><span class="comment">         * least PROTO_REPLY_CHUNK_BYTES */</span></span><br><span class="line">        <span class="keyword">size_t</span> size = len &lt; PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;</span><br><span class="line">        tail = zmalloc(size + <span class="keyword">sizeof</span>(clientReplyBlock));</span><br><span class="line">        <span class="comment">/* take over the allocation&#x27;s internal fragmentation */</span></span><br><span class="line">        tail-&gt;size = zmalloc_usable(tail) - <span class="keyword">sizeof</span>(clientReplyBlock);</span><br><span class="line">        tail-&gt;used = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf, s, len);</span><br><span class="line">        listAddNodeTail(c-&gt;reply, tail);</span><br><span class="line">        c-&gt;reply_bytes += tail-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    asyncCloseClientOnOutputBufferLimitReached(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：anet.c/anet.h/networking.c&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 简介&lt;/strong&gt;&lt;br&gt;Redis在&lt;code&gt;anet.c&lt;/code&gt;中对TCP/IP网络中socket api接口和状态设置进行了封装。状态设置主要包括socket连接的阻塞性、tcp的保活定时器的设置、设置发送缓冲区、tcp的nagle算法设置、设置发送/接收超时时间、地址重用的设置和IPv6/IPv4的设置等。&lt;br&gt;Redis网络通讯的具体实现在&lt;code&gt;networking.c&lt;/code&gt;中，主要包括如何建立和客户端的连接，并且接收其命令，返回给客户端。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="4-net" scheme="https://blog.grizzlys.top/categories/Redis/4-net/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-事件驱动</title>
    <link href="https://blog.grizzlys.top/Redis/4-net/redis-parse-event/"/>
    <id>https://blog.grizzlys.top/Redis/4-net/redis-parse-event/</id>
    <published>2020-07-14T07:38:42.000Z</published>
    <updated>2021-07-08T02:33:40.866Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：ae.c/ae.h/ae_evport.c/ae_epoll.c/ae_kqueue.c/ae_select.c</p><p><strong>1. 简介</strong><br>Redis 是一个事件驱动的内存数据库，服务器需要处理两种类型的事件：</p><ul><li>文本（IO）事件<code>AE_FILE_EVENTS</code></li><li>时间事件<code>AE_TIME_EVENTS</code></li></ul><a id="more"></a><p><strong>2. 文本（IO）事件</strong><br>Redis是基于 Reactor 模式开发了自己的网络事件处理器，这个处理器被称为文件事件处理器。</p><ul><li>文件事件处理器使用 I/O 多路复用（multiplexing）模型来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用模型来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。<br>优势：</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作。</li><li>使用多路I/O复用模型，非阻塞IO。</li></ul><p>Redis提供了4中 I/O 多路复用的方式，其性能由高到低依次是：<code>evport</code> -&gt; <code>epoll</code> -&gt; <code>kqueue</code> -&gt; <code>select</code>。<br>不同的平台使用了不同的实现方式，比如 epoll 和 select 可以用于Linux平台，kqueue 用于MacOS平台，select 用于Windows平台，evport 用于Solaris平台。<br>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_select.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>一般情况下，Redis服务端都是部署在Linux系统上的，所以本文内容就只解析Redis是怎么利用epoll实现 I/O 多路复用的吧。</p><p><strong>epoll：</strong><br>epoll相关的接口实现都封装在了ae_epoll.c中，主要提供了以下几个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 调用epoll_create创建epoll实例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span></span>; <span class="comment">// 重新设置epoll_event的大小</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span></span>; <span class="comment">// 释放实例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>; <span class="comment">// 当有新的客户端连接时，将新的fd注册到epoll实例中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> delmask)</span></span>; <span class="comment">// 当有客户端断开连接时，将epoll实例中该客户端的fd删除</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span></span>; <span class="comment">// 调用epoll_wait获取客户端产生的io事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">aeApiName</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;epoll&quot;</span>; &#125;</span><br></pre></td></tr></table></figure><p>在redis.h/redisServer 结构中，保存着基于事件驱动的程序状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    aeEventLoop *el;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* 当前注册的最大fd */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* 最大fd数 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* 用于检测系统时钟偏差 */</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* 注册事件 */</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* 触发事件 */</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line">    <span class="keyword">int</span> stop;</span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* 用于轮询特定于API的数据 */</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line">    aeBeforeSleepProc *aftersleep;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure><p>Redis服务器在启动时，首先会创建事件轮询器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据不同平台调用不同的 I/O 多路复用模型</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成后，开始事件轮询主循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件的调度和执行函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果不处理时间事件或文本时间，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意，只要我们想处理时间事件，即使没有要处理的文件事件，我们也要调用select（），以便在下一个时间事件准备好触发之前休眠 */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            <span class="comment">// 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算剩余时间 */</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms =</span><br><span class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">                shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果我们必须检查事件，但由于AE_DONT_WAIT而需要尽快返回，我们需要将超时设置为0 */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 等待事件触发或者超时 */</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 阻塞后处理函数 */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果设置了AE_BARRIER标志，我们优先处理写事件 */</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理写事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果需要反转读写处理顺序，处理完写事件后，可以处理读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理时间事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* 返回处理的文本/时间事件数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 时间事件</strong><br>Redis有很多操作需要在给定的时间点进行处理，时间事件就是对这类定时任务的抽象。<br>先看看时间事件的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* 时间事件唯一标识符 */</span></span><br><span class="line">    <span class="comment">/* 事件的到达时间 */</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    <span class="comment">/* 事件处理函数 */</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    <span class="comment">/* 事件释放函数 */</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="comment">/* 多路复用库的私有数据 */</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line">    <span class="comment">/* 指向前、后两个时间事件结构，形成双向链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><p>处理时间事件的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</span><br><span class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 记录最新一次执行这个函数的时间，用于处理系统时间被修改产生的问题 */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span>(te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 2. 遍历链表找出所有 when_sec 和 when_ms 小于现在时间的事件。 */</span></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果当前的事件被设置为删除，则删除该事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</span><br><span class="line">            aeTimeEvent *next = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;prev)</span><br><span class="line">                te-&gt;prev-&gt;next = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;next)</span><br><span class="line">                te-&gt;next-&gt;prev = te-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line">            zfree(te);</span><br><span class="line">            te = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            <span class="comment">/* 3. 执行事件对应的处理函数 */</span></span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">/* 4. 检查事件类型，如果是周期事件则刷新该事件下一次的执行事件，否则从列表中删除事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong><br>为什么单线程的Redis会这么快？</p><ul><li>Redis是完全基于内存的数据库，绝大部分请求是纯粹的内存操作，非常快速。</li><li>Redis由C语言编写，数据结构简单，对数据的操作也简单，Redis中的数据结构是专门设计的。</li><li>Redis采用单线程，保证了数据操作的原子性，不存在多进程或者多线程导致切换而消耗CPU，避免了不必要的上下文切换和竞争条件，不存在加/解锁的操作，不用考虑可能出现的死锁导致性能消耗。</li><li>使用 I/O 多路复用模型，非阻塞IO，可以处理并发的连接。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：ae.c/ae.h/ae_evport.c/ae_epoll.c/ae_kqueue.c/ae_select.c&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 简介&lt;/strong&gt;&lt;br&gt;Redis 是一个事件驱动的内存数据库，服务器需要处理两种类型的事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本（IO）事件&lt;code&gt;AE_FILE_EVENTS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;时间事件&lt;code&gt;AE_TIME_EVENTS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="4-net" scheme="https://blog.grizzlys.top/categories/Redis/4-net/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-事务</title>
    <link href="https://blog.grizzlys.top/Redis/3-database/redis-parse-multi/"/>
    <id>https://blog.grizzlys.top/Redis/3-database/redis-parse-multi/</id>
    <published>2020-07-13T07:32:54.000Z</published>
    <updated>2021-07-08T02:33:40.869Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：multi.c/redis.h</p><p><strong>1. 简介</strong><br>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><a id="more"></a><p>Redis事务的ACID特性：</p><p><strong>A原子性（atomicity）</strong><br>单个Redis命令的执行是原子性的，但Redis没有在事务上增加任何维护原子性的机制，所以<strong>Redis事务的执行不是原子性</strong>的。<br>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败<br>事务失败时，Redis 也不会进行任何的重试或者回滚动作，不满足要么全部全部执行，要么都不执行的条件</p><p><strong>C一致性（consistency）：</strong><br>一致性分下面几种情况来讨论：</p><p>首先，如果一个事务的指令全部被执行，那么数据库的状态是满足数据库完整性约束的</p><p>其次，如果一个事务中有的指令有错误，那么数据库的状态是满足数据完整性约束的</p><p>最后，如果事务运行到某条指令时，进程被kill掉了，那么要分下面几种情况讨论：</p><ul><li>如果当前redis采用的是内存模式，那么重启之后redis数据库是空的，那么满足一致性条件</li><li>如果当前采用RDB模式存储的，在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。 恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数 据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的</li><li>如果当前采用的是AOF存储的，那么可能事务的内容还未写入到AOF文件，那么此时肯定是满足一致性的，如果事务的内容有部分写入到AOF文件中，那么需要用工具把AOF中事务执行部分成功的指令移除，这时，移除之后的AOF文件也是满足一致性的</li></ul><p>所以，<strong>redis事务满足一致性约束</strong>。</p><p><strong>I隔离性（isolation）：</strong><br>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性</strong>的。</p><p><strong>D持久性（durability）：</strong><br>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定</p><ul><li>在单纯的内存模式下，事务肯定是不持久的</li><li>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的</li><li>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync 或 fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</li><li>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</li></ul><p><strong>2. 命令介绍</strong><br>下面介绍命令的使用详情：</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>MULTI</td><td>标记一个事务的开始</td></tr><tr><td>DISCARD</td><td>取消事务，放弃执行事务块内的所有命令</td></tr><tr><td>EXEC</td><td>执行事务内的所有命令</td></tr><tr><td>WATCH key [key …]</td><td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断，不会被执行</td></tr><tr><td>UNWATCH</td><td>取消 WATCH 命令对所有 key 的监视</td></tr></tbody></table></div><p><strong>3. 实现细节</strong><br>Redis事务从开始到结束通常分为三步：</p><ol><li>事务开始(MULTI)：MULTI命令可以将执行该命令的客户端从非事务状态切换成事务状态，这一切换是通过客户端状态的flags属性中打开 <code>CLIENT_MULTI</code> 标识完成的。</li><li>命令入队：切换到事务状态后，该客户端输入的所有命令，都会被暂存到一个命令队列里，不会立即执行。</li><li>事务执行(EXEX)：EXEC命令将命令队列里的命令挨个执行完成。</li></ol><p>Redis会把每个连接的客户端封装成一个client结构体，该结构体包含大量的字段用来保存需要的信息。其中，事务相关的字段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    multiState mstate;</span><br><span class="line">    <span class="built_in">list</span> *watched_keys; <span class="comment">// 监视的key列表（节点结构：watchedKey）</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Client MULTI/EXEC state */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    robj **argv;    <span class="comment">/* 参数 */</span></span><br><span class="line">    <span class="keyword">int</span> argc;       <span class="comment">/* 参数数量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span>   <span class="comment">/* 命令本身 */</span></span><br><span class="line">&#125; multiCmd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">/* 事务命令队列 */</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">/* 队列中命令的数量 */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">int</span> minreplicas;        <span class="comment">/* 需要同步复制的最小数量 */</span></span><br><span class="line">    <span class="keyword">time_t</span> minreplicas_timeout; <span class="comment">/* 同步复制超时时间 */</span></span><br><span class="line">&#125; multiState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视列表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchedKey</span> &#123;</span></span><br><span class="line">    robj *key;      <span class="comment">/* watch的key*/</span></span><br><span class="line">    redisDb *db;    <span class="comment">/* 指向的db */</span></span><br><span class="line">&#125; watchedKey;</span><br></pre></td></tr></table></figure><p>需要注意的是，客户端打开事务操作标识后，只有命令：EXEC、DISCARD、WATCH、MULTI命令会被立即执行，该逻辑在server.c文件中的processCommand方法中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Exec the command */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将命令插入队列</span></span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 立即执行</span></span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将命令插入队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    multiCmd *mc;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">            <span class="keyword">sizeof</span>(multiCmd)*(c-&gt;mstate.count+<span class="number">1</span>));</span><br><span class="line">    mc = c-&gt;mstate.commands+c-&gt;mstate.count;</span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv,c-&gt;argv,<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        incrRefCount(mc-&gt;argv[j]);</span><br><span class="line">    c-&gt;mstate.count++;</span><br><span class="line">    c-&gt;mstate.cmd_flags |= c-&gt;cmd-&gt;flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们考虑一下watch机制的触发时机，现在我们已经把想要watch的key加入到了watch的数据结构中，可以想到触发watch的时机应该是修改key的内容时，通知到所有watch了该key的客户端。该触发机制的源码在multi.c文件的<code>touchWatchedKey()</code>函数中实现。</p><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 设置客户端事务标识</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 执行命令队列中的命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 取消事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 监视一个或多个key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// 取消监视</span></span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>事务开始：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;MULTI calls can not be nested&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置客户端的事务标识</span></span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行事务：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> must_propagate = <span class="number">0</span>; <span class="comment">// 标记是否需要把MULTI/EXEC传递到AOF或者slaves节点</span></span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>; <span class="comment">// 标记当前redis节点是否为主节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有处于事务状态，则返回错误提示信息</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;EXEC without MULTI&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先对两个需要终止当前事务的条件进行判断:</span></span><br><span class="line"><span class="comment">     * 1) 当有WATCH的key被修改时则终止，返回一个nullmultibulk对象</span></span><br><span class="line"><span class="comment">     * 2) 当之前有命令加入事务命令数组出错则终止，例如传入的命令参数数量不对，会返回execaborterr */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">        addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                                                   shared.nullarray[c-&gt;resp]);</span><br><span class="line">        <span class="comment">// 删除当前事务信息</span></span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">goto</span> handle_monitor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果事务命令中有写的操作，并且当前redis节点为只读slave节点，将返回错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (!server.loading &amp;&amp; server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; c-&gt;mstate.cmd_flags &amp; CMD_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;Transaction contains write commands but instance &quot;</span></span><br><span class="line">            <span class="string">&quot;is now a read-only replica. EXEC aborted.&quot;</span>);</span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">goto</span> handle_monitor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行队列中的所有命令 */</span></span><br><span class="line">    unwatchAllKeys(c); <span class="comment">/* 把watch的key都删除 */</span></span><br><span class="line">    <span class="comment">// 保存当前命令上下文</span></span><br><span class="line">    orig_argv = c-&gt;argv;</span><br><span class="line">    orig_argc = c-&gt;argc;</span><br><span class="line">    orig_cmd = c-&gt;cmd;</span><br><span class="line">    addReplyArrayLen(c,c-&gt;mstate.count);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 同步事务操作到AOF或者集群中的从节点. */</span></span><br><span class="line">        <span class="keyword">if</span> (!must_propagate &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; (CMD_READONLY|CMD_ADMIN))) &#123;</span><br><span class="line">            execCommandPropagateMulti(c);</span><br><span class="line">            must_propagate = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> acl_keypos;</span><br><span class="line">        <span class="keyword">int</span> acl_retval = ACLCheckCommandPerm(c,&amp;acl_keypos);</span><br><span class="line">        <span class="keyword">if</span> (acl_retval != ACL_OK) &#123;</span><br><span class="line">            addACLLogEntry(c,acl_retval,acl_keypos,<span class="literal">NULL</span>);</span><br><span class="line">            addReplyErrorFormat(c,</span><br><span class="line">                <span class="string">&quot;-NOPERM ACLs rules changed between the moment the &quot;</span></span><br><span class="line">                <span class="string">&quot;transaction was accumulated and the EXEC call. &quot;</span></span><br><span class="line">                <span class="string">&quot;This command is no longer allowed for the &quot;</span></span><br><span class="line">                <span class="string">&quot;following reason: %s&quot;</span>,</span><br><span class="line">                (acl_retval == ACL_DENIED_CMD) ?</span><br><span class="line">                <span class="string">&quot;no permission to execute the command or subcommand&quot;</span> :</span><br><span class="line">                <span class="string">&quot;no permission to touch the specified keys&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            call(c,server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 由于命令可以修改参数的值或者数量，因此重新保存命令上下文 */</span></span><br><span class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复原始命令上下文</span></span><br><span class="line">    c-&gt;argv = orig_argv;</span><br><span class="line">    c-&gt;argc = orig_argc;</span><br><span class="line">    c-&gt;cmd = orig_cmd;</span><br><span class="line">    <span class="comment">// 事务执行完成，删除该事务</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保EXEC会进行传递 */</span></span><br><span class="line">    <span class="keyword">if</span> (must_propagate) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog &amp;&amp; was_master &amp;&amp; !is_master) &#123;</span><br><span class="line">            <span class="keyword">char</span> *execcmd = <span class="string">&quot;*1\r\n$4\r\nEXEC\r\n&quot;</span>;</span><br><span class="line">            feedReplicationBacklog(execcmd,<span class="built_in">strlen</span>(execcmd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">handle_monitor:</span><br><span class="line">    <span class="comment">/* monitor命令操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp; !server.loading)</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取消事务：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;DISCARD without MULTI&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的删除逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="comment">// 状态位还原</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);</span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放事务中的所有命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeClientMultiState</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        multiCmd *mc = c-&gt;mstate.commands+j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mc-&gt;argc; i++)</span><br><span class="line">            decrRefCount(mc-&gt;argv[i]);</span><br><span class="line">        zfree(mc-&gt;argv);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(c-&gt;mstate.commands);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事务相关字段设为初始值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initClientMultiState</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;mstate.commands = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;mstate.count = <span class="number">0</span>;</span><br><span class="line">    c-&gt;mstate.cmd_flags = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>watch监视：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;WATCH inside MULTI is not allowed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        watchForKey(c,c-&gt;argv[j]);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    watchedKey *wk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断key是否已经被watch过 */</span></span><br><span class="line">    listRewind(c-&gt;watched_keys,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key,wk-&gt;key))</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果未被watch，则将key加入到列表中</span></span><br><span class="line"><span class="comment">     * 整个watch操作保存了两套数据结构，一套是在db-&gt;watched_keys中的字典结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys,key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) &#123;</span><br><span class="line">        clients = listCreate();</span><br><span class="line">        dictAdd(c-&gt;db-&gt;watched_keys,key,clients);</span><br><span class="line">        incrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    listAddNodeTail(clients,c);</span><br><span class="line">    <span class="comment">/* 另一套是在c-&gt;watched_keys中的链表结构 */</span></span><br><span class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</span><br><span class="line">    wk-&gt;key = key;</span><br><span class="line">    wk-&gt;db = c-&gt;db;</span><br><span class="line">    incrRefCount(key);</span><br><span class="line">    listAddNodeTail(c-&gt;watched_keys,wk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unwatch取消监视：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">    <span class="comment">// 修改客户端状态</span></span><br><span class="line">    c-&gt;flags &amp;= (~CLIENT_DIRTY_CAS);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unwatchAllKeys</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="comment">// 如果客户端没有watch任何key，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    listRewind(c-&gt;watched_keys,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        <span class="built_in">list</span> *clients;</span><br><span class="line">        watchedKey *wk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 遍历取出该客户端watch的key */</span></span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        clients = dictFetchValue(wk-&gt;db-&gt;watched_keys, wk-&gt;key);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,clients != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,listSearchKey(clients,c));</span><br><span class="line">        <span class="comment">/* Kill the entry at all if this was the only client */</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>)</span><br><span class="line">            dictDelete(wk-&gt;db-&gt;watched_keys, wk-&gt;key);</span><br><span class="line">        <span class="comment">/* Remove this watched key from the client-&gt;watched list */</span></span><br><span class="line">        listDelNode(c-&gt;watched_keys,ln);</span><br><span class="line">        decrRefCount(wk-&gt;key);</span><br><span class="line">        zfree(wk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：multi.c/redis.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 简介&lt;/strong&gt;&lt;br&gt;Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;br&gt;总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="3-database" scheme="https://blog.grizzlys.top/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-发布和订阅</title>
    <link href="https://blog.grizzlys.top/Redis/3-database/redis-parse-pubsub/"/>
    <id>https://blog.grizzlys.top/Redis/3-database/redis-parse-pubsub/</id>
    <published>2020-06-28T03:15:52.000Z</published>
    <updated>2021-07-08T02:33:40.874Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：pubsub.c/redis.h</p><p><strong>1. 前言</strong><br>Redis发布订阅(pub/sub)是一种消息通信模式，由三部分组成：发布者(pub)，频道(channel)，订阅者(sub)。具体结构如下：</p><a id="more"></a><p><img src="https://i.loli.net/2020/10/29/ujSpaOfrmVAbRyd.png" alt="pubsub1.png"><br>发布者和订阅者都是Redis客户端，频道是Redis服务端，发布者将消息发布到某一频道上，订阅了这一频道的订阅者就会收到该条信息。Redis客户端可订阅任意数量的频道。<br>Redis的发布订阅功能并不保证可靠，因为所有数据都存在内存中，没有提供持久化的功能，也不记录消费端状态，所以相对市面上的一些消息队列相比（如kafka、rabittMQ等），可靠性会差很多。在Redis5.0版本的stream消息队列功能发布之前，会有使用者使用redis-list来实现消息队列和发布订阅的功能，虽然有持久化（AOF &amp; RDB）的功能，但是实现起来比较笨拙，不够方便。</p><p>pubsub与stream比较：</p><div class="table-container"><table><thead><tr><th>pub/sub</th><th>stream</th></tr></thead><tbody><tr><td>不能持久化消息</td><td>可以持久化，支持RDB和AOF两种持久化机制</td></tr><tr><td>没有消息队列中群组的概念</td><td>引入了消费组的概念</td></tr><tr><td>redis客户端断线重连会丢失中间的数据</td><td>支持position，能够消费历史消息。断线后支持消息继续从上次的时间点读取，不会丢失消息，也可以直接读取最新消息</td></tr><tr><td>redis断线后需要重新订阅</td><td></td><td>不存在这个问题</td></tr><tr><td>没有ack机制</td><td>有ACK机制，能够一定程度保证消息“at least once” 消费</td></tr></tbody></table></div><p>基于stream消息队列的多种好处，pub/sub功能仅做源码学习，实际项目中推荐使用stream或者kafka等消息队列。</p><p><strong>2. 命令介绍</strong><br>下面介绍命令的使用详情：</p><ul><li>PSUBSCRIBE pattern [pattern1 ….]<ul><li>说明：订阅一个或多个符合给定模式的频道，每个模式以*作为匹配符</li><li>参数：pattern(给定的模式)</li><li>返回：接受到的信息</li></ul></li><li>PUNSUBSCRIBE pattern [pattern1 ….]<ul><li>说明：用于退订所有给定模式的频道</li><li>参数：pattern(给定的模式)</li><li>返回：这个命令在不同的客户端中有不同的表现。</li></ul></li><li>SUBSCRIBE channel [channel1 …]<ul><li>说明：用于订阅给定的一个或多个频道的信息</li><li>参数：channel(给定的频道名)</li><li>返回：接收到的信息</li></ul></li><li>UNSUBSCRIBE channel [channel1 …]<ul><li>说明：用于退订给定的一个或多个频道的信息</li><li>参数：channel(给定的频道名)</li><li>返回：这个命令在不同的客户端中有不同的表现</li></ul></li><li>PUBLISH channel message<ul><li>说明：用于将信息发送到指定的频道</li><li>参数：channel(频道名称)，message(将要发送的信息)</li><li>返回：接收到此消息的订阅者数量</li></ul></li><li>PUBSUB &lt; subcommand &gt; argument [argument1 ….]<ul><li>说明：用于查看订阅与发布系统状态，它由数个不同格式的子命令组成</li><li>参数：subcommand(子命令)，argument(子命令参数)</li><li>返回：由活跃频道组成的列表</li></ul></li></ul><p>子命令如下：</p><div class="table-container"><table><thead><tr><th>subcommand</th><th>argument</th><th>说明</th></tr></thead><tbody><tr><td>CHANNELS</td><td>[pattern]</td><td>返回指定模式pattern的活跃的频道,指定返回由SUBSCRIBE订阅的频道</td></tr><tr><td>NUMSUB</td><td>channel channel2 …</td><td>返回指定频道的订阅数量</td></tr><tr><td>NUMPAT</td><td></td><td>返回订阅模式的数量，注意：这个命令返回的不是订阅模式的客户端的数量， 而是客户端订阅的所有模式的数量总和</td></tr></tbody></table></div><p><strong>3. 实现原理</strong><br>每个 Redis 服务器进程维持着一个标识服务器状态 的 redis.h/redisServer 结构，其中就 保存着有订阅的频道 以及 订阅模式 的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Pubsub */</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* 订阅频道（字典数据结构） */</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* 订阅模式（列表结构） */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* 该客户端订阅的频道 */</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* 该客户端订阅的模式 */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.在Redis服务端内部维护了一个 <code>pubsub_channels</code> 的channel列表，记录了此客户端所订阅的频道。</p><p>2.当客户端订阅某一个频道之后，Redis服务端就会往自身的 <code>pubsub_channels</code> 这个字典变量中新添加一条数据，实际上这个 dict 字典维护的是一张链表，比如，下图展示的 pubsub_channels 示例中，client 1、client 2 就订阅了 channel 1，而其他频道也分别被其他客户端订阅：<br><img src="https://i.loli.net/2020/10/29/WBJRmu3PDoazsct.png" alt="pubsub2.png"></p><p>3.当一个Redis客户端publish一个message的时候，会先去服务端的 <code>pubsub_channels</code> 找相应的channel，遍历里面的client，然后发送通知，即完成了整个发布订阅的流程。</p></blockquote><p>下面我们通过代码来看看pub/sub的实现吧。</p><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pubsub commands implementation */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于订阅给定的一个或多个频道的信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于退订给定的一个或多个频道的信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psubscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 订阅一个或多个符合给定模式的频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">punsubscribeCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于退订所有给定模式的频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于将信息发送到指定的频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pubsubCommand</span><span class="params">(client *c)</span></span>; <span class="comment">/* 用于查看订阅与发布系统状态 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pubsub low level API */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freePubsubPattern</span><span class="params">(<span class="keyword">void</span> *p)</span></span>; <span class="comment">/* 释放发布订阅的模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listMatchPubsubPattern</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span>; <span class="comment">/* 发布订阅模式是否匹配 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clientSubscriptionsCount</span><span class="params">(redisClient *c)</span></span>; <span class="comment">/* 返回客户端的所订阅的数量，包括channels + patterns频道和模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(redisClient *c, robj *channel)</span></span>; <span class="comment">/* Client订阅一个Channel频道 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeChannel</span><span class="params">(redisClient *c, robj *channel, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* 取消订阅Client中的Channel */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribePattern</span><span class="params">(redisClient *c, robj *pattern)</span></span>; <span class="comment">/* Client客户端订阅一种模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribePattern</span><span class="params">(redisClient *c, robj *pattern, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* Client客户端取消订阅pattern模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllChannels</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* 客户端取消自身订阅的所有Channel */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllPatterns</span><span class="params">(redisClient *c, <span class="keyword">int</span> notify)</span></span>; <span class="comment">/* 客户端取消订阅所有的pattern模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span></span>; <span class="comment">/* 为所有订阅了Channel的Client发送消息message */</span></span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>Redis客户端订阅频道：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        pubsubSubscribeChannel(c,c-&gt;argv[j]);</span><br><span class="line">    <span class="comment">// 添加pubsub订阅标识，方便其他地方判断</span></span><br><span class="line">    c-&gt;flags |= CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(client *c, robj *channel)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step.1 将要订阅的 channel 添加到各自客户端的 pubsub_channels 容器中 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(c-&gt;pubsub_channels,channel,<span class="literal">NULL</span>) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        incrRefCount(channel);</span><br><span class="line">        <span class="comment">/* step.2 将要订阅的channel 添加到 server.pubsub_channels 中, 方便在publish时判定是否触发通知 */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果此频道的client列表为空，则创建新列表并添加</span></span><br><span class="line">            clients = listCreate();</span><br><span class="line">            dictAdd(server.pubsub_channels,channel,clients);</span><br><span class="line">            incrRefCount(channel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，获取频道的客户端列表，在尾部添加新的元素</span></span><br><span class="line">            clients = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* step.3 将客户端自身添加到相应的 server.pubsub_channels 对应的队列中去, 在通知时只需遍历该队列即可 */</span></span><br><span class="line">        listAddNodeTail(clients,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 回复客户端 */</span></span><br><span class="line">    addReplyPubsubSubscribed(c,channel);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端订阅的总channel数, 两种订阅方式相加</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clientSubscriptionsCount</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictSize(c-&gt;pubsub_channels)+</span><br><span class="line">           listLength(c-&gt;pubsub_patterns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>客户端自行管理需要订阅的channel, 放到 c-&gt;pubsub_channels 中;</li><li>redis使用的一个统一的 server-&gt;pubsub_channels dict容器进行管理所有的channel;</li><li>对于多个客户端订阅一个channel, redis 使用list进行管理追加;</li></ol><p><strong>Redis客户端退订频道：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">        pubsubUnsubscribeAllChannels(c,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">            pubsubUnsubscribeChannel(c,c-&gt;argv[j],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 退订所有频道，返回退订的数目 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeAllChannels</span><span class="params">(client *c, <span class="keyword">int</span> notify)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = dictGetSafeIterator(c-&gt;pubsub_channels);</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历该客户端订阅的所有频道并退订</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *channel = dictGetKey(de);</span><br><span class="line"></span><br><span class="line">        count += pubsubUnsubscribeChannel(c,channel,notify);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We were subscribed to nothing? Still reply to the client. */</span></span><br><span class="line">    <span class="keyword">if</span> (notify &amp;&amp; count == <span class="number">0</span>) addReplyPubsubUnsubscribed(c,<span class="literal">NULL</span>);</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubUnsubscribeChannel</span><span class="params">(client *c, robj *channel, <span class="keyword">int</span> notify)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从client.pubsub_channels中移除频道 */</span></span><br><span class="line">    incrRefCount(channel);</span><br><span class="line">    <span class="keyword">if</span> (dictDelete(c-&gt;pubsub_channels,channel) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 从server.pubsub_channels中移除频道 */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</span><br><span class="line">        clients = dictGetVal(de);</span><br><span class="line">        ln = listSearchKey(clients,c);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,ln);</span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果列表中没有数据了，就移除频道列表</span></span><br><span class="line">            dictDelete(server.pubsub_channels,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (notify) addReplyPubsubUnsubscribed(c,channel);</span><br><span class="line">    decrRefCount(channel); <span class="comment">/* it is finally safe to release it */</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：pubsub.c/redis.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br&gt;Redis发布订阅(pub/sub)是一种消息通信模式，由三部分组成：发布者(pub)，频道(channel)，订阅者(sub)。具体结构如下：&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="3-database" scheme="https://blog.grizzlys.top/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-AOF持久化</title>
    <link href="https://blog.grizzlys.top/Redis/3-database/redis-parse-aof/"/>
    <id>https://blog.grizzlys.top/Redis/3-database/redis-parse-aof/</id>
    <published>2020-06-10T12:12:52.000Z</published>
    <updated>2021-07-08T02:33:40.864Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：aof.c/rio.c/rio.h</p><p><strong>1. 前言</strong><br>除了RDB持久化功能以外，Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis所执行的写命令来记录数据库状态的。</p><a id="more"></a><p><strong>2. RDB和AOF的区别</strong><br>antirez 在《Redis 持久化解密》一文中讲述了 RDB 和 AOF 各自的优缺点：</p><ul><li>RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据备份。非常适合备份，全量复制等场景。比如每6小时执行 bgsave 备份，并把 RDB 文件拷贝到远程机器或者文件系统中，用于灾难恢复。</li><li>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</li><li>RDB 方式数据没办法做到实时持久化，而 AOF 方式可以做到。</li></ul><p><strong>3. AOF持久化的实现</strong><br><img src="https://i.loli.net/2020/10/29/92WBXYbOpDcl7aJ.png" alt="aof1.png"><br>如上图所示，AOF 持久化功能的实现可以分为命令追加( append )、文件写入( write )、文件同步( sync )、文件重写(rewrite)和重启加载(load)。其流程如下：</p><ul><li>所有的写命令会追加到 AOF 缓冲中。</li><li>AOF 缓冲区根据对应的策略向硬盘进行同步操作。</li><li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li><li>当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li></ul><p><strong>命令追加</strong><br>当 AOF 持久化功能处于打开状态（配置文件中：<code>appendonly yes</code>）时，Redis 在执行完一个写命令之后，调用<code>feedAppendOnlyFile</code>函数，以协议格式(也就是RESP，即 Redis 客户端和服务器交互的通信协议 )将被执行的写命令追加到 Redis 服务端维护的 AOF 缓冲区末尾（sds类型变量：<code>aof_buf</code>）。</p><p>比如说 SET mykey myvalue 这条命令就以如下格式记录到 AOF 缓冲中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;</span></span><br></pre></td></tr></table></figure><p><strong>文件写入与同步</strong><br>Redis的服务器进程是一个事件循环，文件事件负责处理客户端的命令请求，而时间事件负责执行<code>serverCron</code>函数这样的定时运行的函数。在处理文件事件执行写命令，使得命令被追加到<code>aof_buf</code>中，然后在处理时间事件执行<code>serverCron</code>函数会调用<code>flushAppendOnlyFile</code>函数进行文件的写入和同步。<br>flushAppendOnlyFile函数的行为由服务器配置的<code>appendfsync</code>选项的值决定，该选项有三个可选值，分别是<code>always</code>、<code>everysec</code> 和 <code>no</code>：</p><ul><li><strong>always： 每执行一个命令保存一次。</strong> Redis 在每个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件，并且同步 AOF 文件，所以 always 的效率是 appendfsync 选项三个值当中最差的一个，但从安全性来说，也是最安全的。当发生故障停机时，AOF 持久化也只会丢失一个事件循环中所产生的命令数据。</li><li><strong>everysec： 每一秒钟保存一次。</strong> Redis 在每个事件循环都要将 AOF 缓冲区中的所有内容写入到 AOF 文件中，并且每隔一秒就要在子线程中对 AOF 文件进行一次同步。从效率上看，该模式足够快。当发生故障停机时，只会丢失一秒钟的命令数据。</li><li><strong>no：不保存。</strong> 将aof_buf中的所有内容写入到aof文件，但不对aof文件同步，<code>fsync</code> 由操作系统执行。</li></ul><p>Redis的 <code>write</code> 操作会触发延迟写（delayed write）机制，在同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</p><blockquote><p><strong>延迟写机制：</strong> 传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。 当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则 并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时， 再将该缓冲排入到输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式就被称为延迟写。</p></blockquote><p>而 <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</p><p>三种AOF模式在安全性和性能方面的区别如下：</p><ul><li><strong>no：</strong> <code>write</code> 和 <code>fsync</code> 都由主进程执行，两个操作都会阻塞主进程。因为 <code>fsync</code> 操作只会在AOF 关闭或 Redis 关闭时执行，或者由操作系统触发。所以当系统故障宕机，那么丢失数据的数量由操作系统的缓存冲洗策略决定。</li><li><strong>always：</strong> 该模式的安全性最高，但性能也是最差的，因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后，才能继续处理请求。</li><li><strong>everysec：</strong> <code>write</code> 操作由主进程执行，阻塞主进程。<code>fsync</code> 操作由子线程执行，不直接阻塞主进程，但<code>fsync</code> 操作完成的快慢会影响 <code>write</code> 操作的阻塞时长。因为是一秒执行一次，所以它的安全性高于<code>no</code>模式，系统故障宕机将会丢失一秒钟的命令数据。</li></ul><p><code>appendfsync</code> 的三个值代表着三种不同的调用 <code>fsync</code> 的策略。调用 <code>fsync</code> 周期越频繁，读写效率就越差，但是相应的安全性越高，发生宕机时丢失的数据越少。</p><p><strong>4. AOF数据恢复</strong><br>AOF文件中包含了重建Redis数据所需的所有命令，所以Redis只要读入并重新执行一遍 AOF 文件里边保存的写命令，就可以还原 Redis 关闭之前的状态。<br><img src="https://i.loli.net/2020/10/29/RvlhedCqP6ywjNb.png" alt="aof2.png"></p><p><strong>5. AOF重写</strong><br>因为AOF持久化是通过保存被执行的写命令来记录Redis状态的，所以随着Redis长时间运行，AOF文件中的内容越来越多，文件的体积也会越来越大，如果不加以控制，Redis通过AOF文件还原数据库需要的时间将会变得很久，同时AOF文件很可能会对Redis甚至宿主主机造成影响。<br>为了解决上诉问题，Redis提供了AOF文件重写（rewrite）功能。通过该功能，Redis 可以创建一个新的 AOF 文件来替代现有的 AOF 文件。新旧两个 AOF 文件所保存的 Redis 状态相同，但是新的 AOF 文件不会包含任何浪费空间的冗余命令，所以新 AOF 文件的体积通常比旧 AOF 文件的体积要小得很多。</p><blockquote><p>例如：<br>重写前AOF文件命令记录:<br>RPUSH list “A”,”B”<br>RPUSH list “C”,”D”<br>LPOP list<br>LPOP list<br>RPUSH list “E”,”F”</p><p>重写后AOF文件命令记录：<br>RPUSH list “C”,”D”,”E”,”F”</p></blockquote><p>如上所示，重写前，AOF文件要保存5条命令，重写后只需要保存一条，所以重写后的文件要小很多。</p><p><strong>AOF重写实现</strong><br>AOF文件重写通过 <code>rewriteAppendOnlyFileBackground()</code> 实现，重写不需要对现有的AOF文件进行任何读取、分析或者写入操作，而是读取服务器当前的数据库状态来实现的（<code>rewriteAppendOnlyFileRio()</code>）。首先从数据库中读取键对应的值，然后用一条命令去记录键值对，代替之前的多条命令，这就是AOF重写功能实现。</p><p>在实际过程中，为了避免在执行命令时造成客户端输入缓冲区溢出，AOF 重写在处理列表、哈希表、集合和有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果数量超<code>REDIS_AOF_REWRITE_ITEMS_PER_CMD</code> ( 一般为64 )常量，则使用多条命令记录该键的值，而不是一条命令。</p><p>AOF重写函数会进行大量的写入操作，调用该函数的线程将被长时间阻塞，所以Redis在子进程中执行AOF重写操作。</p><ul><li>子进程重写期间，主线程可以继续处理客户端命令请求。</li><li>子进程带有主线程的内存数据拷贝副本，这样就可以避免与主进程竞争db-&gt;dict，在不用锁的情况下，也能保证数据的安全性。</li></ul><p>AOF重写期间，主进程依然能接收处理命令，会对现有的Redis数据库进行修改，从而导致AOF重写后的数据与现有的数据库数据不一致。因此，Redis设置了AOF重写缓冲区，在创建子进程后，主进程每执行一个写命令都会写到缓冲区中。在子进程完成重写后，主进程会将AOF重写缓冲区的数据写入到重写后的AOF文件中，以此保证数据的一致性。</p><h2 id="函数主要功能"><a href="#函数主要功能" class="headerlink" title="函数主要功能"></a>函数主要功能</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span></span>; <span class="comment">// 将缓冲区的数据刷入到磁盘文件中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span></span>; <span class="comment">// 将写操作的数据添加到AOF缓冲区末尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// AOF文件重写</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span></span>; <span class="comment">// 加载AOF文件恢复数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopAppendOnly</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 停止</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startAppendOnly</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundRewriteDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span></span>; <span class="comment">// 子进程重写完成信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofRewriteBufferReset</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 清空AOF重写缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">aofRewriteBufferSize</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取AOF重写缓冲区的大小</span></span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>写操作命令追加到AOF缓冲区：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">    sds buf = sdsempty();</span><br><span class="line">    robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换dbid，追加select命令</span></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">&quot;%d&quot;</span>,dictid);</span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">&quot;*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        server.aof_selected_db = dictid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        <span class="comment">/* 将EXPIRE/PEXPIRE/EXPIREAT转化成PEXPIREAT生成命令协议格式的字符串 */</span></span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</span><br><span class="line">        <span class="comment">/* 将SETEX/PSETEX转换成SET和PEXPIREAT生成命令协议格式的字符串 */</span></span><br><span class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">&quot;SET&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv);</span><br><span class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        robj *exarg = <span class="literal">NULL</span>, *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,argv);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">&quot;ex&quot;</span>)) exarg = argv[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">&quot;px&quot;</span>)) pxarg = argv[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        serverAssert(!(exarg &amp;&amp; pxarg));</span><br><span class="line">        <span class="keyword">if</span> (exarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               exarg);</span><br><span class="line">        <span class="keyword">if</span> (pxarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               pxarg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 将写命令生成命令协议格式的字符串 */</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将命令的协议格式的字符串追加到aof_buf */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前正在做AOF重写，则将命令的协议格式的字符串追加到AOF重写缓存区 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AOF缓冲区的数据刷入到AOF文件中：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">            server.aof_fsync_offset != server.aof_current_size &amp;&amp;</span><br><span class="line">            server.unixtime &gt; server.aof_last_fsync &amp;&amp;</span><br><span class="line">            !(sync_in_progress = aofFsyncInProgress())) &#123;</span><br><span class="line">            <span class="keyword">goto</span> try_fsync;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">        <span class="comment">// 如果AOF fsync当前已在BIO线程中进行返回true</span></span><br><span class="line">        sync_in_progress = aofFsyncInProgress();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">        <span class="comment">/* 使用这个append fsync策略，我们进行后台fsync。如果fsync仍在进行中，我们可以尝试将写入延迟几秒钟。 */</span></span><br><span class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_delayed_fsync++;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_flush_sleep &amp;&amp; sdslen(server.aof_buf)) &#123;</span><br><span class="line">        usleep(server.aof_flush_sleep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将aof_buf中的内容写入到AOF文件中</span></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-pending-fsync&quot;</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasActiveChildProcess()) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-active-child&quot;</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-alone&quot;</span>,latency);</span><br><span class="line">    &#125;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;aof-write&quot;</span>,latency);</span><br><span class="line"></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">ssize_t</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">            can_log = <span class="number">1</span>;</span><br><span class="line">            last_write_error_log = server.unixtime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error writing to the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">                server.aof_last_write_errno = errno;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Short write while writing to &quot;</span></span><br><span class="line">                                       <span class="string">&quot;the AOF file: (nwritten=%lld, &quot;</span></span><br><span class="line">                                       <span class="string">&quot;expected=%lld)&quot;</span>,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                    serverLog(LL_WARNING, <span class="string">&quot;Could not remove short write &quot;</span></span><br><span class="line">                             <span class="string">&quot;from the append-only file.  Redis may refuse &quot;</span></span><br><span class="line">                             <span class="string">&quot;to load the AOF the next time it starts.  &quot;</span></span><br><span class="line">                             <span class="string">&quot;ftruncate: %s&quot;</span>, strerror(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nwritten = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_last_write_errno = ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t recover from AOF write error when the AOF fsync policy is &#x27;always&#x27;. Exiting...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            server.aof_last_write_status = C_ERR;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_current_size += nwritten;</span><br><span class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;AOF write error looks solved, Redis can write again.&quot;</span>);</span><br><span class="line">            server.aof_last_write_status = C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server.aof_current_size += nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">        sdsclear(server.aof_buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sdsfree(server.aof_buf);</span><br><span class="line">        server.aof_buf = sdsempty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">try_fsync:</span><br><span class="line">    <span class="comment">// appendfsync为no或者有后台进程在进行aof或rdb，不进行文件同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp; hasActiveChildProcess())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        redis_fsync(server.aof_fd); <span class="comment">/* Let&#x27;s try to get this data on the disk */</span></span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-fsync-always&quot;</span>,latency);</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) &#123;</span><br><span class="line">            aof_background_fsync(server.aof_fd);</span><br><span class="line">            server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        &#125;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AOF重写：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR; <span class="comment">//创建父进程与子进程的管道</span></span><br><span class="line">    openChildInfoPipe();</span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">        <span class="comment">// 通过子进程来重写AOF文件</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            sendChildCOWInfo(CHILD_INFO_TYPE_AOF, <span class="string">&quot;AOF rewrite&quot;</span>);</span><br><span class="line">            exitFromChild(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exitFromChild(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t rewrite append only file in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            aofClosePipes();</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Background append only file rewriting started by pid %d&quot;</span>,childpid);</span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        server.aof_rewrite_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AOF重写实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    rio aof;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> byte;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-%d.aof&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">&quot;Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.aof_child_diff = sdsempty();</span><br><span class="line">    rioInitWithFile(&amp;aof,fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_rewrite_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;aof,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    startSaving(RDBFLAGS_AOF_PREAMBLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_use_rdb_preamble) &#123;</span><br><span class="line">        <span class="keyword">int</span> error;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveRio(&amp;aof,&amp;error,RDBFLAGS_AOF_PREAMBLE,<span class="literal">NULL</span>) == C_ERR) &#123;</span><br><span class="line">            errno = error;</span><br><span class="line">            <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取Redis数据库状态进行重写操作</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据刷入到新的AOF文件中</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从父进程的重写缓冲区获取更多数据，如果20ms内没有新数据，则退出循环 */</span></span><br><span class="line">    <span class="keyword">int</span> nodata = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> start = mstime();</span><br><span class="line">    <span class="keyword">while</span>(mstime()-start &lt; <span class="number">1000</span> &amp;&amp; nodata &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodata++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodata = <span class="number">0</span>;</span><br><span class="line">        aofReadDiffFromParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 请求主进程停止发送差异. */</span></span><br><span class="line">    <span class="keyword">if</span> (write(server.aof_pipe_write_ack_to_parent,<span class="string">&quot;!&quot;</span>,<span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,server.aof_pipe_read_ack_from_parent) != ANET_OK)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">/* 设定10秒超时时间来接受主进程的相应 */</span></span><br><span class="line">    <span class="keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,<span class="number">1</span>,<span class="number">5000</span>) != <span class="number">1</span> ||</span><br><span class="line">        byte != <span class="string">&#x27;!&#x27;</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Parent agreed to stop sending diffs. Finalizing AOF...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取最终差异. */</span></span><br><span class="line">    aofReadDiffFromParent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将接收到的差异写入文件中 */</span></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">&quot;Concatenating %.2f MB of AOF diff received from parent.&quot;</span>,</span><br><span class="line">        (<span class="keyword">double</span>) sdslen(server.aof_child_diff) / (<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保数据不会保留在操作系统的输出缓冲区中 */</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重命名. */</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error moving temp append only file on the final destination: %s&quot;</span>, strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        stopSaving(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;SYNC append only file rewrite performed&quot;</span>);</span><br><span class="line">    stopSaving(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error writing append only file on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    stopSaving(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从AOF文件中恢复数据：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span> *<span class="title">fakeClient</span>;</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redis_stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">int</span> old_aof_state = server.aof_state;</span><br><span class="line">    <span class="keyword">long</span> loops = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> valid_up_to = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> valid_before_multi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal error: can&#x27;t open the append log file for reading: %s&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理长度为0的AOF文件，服务启动后，如果没有写操作，则AOF文件的长度为0，是特殊情况 */</span></span><br><span class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_current_size = <span class="number">0</span>;</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 暂时禁用AOF，以防止读取同一文件的同时，有客户端进行写操作命令 */</span></span><br><span class="line">    server.aof_state = AOF_OFF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建伪客户端</span></span><br><span class="line">    fakeClient = createAOFClient();</span><br><span class="line">    <span class="comment">// 开始加载文件的初始化工作</span></span><br><span class="line">    startLoadingFile(fp, filename, RDBFLAGS_AOF_PREAMBLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查这个AOF文件是否有RDB前导码。在这种情况下，我们需要加载RDB文件，然后继续加载AOF tail. */</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">5</span>]; <span class="comment">/* &quot;REDIS&quot; */</span></span><br><span class="line">    <span class="keyword">if</span> (fread(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rio rdb;</span><br><span class="line"></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Reading RDB preamble from AOF file...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">        <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,RDBFLAGS_AOF_PREAMBLE,<span class="literal">NULL</span>) != C_OK) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Reading the remaining AOF tail...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析AOF文件内容. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> argc, j;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">        robj **argv;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        sds argsds;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Serve the clients from time to time */</span></span><br><span class="line">        <span class="keyword">if</span> (!(loops++ % <span class="number">1000</span>)) &#123;</span><br><span class="line">            loadingProgress(ftello(fp));</span><br><span class="line">            processEventsWhileBlocked();</span><br><span class="line">            processModuleLoadingProgressEvent(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (feof(fp))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        argc = atoi(buf+<span class="number">1</span>); <span class="comment">// 命令的参数个数</span></span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line"></span><br><span class="line">        argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*argc);</span><br><span class="line">        fakeClient-&gt;argc = argc;</span><br><span class="line">        fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">            <span class="comment">/* 解析参数长度. */</span></span><br><span class="line">            <span class="keyword">char</span> *readres = fgets(buf,<span class="keyword">sizeof</span>(buf),fp);</span><br><span class="line">            <span class="keyword">if</span> (readres == <span class="literal">NULL</span> || buf[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">if</span> (readres == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">goto</span> readerr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">goto</span> fmterr;</span><br><span class="line">            &#125;</span><br><span class="line">            len = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            argsds = sdsnewlen(SDS_NOINIT,len);</span><br><span class="line">            <span class="keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                sdsfree(argsds);</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            argv[j] = createObject(OBJ_STRING,argsds);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fread(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j+<span class="number">1</span>; <span class="comment">/* Free up to j. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 执行命令 */</span></span><br><span class="line">        cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Unknown command &#x27;%s&#x27; reading the append only file&quot;</span>,</span><br><span class="line">                (<span class="keyword">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == server.multiCommand) valid_before_multi = valid_up_to;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在伪客户端中执行该命令 */</span></span><br><span class="line">        fakeClient-&gt;cmd = cmd;</span><br><span class="line">        <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">            fakeClient-&gt;cmd-&gt;proc != execCommand)</span><br><span class="line">        &#123;</span><br><span class="line">            queueMultiCommand(fakeClient);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmd-&gt;proc(fakeClient);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverAssert(fakeClient-&gt;bufpos == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     listLength(fakeClient-&gt;reply) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 清理伪客户端中的命令. */</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        fakeClient-&gt;cmd = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_load_truncated) valid_up_to = ftello(fp);</span><br><span class="line">        <span class="keyword">if</span> (server.key_load_delay)</span><br><span class="line">            usleep(server.key_load_delay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Revert incomplete MULTI/EXEC transaction in AOF file&quot;</span>);</span><br><span class="line">        valid_up_to = valid_before_multi;</span><br><span class="line">        <span class="keyword">goto</span> uxeof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">loaded_ok: <span class="comment">/* DB loaded, cleanup and return C_OK to the caller. */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    freeFakeClient(fakeClient);</span><br><span class="line">    server.aof_state = old_aof_state;</span><br><span class="line">    stopLoading(<span class="number">1</span>);</span><br><span class="line">    aofUpdateCurrentSize();</span><br><span class="line">    server.aof_rewrite_base_size = server.aof_current_size;</span><br><span class="line">    server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">readerr: <span class="comment">/* Read error. If feof(fp) is true, fall through to unexpected EOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Unrecoverable error reading the append only file: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">uxeof: <span class="comment">/* Unexpected AOF end of file. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_load_truncated) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Warning: short read while loading the AOF file !!!&quot;</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Truncating the AOF at offset %llu !!!&quot;</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) valid_up_to);</span><br><span class="line">        <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span> || truncate(filename,valid_up_to) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Last valid command offset is invalid&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error truncating the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Make sure the AOF file descriptor points to the end of the</span></span><br><span class="line"><span class="comment">             * file after the truncate call. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_fd != <span class="number">-1</span> &amp;&amp; lseek(server.aof_fd,<span class="number">0</span>,SEEK_END) == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t seek the end of the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;AOF loaded anyway because aof-load-truncated is enabled&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> loaded_ok;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &#x27;aof-load-truncated&#x27; configuration option to yes and restart the server.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fmterr: <span class="comment">/* Format error. */</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：aof.c/rio.c/rio.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br&gt;除了RDB持久化功能以外，Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis所执行的写命令来记录数据库状态的。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="3-database" scheme="https://blog.grizzlys.top/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-RDB持久化</title>
    <link href="https://blog.grizzlys.top/Redis/3-database/redis-parse-rdb/"/>
    <id>https://blog.grizzlys.top/Redis/3-database/redis-parse-rdb/</id>
    <published>2020-06-10T12:11:52.000Z</published>
    <updated>2021-07-08T02:33:40.877Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：rdb.c/rdb.h/rio.c/rio.h</p><p><strong>1. 前言</strong><br>Redis是内存数据库，所有的数据都是存在内存中，这样就会存在一个问题，就是当服务进程退出，所有数据都将会丢失，所以Redis提供了两种数据持久化的机制，分别是RDB(Redis DataBase)和AOF(Append Only File)。这两种机制的区别将在后面介绍AOF持久化中介绍。  </p><p>RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。<br>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为<code>dump.rdb</code>。</p><a id="more"></a><p><strong>2. RDB持久化的方式</strong><br>RDB持久化有三种方式，分别是：SAVE、BGSAVE、根据配置定期执行。<br>①.SAVE触发<br>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。<br>②.BGSAVE触发<br>执行该命令时，Redis会派生出一个子进程，然后由子进程负责创建 RDB 文件，父进程继续处理命令请求。<br>③.定期执行<br>定期执行的触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p><ul><li><strong>save</strong>：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如”save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li><li><strong>stop-writes-on-bgsave-error</strong>：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了。</li><li><strong>rdbcompression</strong>：默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</li><li><strong>rdbchecksum</strong>：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li><li><strong>dbfilename</strong>：设置快照的文件名，默认是 dump.rdb。</li><li><strong>dir</strong>:设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</li></ul><div class="table-container"><table><thead><tr><th>命令</th><th>SAVE</th><th>BGSAVE</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞状态</td><td>是</td><td>是（阻塞发生在fork）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork，消耗内存</td></tr></tbody></table></div><p><strong>3. RDB的优势和劣势</strong><br><strong>优势：</strong></p><ul><li>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li><li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><p><strong>劣势：</strong><br>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p><p><strong>4. RDB文件结构</strong><br>一个rdb可以分为以下几个部分：</p><ul><li>REDIS：5字节，保存着 “REDIS” 五个字符</li><li>db_version：4字节，RDB文件的版本号</li><li>databases：数据库中的键值对<ul><li>SELECTDB：1字节常量</li><li>db_number：数据库号码</li><li>key_value_pairs：键值对（含过期时间的键值对会带有 EXPIRETIME_MS 和过期时间 ms）<ul><li>EXPIRETIME_MS：标识符，对应的值是该key的过期时间戳，含过期时间的键值对才有该数据</li><li>ms：过期时间戳，含过期时间的键值对才有该数据</li><li>TYPE：该key的数据类型</li><li>key：key对应的字符串</li><li>value：key对应的值</li></ul></li></ul></li><li><p>EOF：标志着数据库内容的结尾（不是文件的结尾）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_OPCODE_EOF        255</span></span><br></pre></td></tr></table></figure></li><li><p>check_sum：校验和（CRC64），用来检查RDB文件是否出错</p></li></ul><p>图示如下：<br><img src="https://i.loli.net/2020/10/29/K5OtPgSx2keF46U.png" alt="rdb1.png"></p><p><strong>4.1 TYPE编码</strong><br><code>TYPE</code>常量记录了值对象的类型和编码，规则如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_LIST   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_SET    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_ZSET   3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_HASH   4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_ZSET_2 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_MODULE 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_MODULE_2 7</span></span><br><span class="line"><span class="comment">/* Object types for encoded objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_HASH_ZIPMAP    9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_LIST_ZIPLIST  10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_SET_INTSET    11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_ZSET_ZIPLIST  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_HASH_ZIPLIST  13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_LIST_QUICKLIST 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDB_TYPE_STREAM_LISTPACKS 15</span></span><br></pre></td></tr></table></figure><p><strong>4.2 key</strong><br>在RDB文件中有很多地方需要存储长度信息，如字符串长度、list长度等等。如果使用固定的int或long类型来存储该信息，在长度值比较小的时候会造成较大的空间浪费。为了节省空间，Redis也是无所不用其极，设计了一套特殊的方法对长度进行编码后再存储。</p><p>RDB文件中的长度编码主要通过读取第一字节的最高 2 位来决定接下来如何解析长度信息，在 <code>rdbSaveLen()</code> 函数中，我们可以看到有以下四种方式：</p><div class="table-container"><table><thead><tr><th>编码方式</th><th>占用字节数</th><th>说明</th></tr></thead><tbody><tr><td>00\</td><td>000000</td><td>1byte</td><td>这一字节的其余 6 位表示长度，可以保存的最大长度是 63 （包括在内）</td></tr><tr><td>01\</td><td>000000 00000000</td><td>2byte</td><td>长度为 14 位，当前字节 6 位，加上下个字节 8 位</td></tr><tr><td>10\</td><td>000000 [32 bit integer]</td><td>5byte</td><td>长度由随后的 32 位整数保存</td></tr><tr><td>11\</td><td>000000</td><td></td><td>后跟一个特殊编码的对象。字节中的 6 位（实际上只用到两个bit）指定对象的类型，用来确定怎样读取和解析接下来的数据</td></tr></tbody></table></div><p><code>rdbSaveLen()</code>的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveLen</span><span class="params">(rio *rdb, <span class="keyword">uint64_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">size_t</span> nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) &#123;</span><br><span class="line">        <span class="comment">/* Save a 6 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = (len&amp;<span class="number">0xFF</span>)|(RDB_6BITLEN&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) &#123;</span><br><span class="line">        <span class="comment">/* Save a 14 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = ((len&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>)|(RDB_14BITLEN&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        buf[<span class="number">1</span>] = len&amp;<span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">2</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt;= UINT32_MAX) &#123;</span><br><span class="line">        <span class="comment">/* Save a 32 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = RDB_32BITLEN;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> len32 = htonl(len);</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,&amp;len32,<span class="number">4</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">1</span>+<span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Save a 64 bit len */</span></span><br><span class="line">        buf[<span class="number">0</span>] = RDB_64BITLEN;</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,buf,<span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        len = htonu64(len);</span><br><span class="line">        <span class="keyword">if</span> (rdbWriteRaw(rdb,&amp;len,<span class="number">8</span>) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten = <span class="number">1</span>+<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nwritten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数主要功能"><a href="#函数主要功能" class="headerlink" title="函数主要功能"></a>函数主要功能</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span></span>; <span class="comment">// 保存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi, <span class="keyword">int</span> rdbflags)</span></span>; <span class="comment">// 加载</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoadRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>数据保存到rdb文件中：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> cwd[MAXPATHLEN]; <span class="comment">/* Current working dir path for error messages. */</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建rdb文件</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-%d.rdb&quot;</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed opening the RDB file %s (in server root dir %s) &quot;</span></span><br><span class="line">            <span class="string">&quot;for saving: %s&quot;</span>,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化rio</span></span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    startSaving(RDBFLAGS_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_save_incremental_fsync)</span><br><span class="line">        rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将db中的数据存入到rio中</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveRio(&amp;rdb,&amp;error,RDBFLAGS_NONE,rsi) == C_ERR) &#123;</span><br><span class="line">        errno = error;</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure data will not remain on the OS&#x27;s output buffers */</span></span><br><span class="line">    <span class="comment">// 同步数据到磁盘文件中</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></span><br><span class="line"><span class="comment">     * if the generate DB file is ok. */</span></span><br><span class="line">    <span class="comment">// 重命名rdb文件</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Error moving temp DB file %s on the final &quot;</span></span><br><span class="line">            <span class="string">&quot;destination %s (in server root dir %s): %s&quot;</span>,</span><br><span class="line">            tmpfile,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        stopSaving(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;DB saved on disk&quot;</span>);</span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line">    server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    stopSaving(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error saving DB on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    stopSaving(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">uint64_t</span> cksum;</span><br><span class="line">    <span class="keyword">size_t</span> processed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">&quot;REDIS%04d&quot;</span>,RDB_VERSION);</span><br><span class="line">    <span class="comment">// 保存REDIS RDB_VERSION</span></span><br><span class="line">    <span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 保存一些生产rdb文件的默认字段信息</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存数据库信息</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the SELECT DB opcode */</span></span><br><span class="line">        <span class="comment">// 保存SELECTDB常量和dbid</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the RESIZE DB opcode. We trim the size to UINT32_MAX, which</span></span><br><span class="line"><span class="comment">         * is currently the largest type we are able to represent in RDB sizes.</span></span><br><span class="line"><span class="comment">         * However this does not limit the actual size of the DB to load since</span></span><br><span class="line"><span class="comment">         * these sizes are just hints to resize the hash tables. */</span></span><br><span class="line">        <span class="keyword">uint64_t</span> db_size, expires_size;</span><br><span class="line">        db_size = dictSize(db-&gt;dict);</span><br><span class="line">        expires_size = dictSize(db-&gt;expires);</span><br><span class="line">        <span class="comment">// 保存RESIZEDB常量，数据库size和设置expire的key-value的size</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,db_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,expires_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line">        <span class="comment">// 遍历数据库的键空间，将数据库中的key-value存到rdb文件</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr = dictGetKey(de);</span><br><span class="line">            robj key, *o = dictGetVal(de);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            expire = getExpire(db,&amp;key);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When this RDB is produced as part of an AOF rewrite, move</span></span><br><span class="line"><span class="comment">             * accumulated diff from parent to child while rewriting in</span></span><br><span class="line"><span class="comment">             * order to have a smaller final write. */</span></span><br><span class="line">            <span class="keyword">if</span> (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">                rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">            &#123;</span><br><span class="line">                processed = rdb-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don&#x27;t release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are storing the replication information on disk, persist</span></span><br><span class="line"><span class="comment">     * the script cache as well: on successful PSYNC after a restart, we need</span></span><br><span class="line"><span class="comment">     * to be able to process any EVALSHA inside the replication backlog the</span></span><br><span class="line"><span class="comment">     * master will send us. */</span></span><br><span class="line">    <span class="keyword">if</span> (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123;</span><br><span class="line">        di = dictGetIterator(server.lua_scripts);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            robj *body = dictGetVal(de);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveAuxField(rdb,<span class="string">&quot;lua&quot;</span>,<span class="number">3</span>,body-&gt;ptr,sdslen(body-&gt;ptr)) == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        di = <span class="literal">NULL</span>; <span class="comment">/* So that we don&#x27;t release it again on error. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF opcode */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></span><br><span class="line"><span class="comment">     * loading code skips the check in this case. */</span></span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="keyword">if</span> (error) *error = errno;</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从rdb文件中加载数据：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi, <span class="keyword">int</span> rdbflags)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 获取文件状态写入server结构体中（如加载的文件大小、加载时间等）</span></span><br><span class="line">    startLoadingFile(fp, filename,rdbflags);</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp); <span class="comment">// 初始化rio</span></span><br><span class="line">    retval = rdbLoadRio(&amp;rdb,rdbflags,rsi);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    stopLoading(retval==C_OK);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoadRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> dbid;</span><br><span class="line">    <span class="keyword">int</span> type, rdbver;</span><br><span class="line">    redisDb *db = server.db+<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    rdb-&gt;update_cksum = rdbLoadProgressCallback;</span><br><span class="line">    rdb-&gt;max_processing_chunk = server.loading_process_events_interval_bytes;</span><br><span class="line">    <span class="comment">// 读取REDIS RDB_VERSION</span></span><br><span class="line">    <span class="keyword">if</span> (rioRead(rdb,buf,<span class="number">9</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">    buf[<span class="number">9</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 检查REDIS RDB_VERSION</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(buf,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Wrong signature trying to load DB from file&quot;</span>);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    rdbver = atoi(buf+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (rdbver &lt; <span class="number">1</span> || rdbver &gt; RDB_VERSION) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t handle RDB format version %d&quot;</span>,rdbver);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Key-specific attributes, set by opcodes before the key type. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lru_idle = <span class="number">-1</span>, lfu_freq = <span class="number">-1</span>, expiretime = <span class="number">-1</span>, now = mstime();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lru_clock = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始读取数据写入到数据库中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        robj *key, *val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read type. */</span></span><br><span class="line">        <span class="comment">// 读取数据的类型</span></span><br><span class="line">        <span class="keyword">if</span> ((type = rdbLoadType(rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle special types. */</span></span><br><span class="line">        <span class="comment">// 根据不同的类型进行相应的处理</span></span><br><span class="line">        <span class="keyword">if</span> (type == RDB_OPCODE_EXPIRETIME) &#123;</span><br><span class="line">            <span class="comment">/* EXPIRETIME: load an expire associated with the next key</span></span><br><span class="line"><span class="comment">             * to load. Note that after loading an expire we need to</span></span><br><span class="line"><span class="comment">             * load the actual type, and continue. */</span></span><br><span class="line">            expiretime = rdbLoadTime(rdb);</span><br><span class="line">            expiretime *= <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (rioGetReadError(rdb)) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_EXPIRETIME_MS) &#123;</span><br><span class="line">            <span class="comment">/* EXPIRETIME_MS: milliseconds precision expire times introduced</span></span><br><span class="line"><span class="comment">             * with RDB v3. Like EXPIRETIME but no with more precision. */</span></span><br><span class="line">            expiretime = rdbLoadMillisecondTime(rdb,rdbver);</span><br><span class="line">            <span class="keyword">if</span> (rioGetReadError(rdb)) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_FREQ) &#123;</span><br><span class="line">            <span class="comment">/* FREQ: LFU frequency. */</span></span><br><span class="line">            <span class="keyword">uint8_t</span> byte;</span><br><span class="line">            <span class="keyword">if</span> (rioRead(rdb,&amp;byte,<span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            lfu_freq = byte;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_IDLE) &#123;</span><br><span class="line">            <span class="comment">/* IDLE: LRU idle time. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> qword;</span><br><span class="line">            <span class="keyword">if</span> ((qword = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            lru_idle = qword;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_EOF) &#123;</span><br><span class="line">            <span class="comment">/* EOF: End of file, exit the main loop. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_SELECTDB) &#123;</span><br><span class="line">            <span class="comment">/* SELECTDB: Select the specified database. */</span></span><br><span class="line">            <span class="keyword">if</span> ((dbid = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> (dbid &gt;= (<span class="keyword">unsigned</span>)server.dbnum) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;FATAL: Data file was created with a Redis &quot;</span></span><br><span class="line">                    <span class="string">&quot;server configured to handle more than %d &quot;</span></span><br><span class="line">                    <span class="string">&quot;databases. Exiting\n&quot;</span>, server.dbnum);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            db = server.db+dbid;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_RESIZEDB) &#123;</span><br><span class="line">            <span class="comment">/* RESIZEDB: Hint about the size of the keys in the currently</span></span><br><span class="line"><span class="comment">             * selected data base, in order to avoid useless rehashing. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> db_size, expires_size;</span><br><span class="line">            <span class="keyword">if</span> ((db_size = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR)</span><br><span class="line">                <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> ((expires_size = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR)</span><br><span class="line">                <span class="keyword">goto</span> eoferr;</span><br><span class="line">            dictExpand(db-&gt;dict,db_size);</span><br><span class="line">            dictExpand(db-&gt;expires,expires_size);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_AUX) &#123;</span><br><span class="line">            <span class="comment">/* AUX: generic string-string fields. Use to add state to RDB</span></span><br><span class="line"><span class="comment">             * which is backward compatible. Implementations of RDB loading</span></span><br><span class="line"><span class="comment">             * are requierd to skip AUX fields they don&#x27;t understand.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * An AUX field is composed of two strings: key and value. */</span></span><br><span class="line">            robj *auxkey, *auxval;</span><br><span class="line">            <span class="keyword">if</span> ((auxkey = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> ((auxval = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((<span class="keyword">char</span>*)auxkey-&gt;ptr)[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">/* All the fields with a name staring with &#x27;%&#x27; are considered</span></span><br><span class="line"><span class="comment">                 * information fields and are logged at startup with a log</span></span><br><span class="line"><span class="comment">                 * level of NOTICE. */</span></span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;RDB &#x27;%s&#x27;: %s&quot;</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxkey-&gt;ptr,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;repl-stream-db&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi) rsi-&gt;repl_stream_db = atoi(auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;repl-id&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi &amp;&amp; sdslen(auxval-&gt;ptr) == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(rsi-&gt;repl_id,auxval-&gt;ptr,CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">                    rsi-&gt;repl_id_is_set = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;repl-offset&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi) rsi-&gt;repl_offset = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;lua&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Load the script back in memory. */</span></span><br><span class="line">                <span class="keyword">if</span> (luaCreateFunction(<span class="literal">NULL</span>,server.lua,auxval) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    rdbExitReportCorruptRDB(</span><br><span class="line">                        <span class="string">&quot;Can&#x27;t load Lua script from RDB file! &quot;</span></span><br><span class="line">                        <span class="string">&quot;BODY: %s&quot;</span>, auxval-&gt;ptr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;redis-ver&quot;</span>)) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;Loading RDB produced by version %s&quot;</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;ctime&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">time_t</span> age = time(<span class="literal">NULL</span>)-strtol(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (age &lt; <span class="number">0</span>) age = <span class="number">0</span>;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;RDB age %ld seconds&quot;</span>,</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) age);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;used-mem&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> usedmem = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">&quot;RDB memory usage when created %.2f Mb&quot;</span>,</span><br><span class="line">                    (<span class="keyword">double</span>) usedmem / (<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;aof-preamble&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> haspreamble = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span> (haspreamble) serverLog(LL_NOTICE,<span class="string">&quot;RDB has an AOF tail&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">&quot;redis-bits&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Just ignored. */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* We ignore fields we don&#x27;t understand, as by AUX field</span></span><br><span class="line"><span class="comment">                 * contract. */</span></span><br><span class="line">                serverLog(LL_DEBUG,<span class="string">&quot;Unrecognized RDB AUX field: &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxkey-&gt;ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            decrRefCount(auxkey);</span><br><span class="line">            decrRefCount(auxval);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read type again. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_MODULE_AUX) &#123;</span><br><span class="line">            <span class="comment">/* Load module data that is not related to the Redis key space.</span></span><br><span class="line"><span class="comment">             * Such data can be potentially be stored both before and after the</span></span><br><span class="line"><span class="comment">             * RDB keys-values section. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> moduleid = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">int</span> when_opcode = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">int</span> when = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (rioGetReadError(rdb)) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> (when_opcode != RDB_MODULE_OPCODE_UINT)</span><br><span class="line">                rdbReportReadError(<span class="string">&quot;bad when_opcode&quot;</span>);</span><br><span class="line">            moduleType *mt = moduleTypeLookupModuleByID(moduleid);</span><br><span class="line">            <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">            moduleTypeNameByID(name,moduleid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!rdbCheckMode &amp;&amp; mt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Unknown module. */</span></span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains AUX module data I can&#x27;t load: no matching module &#x27;%s&#x27;&quot;</span>, name);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rdbCheckMode &amp;&amp; mt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mt-&gt;aux_load) &#123;</span><br><span class="line">                    <span class="comment">/* Module doesn&#x27;t support AUX. */</span></span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains module AUX data, but the module &#x27;%s&#x27; doesn&#x27;t seem to support it.&quot;</span>, name);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                RedisModuleIO io;</span><br><span class="line">                moduleInitIOContext(io,mt,rdb,<span class="literal">NULL</span>);</span><br><span class="line">                io.ver = <span class="number">2</span>;</span><br><span class="line">                <span class="comment">/* Call the rdb_load method of the module providing the 10 bit</span></span><br><span class="line"><span class="comment">                 * encoding version in the lower 10 bits of the module ID. */</span></span><br><span class="line">                <span class="keyword">if</span> (mt-&gt;aux_load(&amp;io,moduleid&amp;<span class="number">1023</span>, when) != REDISMODULE_OK || io.error) &#123;</span><br><span class="line">                    moduleTypeNameByID(name,moduleid);</span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains module AUX data for the module type &#x27;%s&#x27;, that the responsible module is not able to load. Check for modules log above for additional clues.&quot;</span>, name);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (io.ctx) &#123;</span><br><span class="line">                    moduleFreeContext(io.ctx);</span><br><span class="line">                    zfree(io.ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">uint64_t</span> eof = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (eof != RDB_MODULE_OPCODE_EOF) &#123;</span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;The RDB file contains module AUX data for the module &#x27;%s&#x27; that is not terminated by the proper module value EOF marker&quot;</span>, name);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* RDB check mode. */</span></span><br><span class="line">                robj *aux = rdbLoadCheckModuleValue(rdb,name);</span><br><span class="line">                decrRefCount(aux);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">/* Read next opcode. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read key */</span></span><br><span class="line">        <span class="keyword">if</span> ((key = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">        <span class="comment">/* Read value */</span></span><br><span class="line">        <span class="keyword">if</span> ((val = rdbLoadObject(type,rdb,key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            <span class="keyword">goto</span> eoferr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the key already expired. This function is used when loading</span></span><br><span class="line"><span class="comment">         * an RDB file from disk, either at startup, or when an RDB was</span></span><br><span class="line"><span class="comment">         * received from the master. In the latter case, the master is</span></span><br><span class="line"><span class="comment">         * responsible for key expiry. If we would expire keys here, the</span></span><br><span class="line"><span class="comment">         * snapshot taken by the master may not be reflected on the slave. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; !(rdbflags&amp;RDBFLAGS_AOF_PREAMBLE) &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            decrRefCount(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Add the new object in the hash table */</span></span><br><span class="line">            dbAdd(db,key,val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Set the expire time if needed */</span></span><br><span class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) setExpire(<span class="literal">NULL</span>,db,key,expiretime);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Set usage information (for eviction). */</span></span><br><span class="line">            objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Decrement the key refcount since dbAdd() will take its</span></span><br><span class="line"><span class="comment">             * own reference. */</span></span><br><span class="line">            decrRefCount(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server.key_load_delay)</span><br><span class="line">            usleep(server.key_load_delay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Reset the state that is key-specified and is populated by</span></span><br><span class="line"><span class="comment">         * opcodes before the key, so that we start from scratch again. */</span></span><br><span class="line">        expiretime = <span class="number">-1</span>;</span><br><span class="line">        lfu_freq = <span class="number">-1</span>;</span><br><span class="line">        lru_idle = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Verify the checksum if RDB version is &gt;= 5 */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbver &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> cksum, expected = rdb-&gt;cksum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rioRead(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">        <span class="keyword">if</span> (server.rdb_checksum) &#123;</span><br><span class="line">            memrev64ifbe(&amp;cksum);</span><br><span class="line">            <span class="keyword">if</span> (cksum == <span class="number">0</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;RDB file was saved with checksum disabled: no check performed.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != expected) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Wrong RDB checksum. Aborting now.&quot;</span>);</span><br><span class="line">                rdbExitReportCorruptRDB(<span class="string">&quot;RDB CRC error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unexpected end of file is handled here calling rdbReportReadError():</span></span><br><span class="line"><span class="comment">     * this will in turn either abort Redis in most cases, or if we are loading</span></span><br><span class="line"><span class="comment">     * the RDB file from a socket during initial SYNC (diskless replica mode),</span></span><br><span class="line"><span class="comment">     * we&#x27;ll report the error to the caller, so that we can retry. */</span></span><br><span class="line">eoferr:</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">&quot;Short read or OOM loading DB. Unrecoverable error, aborting now.&quot;</span>);</span><br><span class="line">    rdbReportReadError(<span class="string">&quot;Unexpected EOF reading RDB file&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：rdb.c/rdb.h/rio.c/rio.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br&gt;Redis是内存数据库，所有的数据都是存在内存中，这样就会存在一个问题，就是当服务进程退出，所有数据都将会丢失，所以Redis提供了两种数据持久化的机制，分别是RDB(Redis DataBase)和AOF(Append Only File)。这两种机制的区别将在后面介绍AOF持久化中介绍。  &lt;/p&gt;
&lt;p&gt;RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。&lt;br&gt;RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为&lt;code&gt;dump.rdb&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="3-database" scheme="https://blog.grizzlys.top/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-通知功能notify</title>
    <link href="https://blog.grizzlys.top/Redis/3-database/redis-parse-notify/"/>
    <id>https://blog.grizzlys.top/Redis/3-database/redis-parse-notify/</id>
    <published>2020-06-09T11:44:26.000Z</published>
    <updated>2021-07-08T02:33:40.873Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：notify.c/server.h</p><p><strong>1. 事件通知概述</strong><br>对于Redis服务器，它可以通过订阅发布功能来发送服务器中的键空间事件。所谓的键空间事件，就是数据库中键的增加、修改和删除等操作，用于告知收听该类事件的客户端当前数据库中执行了哪些操作。客户端可以通过 订阅与发布功能（pub/sub）功能，来接收那些以某种方式改动了Redis数据集的事件。<br>目前Redis的订阅与发布功能采用的是发送即忘（fire and forget）的策略，当订阅事件的客户端断线时，它会丢失所有在断线期间分发给它的事件。<br>订阅与发布功能（pub/sub）功能实现在pubsub.c中，后续会在博文中讲到。</p><a id="more"></a><p><strong>2. 事件类型</strong><br>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件：  </p><ul><li>键空间通知（key-space）</li><li>键事件通知（key-event）</li></ul><p>当 <code>del mykey</code> 命令执行时：</p><ul><li>键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 del</li><li>键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 mykey</li></ul><p><strong>3. 配置</strong><br>因为开启键空间通知功能需要消耗一些 CPU，所以在默认配置下，该功能处于关闭状态。开启通知功能有以下两种方式：  </p><ol><li>修改 redis.conf 中的 <code>notify-keyspace-events</code> 参数</li><li>通过 CONFIG SET 命令来设定 <code>notify-keyspace-events</code> 参数</li></ol><p><code>notify-keyspace-events</code> 参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知：</p><div class="table-container"><table><thead><tr><th>字符</th><th>发送的通知</th></tr></thead><tbody><tr><td>K</td><td>键空间通知，所有通知以 <strong>keyspace@\<db></db></strong> 为前缀</td></tr><tr><td>E</td><td>键事件通知，所有通知以 <strong>keyevent@\<db></db></strong> 为前缀</td></tr><tr><td>g</td><td>DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</td></tr><tr><td>$</td><td>字符串命令的通知</td></tr><tr><td>l</td><td>列表命令的通知</td></tr><tr><td>s</td><td>集合命令的通知</td></tr><tr><td>h</td><td>哈希命令的通知</td></tr><tr><td>z</td><td>有序集合命令的通知</td></tr><tr><td>x</td><td>过期事件：每当有过期键被删除时发送</td></tr><tr><td>e</td><td>驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</td></tr><tr><td>A</td><td>参数 g$lshzxe 的别名，包含所有的字符</td></tr></tbody></table></div><p>输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何通知被分发。<br>在源码中设定了一系列的宏定义，用来标识以上这些字符事件的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键空间通知的类型，每个类型都关联着一个有目的的字符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_KEYSPACE (1&lt;&lt;0)    <span class="comment">/* K */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_KEYEVENT (1&lt;&lt;1)    <span class="comment">/* E */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_GENERIC (1&lt;&lt;2)     <span class="comment">/* g */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_STRING (1&lt;&lt;3)      <span class="comment">/* $ */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_LIST (1&lt;&lt;4)        <span class="comment">/* l */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_SET (1&lt;&lt;5)         <span class="comment">/* s */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_HASH (1&lt;&lt;6)        <span class="comment">/* h */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_ZSET (1&lt;&lt;7)        <span class="comment">/* z */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_EXPIRED (1&lt;&lt;8)     <span class="comment">/* x */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_EVICTED (1&lt;&lt;9)     <span class="comment">/* e */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_STREAM (1&lt;&lt;10)     <span class="comment">/* t */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_KEY_MISS (1&lt;&lt;11)   <span class="comment">/* m (Note: This one is excluded from NOTIFY_ALL on purpose) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTIFY_ALL (NOTIFY_GENERIC | NOTIFY_STRING | NOTIFY_LIST | NOTIFY_SET | NOTIFY_HASH | NOTIFY_ZSET | NOTIFY_EXPIRED | NOTIFY_EVICTED | NOTIFY_STREAM) <span class="comment">/* A flag */</span></span></span><br></pre></td></tr></table></figure><p>在notify.c文件中，只有三个功能函数，下面让我们来看看源码实现吧。</p><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keyspace events notification */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyspaceEventsStringToFlags</span><span class="params">(<span class="keyword">char</span> *classes)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">keyspaceEventsFlagsToString</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 因为redis命令中事件类型是字符类型，所以会使用一个int类型的flags参数</span></span><br><span class="line"><span class="comment"> * 通过多个字符按位或运算保存起来，方便后面使用 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyspaceEventsStringToFlags</span><span class="params">(<span class="keyword">char</span> *classes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = classes;</span><br><span class="line">    <span class="keyword">int</span> c, flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = *p++) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: flags |= NOTIFY_ALL; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>: flags |= NOTIFY_GENERIC; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: flags |= NOTIFY_STRING; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: flags |= NOTIFY_LIST; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: flags |= NOTIFY_SET; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: flags |= NOTIFY_HASH; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>: flags |= NOTIFY_ZSET; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: flags |= NOTIFY_EXPIRED; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: flags |= NOTIFY_EVICTED; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>: flags |= NOTIFY_KEYSPACE; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: flags |= NOTIFY_KEYEVENT; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: flags |= NOTIFY_STREAM; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: flags |= NOTIFY_KEY_MISS; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将flags参数转为sds类型</span></span><br><span class="line"><span class="function">sds <span class="title">keyspaceEventsFlagsToString</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    sds res;</span><br><span class="line"></span><br><span class="line">    res = sdsempty();</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; NOTIFY_ALL) == NOTIFY_ALL) &#123;</span><br><span class="line">        res = sdscatlen(res,<span class="string">&quot;A&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_GENERIC) res = sdscatlen(res,<span class="string">&quot;g&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_STRING) res = sdscatlen(res,<span class="string">&quot;$&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_LIST) res = sdscatlen(res,<span class="string">&quot;l&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_SET) res = sdscatlen(res,<span class="string">&quot;s&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_HASH) res = sdscatlen(res,<span class="string">&quot;h&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_ZSET) res = sdscatlen(res,<span class="string">&quot;z&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_EXPIRED) res = sdscatlen(res,<span class="string">&quot;x&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_EVICTED) res = sdscatlen(res,<span class="string">&quot;e&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; NOTIFY_STREAM) res = sdscatlen(res,<span class="string">&quot;t&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NOTIFY_KEYSPACE) res = sdscatlen(res,<span class="string">&quot;K&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NOTIFY_KEYEVENT) res = sdscatlen(res,<span class="string">&quot;E&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NOTIFY_KEY_MISS) res = sdscatlen(res,<span class="string">&quot;m&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用Redis的订阅和发布功能来发送键空间事件通知。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果任何模块对事件感兴趣，将立即通知感兴趣的模块。这将绕过通知配置，但模块引擎将仅在事件类型与事件订阅者感兴趣的类型匹配时调用事件订阅者。 */</span></span><br><span class="line">     moduleNotifyKeyspaceEvent(type, event, key, dbid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知功能关闭，直接退出 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(server.notify_keyspace_events &amp; type)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事件对象</span></span><br><span class="line">    eventobj = createStringObject(event,<span class="built_in">strlen</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 键空间通知，格式为__keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">&quot;__keyspace@&quot;</span>,<span class="number">11</span>);</span><br><span class="line">        len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">&quot;__:&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        <span class="comment">// 调用pub/sub命令发送</span></span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 键时间通知，格式为__keyevente@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">&quot;__keyevent@&quot;</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">&quot;__:&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        <span class="comment">// 调用pub/sub命令发送</span></span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：notify.c/server.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 事件通知概述&lt;/strong&gt;&lt;br&gt;对于Redis服务器，它可以通过订阅发布功能来发送服务器中的键空间事件。所谓的键空间事件，就是数据库中键的增加、修改和删除等操作，用于告知收听该类事件的客户端当前数据库中执行了哪些操作。客户端可以通过 订阅与发布功能（pub/sub）功能，来接收那些以某种方式改动了Redis数据集的事件。&lt;br&gt;目前Redis的订阅与发布功能采用的是发送即忘（fire and forget）的策略，当订阅事件的客户端断线时，它会丢失所有在断线期间分发给它的事件。&lt;br&gt;订阅与发布功能（pub/sub）功能实现在pubsub.c中，后续会在博文中讲到。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="3-database" scheme="https://blog.grizzlys.top/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-数据库的实现</title>
    <link href="https://blog.grizzlys.top/Redis/3-database/redis-parse-db/"/>
    <id>https://blog.grizzlys.top/Redis/3-database/redis-parse-db/</id>
    <published>2020-05-07T09:18:36.000Z</published>
    <updated>2021-07-08T02:33:40.865Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：db.c/server.h</p><p><strong>1. Redis数据库介绍：</strong><br>在前两个阶段中，我们学习了redis数据结构的实现，而这些数据结构都是为了实现数据库功能做的铺垫，下面，让我们一起来看看redis数据库是如何实现的吧。  </p><p>Redis服务器在运行的时候会创建大量的redisObject对象，这些对象都是存在redisDb中的，为了快速索引到某个对象，redisDb采用了dict字典结构设计。<br>启动Redis后，Redis服务器将所有数据库都保存在redisServer结构的db数组中，db数组的每一项都是一个redisDb结构，代表一个数据库。根据配置参数，redis服务器在初始化的时候，默认情况下会创建16个数据库，由dbnum决定(可通过<code>databases</code>配置修改)，每个数据库都是独立的。<br>客户端可以通过<code>select</code>命令来切换数据库，如<code>select 1</code>会切换到数据库号为 1 的数据库，select是通过修改客户端的db指针，指针指向不同的数据库来实现数据库的切换操作的。  </p><a id="more"></a><p>操作如下图：<br><img src="https://i.loli.net/2020/10/29/IJD7hLAU81kFSNz.png" alt="db0.png"></p><p>redis服务结构体如下：<br><img src="https://i.loli.net/2020/10/29/DeiQsrYdVA4Cn9M.png" alt="db1.png"></p><p>redis通过字典保存数据库中的所有键值对，我们称之为键空间(key space)。键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种redis对象。</li></ul><p><strong>2. redis数据库支持增删改查(curd)操作：</strong></p><p><strong>①.添加新键</strong><br>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间的字典里，其中键为字符串对象，值为任意一种类型的redis对象。<br><strong>②.删除键</strong><br>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。<br><strong>③.更新键</strong><br>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象类型的不同，更新的方法也不同。<br><strong>④.查询键</strong><br>对一个数据库键进行查询，实际上就是在键空间中取出键所对应的值对象，根据值对象类型的不同，取值的方法也不同。  </p><p>除了以上操作外，redis还有很多针对数据库本身的命令，也是通过对键空间进行处理来完成的。  </p><p><strong>3. 读写键空间时的维护操作：</strong><br>当使用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的操作，其中包括：</p><ul><li>在读取一个键之后（读写操作都需要先对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中(hit)次数或不命中(miss)次数，这两个值可以在<code>INFO stat</code>命令的<code>keyspace_hits</code>和<code>keyspace_misses</code>属性中查看。</li><li>在读取一个键之后，服务器会更新键的LRU或LFU时间，这个值用于计算键的闲置时间，可以使用<code>OBJECT idletime [key]</code>命令查看key的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期的键，然后才执行余下操作。</li><li>如果有客户端使用<code>WATCH</code>命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏(dirty)，从而让事务程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键后，都会对脏(dirty)键计数器的值增 1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器会按配置发送相应的数据库通知。</li></ul><p><strong>4. 设置键的生存时间或过期时间：</strong><br>Redis有四个命令可以设置键的过期时间，包括expire,pexpire,expireat,pexpireat，不过这四个命令最后都会转化成pexpireat命令来实现。<br>RedisDb中，使用一个字典expires来存储带有过期时间的键，称之为过期字典。</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间（精度为毫秒的unix时间戳）。</li></ul><p><strong>5. 过期键的删除策略：</strong><br>如果一个键过期了，那么它什么时候被删除呢？redis有三种删除策略：</p><ol><li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，执行删除操作，如果没过期，则返回该键。</li><li>定期删除：每隔一段时间，程序对数据库进行检查，删除过期的键。至于要删除多少过期键，以及要检查多少个数据库，则由算法实现。</li></ol><p>这几种方式各有利弊。</p><ol><li>定时删除对内存最为友好，当键过期时，会立即删除该键，释放内存。不过对CPU最不友好，因为每一个键都需要创建一个定时器，这种行为可能会占用相当一部分的CPU时间。此外，创建定时器需要用到Redis服务器中的时间时间，而当前时间时间的实现方式-无序链表查找一个事件的时间复杂度为O(N)，不能高效地处理大量时间事件。</li><li>惰性删除策略对CPU是最友好的，但是对内存最不友好。如果一个键已经过期，这个键又保留在数据库中，那么内存就会一直占用不释放，由db.c/expireIfNeeded()函数实现惰性删除。</li><li>定期删除算是前两种策略的一种整合和折中，定期策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率减少删除操作对CPU时间的影响。定期删除过期键可以有效地减少因为过期键带来的内存浪费。</li></ol><p>下面我们通过代码来看看redis数据库的实现吧。</p><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redisServer</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;    <span class="comment">/* 数据库数组*/</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;      <span class="comment">/* 数据库的总个数 */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redisDb</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库的键空间 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期字典 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* 存放所有造成阻塞的键及其客户端 */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* 存放push操作添加的造成阻塞的键，便于解阻塞 */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* 被watch命令监控的键和相应的客户端，用于multi/exec */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* 数据库编号 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 平均生存时间 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* 要尝试逐项进行碎片整理的密钥名称列表 */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeExpire</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 移除key的过期时间，当只有在db-&gt;dict中存在key时，才会移除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> lazy)</span></span>; <span class="comment">// 将过期key的del操作通知给slaves和AOF文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 被动的删除过期key。当用户对key进行操作时，首先判断key是否过期，过期则删除返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 返回key的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(client *c, redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span></span>; <span class="comment">// 设置key的过期时间</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// db中查找元素的底层实现</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 调用lookupKeyReadWithFlags，需要修改键的访问时间</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 调用lookupKeyWriteWithFlags，需要修改键的访问时间</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyReadOrReply</span><span class="params">(client *c, robj *key, robj *reply)</span></span>; <span class="comment">// 调用lookupKeyRead，未找到则将描述信息加入到缓冲区输出到客户端</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteOrReply</span><span class="params">(client *c, robj *key, robj *reply)</span></span>; <span class="comment">// 调用lookupKeyWrite，未找到则将描述信息加入到缓冲区输出到客户端</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 首先从过期字典中查找键是否过期，未过期调用lookupKey来查找元素，并更新键的命中或不命中的属性</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// 首先从过期字典中查找键是否过期并调用lookupKey来查找元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 键空间增加键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 重写键的值，继承源键的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genericSetKey</span><span class="params">(redisDb *db, robj *key, robj *val, <span class="keyword">int</span> keepttl)</span></span>; <span class="comment">// 高阶函数，如果key不存在则增加，key存在则修改值，可选择是否删除过期字典中的key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span></span>; <span class="comment">// 调用genericSetKey，并从过期字典中删除该key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbExists</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// key是否存在</span></span><br><span class="line"><span class="function">robj *<span class="title">dbRandomKey</span><span class="params">(redisDb *db)</span></span>; <span class="comment">// 随机获取key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 同步删除键空间和过期字典中的key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 通过redis延迟删除配置，选择dbSyncDelete或者dbAsyncDelete</span></span><br><span class="line"><span class="function">robj *<span class="title">dbUnshareStringValue</span><span class="params">(redisDb *db, robj *key, robj *o)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">emptyDb</span><span class="params">(<span class="keyword">int</span> dbnum, <span class="keyword">int</span> flags, <span class="keyword">void</span>(callback)(<span class="keyword">void</span>*))</span></span>; <span class="comment">// 调用emptyDbGeneric清空数据库</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">emptyDbGeneric</span><span class="params">(redisDb *dbarray, <span class="keyword">int</span> dbnum, <span class="keyword">int</span> flags, <span class="keyword">void</span>(callback)(<span class="keyword">void</span>*))</span></span>; <span class="comment">// 清空数据库</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAllDataAndResetRDB</span><span class="params">(<span class="keyword">int</span> flags)</span></span>; <span class="comment">// 清空所有的数据库并重置</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dbTotalServerKeyCount</span><span class="params">()</span></span>; <span class="comment">// 统计所有数据库的键数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(client *c, <span class="keyword">int</span> id)</span></span>; <span class="comment">// 选择数据库</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 每次修改键空间的键时，都会调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalFlushedDb</span><span class="params">(<span class="keyword">int</span> dbid)</span></span>; <span class="comment">// 清空数据库时调用此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// redis-cluster集群 slot槽点相关函数，将在cluster中解释</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot, robj **keys, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">countKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">delKeysInSlot</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> hashslot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verifyClusterConfigWithData</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> cursor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseScanCursorOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> *cursor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slotToKeyAdd</span><span class="params">(robj *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slotToKeyDel</span><span class="params">(robj *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slotToKeyFlush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span></span>; <span class="comment">// 异步删除过期key，放入惰性删除列表中，将在另一个bio.c线程中回收</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emptyDbAsync</span><span class="params">(redisDb *db)</span></span>; <span class="comment">// 异步清空数据库，创建新库，将旧库放入惰性删除列表中，将在另一个bio.c线程中回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* API to get key arguments from commands */</span></span><br><span class="line"><span class="comment">// 一些命令的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getKeysFromCommand</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>; <span class="comment">// 获取所有的 keyIndex</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getKeysFreeResult</span><span class="params">(<span class="keyword">int</span> *result)</span></span>; <span class="comment">// 释放keyindex</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">zunionInterGetKeys</span><span class="params">(struct redisCommand *cmd,robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">evalGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">sortGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">migrateGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">georadiusGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">xreadGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">memoryGetKeys</span><span class="params">(struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *numkeys)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：db.c/server.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Redis数据库介绍：&lt;/strong&gt;&lt;br&gt;在前两个阶段中，我们学习了redis数据结构的实现，而这些数据结构都是为了实现数据库功能做的铺垫，下面，让我们一起来看看redis数据库是如何实现的吧。  &lt;/p&gt;
&lt;p&gt;Redis服务器在运行的时候会创建大量的redisObject对象，这些对象都是存在redisDb中的，为了快速索引到某个对象，redisDb采用了dict字典结构设计。&lt;br&gt;启动Redis后，Redis服务器将所有数据库都保存在redisServer结构的db数组中，db数组的每一项都是一个redisDb结构，代表一个数据库。根据配置参数，redis服务器在初始化的时候，默认情况下会创建16个数据库，由dbnum决定(可通过&lt;code&gt;databases&lt;/code&gt;配置修改)，每个数据库都是独立的。&lt;br&gt;客户端可以通过&lt;code&gt;select&lt;/code&gt;命令来切换数据库，如&lt;code&gt;select 1&lt;/code&gt;会切换到数据库号为 1 的数据库，select是通过修改客户端的db指针，指针指向不同的数据库来实现数据库的切换操作的。  &lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="3-database" scheme="https://blog.grizzlys.top/categories/Redis/3-database/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>C++ 编译与链接</title>
    <link href="https://blog.grizzlys.top/c/cpp-compilie-link/"/>
    <id>https://blog.grizzlys.top/c/cpp-compilie-link/</id>
    <published>2020-05-01T03:05:48.000Z</published>
    <updated>2021-07-08T02:33:40.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-编译系统"><a href="#1-编译系统" class="headerlink" title="1. 编译系统"></a>1. 编译系统</h2><p>从源码文件到可执行程序是如何实现的呢？下面写个简单的程序来进行说明。<br>以下是一个 hello.c 程序：</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Linux系统上，由编译器把源文件转换为可执行文件的命令如下：</p><blockquote><p>gcc hello.c -o hello</p></blockquote><p>这是gcc编译器一步到位将源文件编译成了可执行文件，其中省略了的几个步骤，由gcc编译器自动执行。我们拆开来看，整个编译分为四个步骤：</p><blockquote><p>1-&gt; gcc -E hello.c -o hello.i<br>2-&gt; gcc -S hello.i -o hello.s<br>3-&gt; gcc -c hello.s -o hello.o<br>4-&gt; gcc hello.o -o hello</p></blockquote><p>步骤1：<strong>预处理阶段</strong>，处理以 # 开头的预处理命令；<br>步骤2：<strong>编译阶段</strong>，翻译成汇编文件；<br>步骤3：<strong>汇编阶段</strong>，将汇编文件翻译成可重定位目标文件（.o文件）；<br>步骤4：<strong>链接阶段</strong>，将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。<br><img src="https://qqadapt.qpic.cn/txdocpic/0/8a5e60d8034df3a7be257782321abbca/0" alt="compilie&amp;link"><br>以上就是编译链接成可执行文件的过程，下面介绍两种链接方式：<strong>静态链接</strong>和<strong>动态链接</strong>。</p><h2 id="2-静态链接"><a href="#2-静态链接" class="headerlink" title="2. 静态链接"></a>2. 静态链接</h2><h3 id="2-1-为什么需要静态链接"><a href="#2-1-为什么需要静态链接" class="headerlink" title="2.1 为什么需要静态链接"></a>2.1 为什么需要静态链接</h3><p>在实际开发中，我们不可能把所有的代码都写在一个源文件中，所以会出现很多源文件。这些源文件并非是独立的，而是有一定的依赖关系，如一个源文件需要调用另一个源文件中的函数，但是每个源文件都是独立编译的，即每个 <strong>.c</strong> 将会编译成对应的 <strong>.o</strong> 文件，那么就需要将这些目标文件进行链接，从而生成一个可执行文件，这个过程就是静态链接。</p><h3 id="2-2-静态链接的过程"><a href="#2-2-静态链接的过程" class="headerlink" title="2.2 静态链接的过程"></a>2.2 静态链接的过程</h3><p>在Linux中，静态链接库以 .a 为文件后缀，如 libc.a 为 c语言的静态链接库。<br>在示例程序中，调用了 stdio.h 中的 printf 函数，在 libc.a 中找到 printf.o 和它的依赖目标文件，然后将这些依赖文件和我们的 hello.o 文件链接打包成一个可执行文件，过程如下图：<br><img src="https://qqadapt.qpic.cn/txdocpic/0/830e5f24d85ce1067c6bc9125e003bc9/0" alt="static"></p><h3 id="2-3-静态链接的优缺点"><a href="#2-3-静态链接的优缺点" class="headerlink" title="2.3 静态链接的优缺点"></a>2.3 静态链接的优缺点</h3><p><strong>优点：</strong></p><ol><li>因为可执行程序中已经具备了执行程序所需要的所有东西，所以程序加载速度快，执行速度也快。</li><li>只需要保证开发者计算机上有正确的 .a 文件，在发布可执行程序时，不需要考虑发布机器上是否存在 .a 文件。</li></ol><p><strong>缺点：</strong></p><ol><li>使用静态链接生成的可执行文件体积较大，包含了相同的公共代码，造成空间浪费。</li><li>更新困难，如果静态库文件更新，需要重新编译链接整个可执行文件，再行发布。</li></ol><h2 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h2><p>为了解决静态链接的缺点，就需要使用到动态链接。<br>在Linux中，动态链接库以 .so 为文件后缀。<br>动态链接的思想就是将程序按照模块拆分为各个相对独立的部分，在程序运行时才将它们链接在一起形成完整的程序。<br><img src="https://qqadapt.qpic.cn/txdocpic/0/4f8013511ac6fbf141ebdfe1a1d065aa/0" alt="mem"><br><strong>优点：</strong></p><ol><li>更加节省内存并减少页面交换。</li><li>更新方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。</li><li>可是实现进程之间的资源共享。</li></ol><p><strong>缺点：</strong></p><ol><li>当某个动态库更新后，如果依赖该动态库的程序与更新后的动态库不兼容，则该程序将无法正常执行。</li><li>因为是运行时加载，所以相对于静态链接，性能会有所下降。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-编译系统&quot;&gt;&lt;a href=&quot;#1-编译系统&quot; class=&quot;headerlink&quot; title=&quot;1. 编译系统&quot;&gt;&lt;/a&gt;1. 编译系统&lt;/h2&gt;&lt;p&gt;从源码文件到可执行程序是如何实现的呢？下面写个简单的程序来进行说明。&lt;br&gt;以下是一个 hello.c 程序：&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://blog.grizzlys.top/categories/c/"/>
    
    
    <category term="c++" scheme="https://blog.grizzlys.top/tags/c/"/>
    
    <category term="编译" scheme="https://blog.grizzlys.top/tags/%E7%BC%96%E8%AF%91/"/>
    
    <category term="链接" scheme="https://blog.grizzlys.top/tags/%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-有序集合对象zset</title>
    <link href="https://blog.grizzlys.top/Redis/2-object/redis-parse-zset/"/>
    <id>https://blog.grizzlys.top/Redis/2-object/redis-parse-zset/</id>
    <published>2020-04-29T12:05:53.000Z</published>
    <updated>2021-07-08T02:33:40.879Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：t_zset.c/server.h</p><p>zset对象底层编码方式有两种，<code>ziplist</code>或<code>skiplist</code>。<br>使用ziplist编码需要同时满足以下两个条件：  </p><ul><li>有序集合对象中所有元素的大小都小于64字节。（可通过redis.conf配置：zset_max_ziplist_value）</li><li>有序集合对象保存的元素个数不超过128个。（可通过redis.conf配置：zset_max_ziplist_entries）</li></ul><a id="more"></a><p>ziplist的结构如下：<br><img src="https://i.loli.net/2020/10/29/LZnqe3lM8a5zS6R.png" alt="t_zset_ziplist.png"><br>如上图，集合的元素由两个紧挨着的节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。压缩列表内的元素按照分值从小到大排序，分值小的靠近表头，分值大的靠近表尾。  </p><p>zset编码底层实际上是由skiplist和dict构成的：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>为什么会使用两种数据结构呢？其实，使用单一的数据结构也是可以实现有序集合对象的，比如单独使用字典，查找时间复杂度为O(1)，因为字典是无序的，所以当执行范围型操作时，首先要对所有元素进行排序，这里就会增加时间复杂度和空间复杂度了。当单独使用跳跃表时，查找的时间复杂度将会是O(logN)。所以，将两者的优势结合，将会很大的提高性能。另外，两种数据结构都会通过指针来共享相同的元素和分值，所以不会对内存造成不必要的浪费。</p><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th><th>时间复杂度</th></tr></thead><tbody><tr><td>ZCARD</td><td>返回key的有序集元素个数</td><td>O(1)</td></tr><tr><td>ZCOUNT</td><td>返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员</td><td>O(log(N))</td></tr><tr><td>ZINCRBY</td><td>为有序集key的成员member的score值加上增量increment</td><td>O(log(N))</td></tr><tr><td>ZINTERSTORE</td><td>计算给定的numkeys个有序集合的交集，并且把结果放到destination中</td><td>O(N<em>K)+O(M</em>log(M))，最坏的情况，N是最小的输入排序集，K是输入排序集的数量，M是结果排序集中的元素的数量</td></tr><tr><td>ZLEXCOUNT</td><td>用于计算有序集合中指定成员之间的成员数量</td><td>O(log(N))</td></tr><tr><td>ZPOPMAX</td><td>删除并返回有序集合key中的最多count个具有最高得分的成员</td><td>O(log(N)*M)</td></tr><tr><td>ZPOPMIN</td><td>删除并返回有序集合key中的最多count个具有最低得分的成员</td><td>O(log(N)*M)</td></tr><tr><td>ZRANGE</td><td>返回存储在有序集合key中的指定范围的元素</td><td>O(log(N)+M)</td></tr><tr><td>ZRANGEBYLEX</td><td>返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同</td><td>O(log(N)+M)</td></tr><tr><td>ZREVRANGEBYLEX</td><td>返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同</td><td>O(log(N)+M)</td></tr><tr><td>ZRANGEBYSCORE</td><td>返回指定分数范围的元素列表</td><td>O(log(N)+M)</td></tr><tr><td>ZRANK</td><td>返回有序集key中成员member的排名</td><td>O(log(N))</td></tr><tr><td>ZREM</td><td>在key集合中移除指定的元素</td><td>O(M*log(N))</td></tr><tr><td>ZREMRANGEBYLEX</td><td>删除名称按字典由低到高排序成员之间所有成员</td><td>O(log(N)+M)</td></tr><tr><td>ZREMRANGEBYRANK</td><td>移除有序集key中，指定排名(rank)区间内的所有成员</td><td>O(log(N)+M)</td></tr><tr><td>ZREMRANGEBYSCORE</td><td>移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员</td><td>O(log(N)+M)</td></tr><tr><td>ZREVRANGE</td><td>返回有序集key中，指定区间内的成员</td><td>O(log(N)+M)</td></tr><tr><td>ZREVRANGEBYSCORE</td><td>返回有序集合中指定分数区间内的成员，分数由高到低排序</td><td>O(log(N)+M)</td></tr><tr><td>ZREVRANK</td><td>返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列</td><td>O(log(N))</td></tr><tr><td>ZSCORE</td><td>返回有序集key中，成员member的score值</td><td>O(1)</td></tr><tr><td>ZUNIONSTORE</td><td>计算给定的numkeys个有序集合的并集，并且把结果放到destination中</td><td>O(N)+O(M log(M))</td></tr><tr><td>ZSCAN</td><td>用于迭代集合类型中的集合成员</td><td>O(1)</td></tr></tbody></table></div><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcardCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zcountCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincrbyCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zinterstoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlexcountCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zpopmaxCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zpopminCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangeCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebylexCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebylexCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangebyscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrankCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebylexCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyrankCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zremrangebyscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangeCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrangebyscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrevrankCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zunionstoreCommand</span><span class="params">(client *c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zscanCommand</span><span class="params">(client *c)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr><p>添加命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数含义：  </span></span><br><span class="line"><span class="comment">* XX: 仅仅更新存在的成员，不添加新成员。</span></span><br><span class="line"><span class="comment">* NX: 不更新存在的成员。只添加新成员。</span></span><br><span class="line"><span class="comment">* CH: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 changed 的意思)。</span></span><br><span class="line"><span class="comment">*     更改的元素是新添加的成员，已经存在的成员更新分数。 所以在命令中指定的成员有相同的分数将不</span></span><br><span class="line"><span class="comment">*     被计算在内。注：在通常情况下，ZADD返回值只计算新添加成员的数量。</span></span><br><span class="line"><span class="comment">* INCR: 当ZADD指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作。 */</span></span><br><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    zaddGenericCommand(c,ZADD_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincrbyCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    zaddGenericCommand(c,ZADD_INCR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nanerr = <span class="string">&quot;resulting score is not a number (NaN)&quot;</span>;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">0</span>, *scores = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> j, elements;</span><br><span class="line">    <span class="keyword">int</span> scoreidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> added = <span class="number">0</span>;      <span class="comment">/* Number of new elements added. */</span></span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>;    <span class="comment">/* Number of elements with updated score. */</span></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;  <span class="comment">/* Number of elements processed, may remain zero with</span></span><br><span class="line"><span class="comment">                           options like XX. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析命令参数 */</span></span><br><span class="line">    scoreidx = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class="line">        <span class="keyword">char</span> *opt = c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;nx&quot;</span>)) flags |= ZADD_NX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;xx&quot;</span>)) flags |= ZADD_XX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;ch&quot;</span>)) flags |= ZADD_CH;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;incr&quot;</span>)) flags |= ZADD_INCR;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        scoreidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> incr = (flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nx = (flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx = (flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch = (flags &amp; ZADD_CH) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断参数合法性（元素-分值对） */</span></span><br><span class="line">    elements = c-&gt;argc-scoreidx;</span><br><span class="line">    <span class="keyword">if</span> (elements % <span class="number">2</span> || !elements) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查不兼容的选项 */</span></span><br><span class="line">    <span class="keyword">if</span> (nx &amp;&amp; xx) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;XX and NX options at the same time are not compatible&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (incr &amp;&amp; elements &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;INCR option supports a single increment-element pair&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查分数参数是否合格 */</span></span><br><span class="line">    scores = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*elements);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class="number">2</span>],&amp;scores[j],<span class="literal">NULL</span>)</span><br><span class="line">            != C_OK) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* db中查找集合 */</span></span><br><span class="line">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    <span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) <span class="keyword">goto</span> reply_to_client; <span class="comment">/* 没有找到key，并且设置了 XX 参数，则什么都不做 */</span></span><br><span class="line">        <span class="comment">// 如果db中没有key，则创建zset对象</span></span><br><span class="line">        <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">        &#123;</span><br><span class="line">            zobj = createZsetObject();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zobj = createZsetZiplistObject();</span><br><span class="line">        &#125;</span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zobj-&gt;type != OBJ_ZSET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> newscore;</span><br><span class="line">        score = scores[j];</span><br><span class="line">        <span class="keyword">int</span> retflags = flags;</span><br><span class="line"></span><br><span class="line">        ele = c-&gt;argv[scoreidx+<span class="number">1</span>+j*<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        <span class="keyword">int</span> retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,nanerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_ADDED) added++;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class="line">        <span class="keyword">if</span> (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class="line">        score = newscore;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (added+updated);</span><br><span class="line"></span><br><span class="line">reply_to_client:</span><br><span class="line">    <span class="keyword">if</span> (incr) &#123; <span class="comment">/* ZINCRBY or INCR option. */</span></span><br><span class="line">        <span class="keyword">if</span> (processed)</span><br><span class="line">            addReplyDouble(c,score);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyNull(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ZADD. */</span></span><br><span class="line">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    <span class="keyword">if</span> (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class="line">            incr ? <span class="string">&quot;zincr&quot;</span> : <span class="string">&quot;zadd&quot;</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>其他命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br><span class="line">ZCOUNT key min max</span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX]</span><br><span class="line">ZLEXCOUNT key min max</span><br><span class="line">ZPOPMAX key [count]</span><br><span class="line">ZPOPMIN key [count]</span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">ZRANK key member</span><br><span class="line">ZREM key member [member ...]</span><br><span class="line">ZREMRANGEBYLEX key min max</span><br><span class="line">ZREMRANGEBYRANK key start stop</span><br><span class="line">ZREMRANGEBYSCORE key min max</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">ZREVRANK key member</span><br><span class="line">ZSCORE key member</span><br><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX]</span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：t_zset.c/server.h&lt;/p&gt;
&lt;p&gt;zset对象底层编码方式有两种，&lt;code&gt;ziplist&lt;/code&gt;或&lt;code&gt;skiplist&lt;/code&gt;。&lt;br&gt;使用ziplist编码需要同时满足以下两个条件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有序集合对象中所有元素的大小都小于64字节。（可通过redis.conf配置：zset_max_ziplist_value）&lt;/li&gt;
&lt;li&gt;有序集合对象保存的元素个数不超过128个。（可通过redis.conf配置：zset_max_ziplist_entries）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="2-object" scheme="https://blog.grizzlys.top/categories/Redis/2-object/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-集合对象set</title>
    <link href="https://blog.grizzlys.top/Redis/2-object/redis-parse-set/"/>
    <id>https://blog.grizzlys.top/Redis/2-object/redis-parse-set/</id>
    <published>2020-04-26T09:07:05.000Z</published>
    <updated>2021-07-08T02:33:40.877Z</updated>
    
    <content type="html"><![CDATA[<p>源码位置：t_set.c/server.h</p><p>set对象底层编码方式有两种，<code>intset</code>或<code>hashtable</code>。<br>使用intset编码的条件：  </p><ul><li>集合对象中所有元素都是整数值。</li><li>集合对象保存的元素个数不超过512个。（可通过redis.conf配置：set_max_intset_entries）</li></ul><a id="more"></a><p>下面让我们测试一下：<br>例1：<br><img src="https://i.loli.net/2020/10/29/vnkPheCN7RUdKSj.png" alt="t_set_intset1.png"><br>当添加非整数的字符串时，则会转为hashtable编码<br><img src="https://i.loli.net/2020/10/29/WaIGyVSbJtMu4HE.png" alt="t_set_intset2.png"></p><p>例2：<br>插入512个整数，使用的是intset编码<br><img src="https://i.loli.net/2020/10/29/8r4QGNk6LVvTxbu.png" alt="t_set_intset3.png"><br>当插入第513个整数时，将会转为hashtable编码<br><img src="https://i.loli.net/2020/10/29/AISc4z7bOYN9pmF.png" alt="t_set_intset4.png"></p><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th><th>时间复杂度</th></tr></thead><tbody><tr><td>SADD</td><td>添加一个或多个元素到集合里</td><td>O(N)，N为添加的元素个数</td></tr><tr><td>SCARD</td><td>返回集合存储的key的基数 (集合元素的数量)</td><td>O(1)</td></tr><tr><td>SISMEMBER</td><td>返回成员member是否是存储的集合key的成员</td><td>O(1)</td></tr><tr><td>SINTER</td><td>返回指定所有的集合的成员的交集</td><td>O(N*M)，其中N是最小集合的基数，M是集合的数目</td></tr><tr><td>SINTERSTORE</td><td>类似SINTER，将结果存放到destination集合中，如果destination存在，则覆盖重写</td><td>O(N*M)，其中N是最小集合的基数，M是集合的数目</td></tr><tr><td>SDIFF</td><td>返回一个集合与给定集合的差集的元素</td><td>O(N)，N为所有集合的元素总数</td></tr><tr><td>SDIFFSTORE</td><td>类似SDIFF，将结果存放到destination集合中，如果destination存在，则覆盖重写</td><td>O(N)，N为所有集合的元素总数</td></tr><tr><td>SUNION</td><td>返回给定的多个集合的并集中的所有成员</td><td>O(N)</td></tr><tr><td>SUNIONSTORE</td><td>类似SUNION，将结果存放到destination集合中，如果destination存在，则覆盖重写</td><td>平均O(N)</td></tr><tr><td>SMEMBERS</td><td>返回key集合所有的元素，由SINTER实现</td><td>O(N)，N为该集合元素总数</td></tr><tr><td>SMOVE</td><td>将member从source集合移动到destination集合中</td><td>O(1)</td></tr><tr><td>SPOP</td><td>从存储在key的集合中移除并返回一个或多个随机元素</td><td>O(1)</td></tr><tr><td>SRANDMEMBER</td><td>类似SPOP，区别是该命令不删除元素</td><td>O(N)，N为指定count的值</td></tr><tr><td>SREM</td><td>在key集合中移除指定的元素</td><td>O(N)，N为指定的元素个数</td></tr><tr><td>SSCAN</td><td>用于迭代集合类型中的集合成员</td><td>O(1)</td></tr></tbody></table></div><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sadd命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scardCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// scard命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sdiff命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffstoreCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sdiffstore命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sinter和smembers命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterstoreCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sinterstore命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sismemberCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sismember命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoveCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// smove命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spopCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// spop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srandmemberCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// srandmember命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sremCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// srem命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sscanCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sscan命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sunion命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionstoreCommand</span><span class="params">(client *c)</span></span>; <span class="comment">// sunionstore命令</span></span><br></pre></td></tr></table></figure><h2 id="Redis命令实现"><a href="#Redis命令实现" class="headerlink" title="Redis命令实现"></a>Redis命令实现</h2><hr><p>插入命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">int</span> j, added = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果db中不存在该key，则根据元素类型选择使用intset编码或者hashtable编码创建set集合</span></span><br><span class="line">        <span class="built_in">set</span> = setTypeCreate(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="built_in">set</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;type != OBJ_SET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeAdd(<span class="built_in">set</span>,c-&gt;argv[j]-&gt;ptr)) added++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (added) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_SET,<span class="string">&quot;sadd&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += added;</span><br><span class="line">    addReplyLongLong(c,added);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">/* Convert to regular set when the intset contains</span></span><br><span class="line"><span class="comment">                 * too many entries. */</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Failed to get integer from object, convert to regular set. */</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The set *was* an intset and this value is not integer</span></span><br><span class="line"><span class="comment">             * encodable, so dictAdd should always work. */</span></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>交集命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line">SMEMBERS key <span class="comment">// 该命令是通过SINTER命令实现的</span></span><br></pre></td></tr></table></figure><p>代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setkeys：集合数组指针</span></span><br><span class="line"><span class="comment">// setnum：集合数量（命令中key的个数）</span></span><br><span class="line"><span class="comment">// dstkey：结果集是否添加到新的集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterGenericCommand</span><span class="params">(client *c, robj **setkeys,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">unsigned</span> <span class="keyword">long</span> setnum, robj *dstkey)</span> </span>&#123;</span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    sds elesds;</span><br><span class="line">    <span class="keyword">int64_t</span> intobj;</span><br><span class="line">    <span class="keyword">void</span> *replylen = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dbDelete(c-&gt;db,dstkey)) &#123;</span><br><span class="line">                    signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">                    server.dirty++;</span><br><span class="line">                &#125;</span><br><span class="line">                addReply(c,shared.czero);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReply(c,shared.emptyset[c-&gt;resp]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[j] = setobj; <span class="comment">// 从db中获取的集合对象存入到临时数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据集合的大小从小到大进行排序</span></span><br><span class="line">    qsort(sets,setnum,<span class="keyword">sizeof</span>(robj*),qsortCompareSetsByCardinality);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        replylen = addReplyDeferredLen(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dstset = createIntsetObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    si = setTypeInitIterator(sets[<span class="number">0</span>]); <span class="comment">// 从第一个集合开始遍历</span></span><br><span class="line">    <span class="comment">// 此处是while+for循环，所有时间复杂度是O(N*M)</span></span><br><span class="line">    <span class="keyword">while</span>((encoding = setTypeNext(si,&amp;elesds,&amp;intobj)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="comment">// 判断第一个集合的元素是否在集合j中</span></span><br><span class="line">            <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_INTSET &amp;&amp;</span><br><span class="line">                    !intsetFind((intset*)sets[j]-&gt;ptr,intobj))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                    elesds = sdsfromlonglong(intobj);</span><br><span class="line">                    <span class="keyword">if</span> (!setTypeIsMember(sets[j],elesds)) &#123;</span><br><span class="line">                        sdsfree(elesds);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sdsfree(elesds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!setTypeIsMember(sets[j],elesds)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT)</span><br><span class="line">                    addReplyBulkCBuffer(c,elesds,sdslen(elesds));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    addReplyBulkLongLong(c,intobj);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                    elesds = sdsfromlonglong(intobj);</span><br><span class="line">                    setTypeAdd(dstset,elesds);</span><br><span class="line">                    sdsfree(elesds);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setTypeAdd(dstset,elesds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setTypeReleaseIterator(si);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">        <span class="keyword">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,<span class="string">&quot;sinterstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setDeferredSetLen(c,replylen,cardinality);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>并集&amp;差集命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">并集：</span><br><span class="line">SUNION key [key ...]</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line">差集：</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_UNION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_UNION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_DIFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_DIFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionDiffGenericCommand</span><span class="params">(client *c, robj **setkeys, <span class="keyword">int</span> setnum,</span></span></span><br><span class="line"><span class="function"><span class="params">                              robj *dstkey, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">int</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> diff_algo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            sets[j] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[j] = setobj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 差集算法有两种：</span></span><br><span class="line"><span class="comment">     * 算法1： 时间复杂度为O(N*M)，N是第一个集合的大小，M是集合的总数</span></span><br><span class="line"><span class="comment">     * 算法2： 时间复杂度为O(N)，N是所有集合的元素总数</span></span><br><span class="line"><span class="comment">     * 根据输入条件计算选择使用哪种算法 */</span></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> algo_one_work = <span class="number">0</span>, algo_two_work = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sets[j] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            algo_one_work += setTypeSize(sets[<span class="number">0</span>]);</span><br><span class="line">            algo_two_work += setTypeSize(sets[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 算法1 具有更好的常数时间，并且如果有共同的元素，则执行的操作更少。 */</span></span><br><span class="line">        algo_one_work /= <span class="number">2</span>;</span><br><span class="line">        diff_algo = (algo_one_work &lt;= algo_two_work) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff_algo == <span class="number">1</span> &amp;&amp; setnum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            qsort(sets+<span class="number">1</span>,setnum<span class="number">-1</span>,<span class="keyword">sizeof</span>(robj*),</span><br><span class="line">                qsortCompareSetsByRevCardinality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个临时的set进行存储元素，如果是store模式，则存储该临时集合 */</span></span><br><span class="line">    dstset = createIntsetObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_UNION) &#123;</span><br><span class="line">        <span class="comment">/* 并集很简单，只需要把所有集合的元素放入到临时集合中就能得出 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* non existing keys are like empty sets */</span></span><br><span class="line"></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                sdsfree(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 差集算法1:</span></span><br><span class="line"><span class="comment">         * 通过迭代第一个集合的所有元素来进行差集判断，</span></span><br><span class="line"><span class="comment">         * 当第一个集合的元素不存在于其他所有的集合中时，</span></span><br><span class="line"><span class="comment">         * 才将元素插入到临时集合中。*/</span></span><br><span class="line">        si = setTypeInitIterator(sets[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* no key is an empty set. */</span></span><br><span class="line">                <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">break</span>; <span class="comment">/* same set! */</span></span><br><span class="line">                <span class="keyword">if</span> (setTypeIsMember(sets[j],ele)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">                <span class="comment">/* 当前元素不存在与其他集合中时，添加到临时集合dstset中 */</span></span><br><span class="line">                setTypeAdd(dstset,ele);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125;</span><br><span class="line">            sdsfree(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* 差集算法2:</span></span><br><span class="line"><span class="comment">         * 首先将第一个集合的元素插入到临时集合中，</span></span><br><span class="line"><span class="comment">         * 然后从中移除其他集合的所有元素。 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把第一个集合的元素添加到dstset中</span></span><br><span class="line">                    <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 从dstset中移除其他集合的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (setTypeRemove(dstset,ele)) cardinality--;</span><br><span class="line">                &#125;</span><br><span class="line">                sdsfree(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果临时集合dstset为空，则表示第一个集合的元素在其他集合中都存在，</span></span><br><span class="line"><span class="comment">             * 没有差集，直接退出循环 */</span></span><br><span class="line">            <span class="keyword">if</span> (cardinality == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        addReplySetLen(c,cardinality);</span><br><span class="line">        si = setTypeInitIterator(dstset);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyBulkCBuffer(c,ele,sdslen(ele));</span><br><span class="line">            sdsfree(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">        server.lazyfree_lazy_server_del ? freeObjAsync(dstset) :</span><br><span class="line">                                          decrRefCount(dstset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we have a target key where to store the resulting set</span></span><br><span class="line"><span class="comment">         * create this key with the result set inside */</span></span><br><span class="line">        <span class="keyword">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,</span><br><span class="line">                op == SET_OP_UNION ? <span class="string">&quot;sunionstore&quot;</span> : <span class="string">&quot;sdiffstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>其他命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br><span class="line">SCARD key</span><br><span class="line">SMOVE source destination member</span><br><span class="line">SPOP key [count]</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line">SREM key member [member ...]</span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码位置：t_set.c/server.h&lt;/p&gt;
&lt;p&gt;set对象底层编码方式有两种，&lt;code&gt;intset&lt;/code&gt;或&lt;code&gt;hashtable&lt;/code&gt;。&lt;br&gt;使用intset编码的条件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集合对象中所有元素都是整数值。&lt;/li&gt;
&lt;li&gt;集合对象保存的元素个数不超过512个。（可通过redis.conf配置：set_max_intset_entries）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/categories/Redis/"/>
    
    <category term="2-object" scheme="https://blog.grizzlys.top/categories/Redis/2-object/"/>
    
    
    <category term="Redis" scheme="https://blog.grizzlys.top/tags/Redis/"/>
    
  </entry>
  
</feed>
