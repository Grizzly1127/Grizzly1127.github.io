<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grizzly</title>
  
  <subtitle>记录点点滴滴</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-21T09:52:40.613Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>李辉雄</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis源码-对象系统object</title>
    <link href="http://example.com/Redis/second-stage/redis-parse-object/"/>
    <id>http://example.com/Redis/second-stage/redis-parse-object/</id>
    <published>2020-09-21T09:23:23.000Z</published>
    <updated>2020-09-21T09:52:40.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：object.c/server.h</p><p>在之前的文章中，我们介绍了redis底层的数据结构，比如简单动态字符串，双端链表，跳跃表，字典，整数集合，压缩列表，快速列表，基数树，紧凑列表等。<br><a id="more"></a><br>然而Redis没有用这些数据结构来实现键值对的数据库，而是在这些数据结构之上又封装了一层RedisObject，RedisObject有6种类型：string字符串，hash散列，set集合，zset有序集合，list列表，stream消息队列这些类型是面向用户的，有些对象内部至少有两种编码方式，不同的编码方式适用于不同的使用场景。<br>Redis对象带有引用计数功能，类似于智能指针，当引用计数为0时，对象将会被自动释放。<br>Redis还会对每一个对象记录其最近被使用时间，从而计算对象的空转时长，便于在适当的时候释放内存。</p><p>redis对象的类型和其对应使用的编码方式（数据结构）：<br>|type|encoding|<br>|—-|—-|<br>|OBJ_STRING|OBJ_ENCODING_RAW ,OBJ_ENCODING_INT ,OBJ_ENCODING_EMBSTR|<br>|OBJ_LIST|OBJ_ENCODING_QUICKLIST|<br>|OBJ_SET|OBJ_ENCODING_INTSET ,OBJ_ENCODING_HT|<br>|OBJ_ZSET|OBJ_ENCODING_ZIPLIST ,OBJ_ENCODING_SKIPLIST|<br>|OBJ_HASH|OBJ_ENCODING_ZIPLIST ,OBJ_ENCODING_HT|<br>|OBJ_STREAM|OBJ_ENCODING_STREAM|</p><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type：标识redis对象的七种类型，占用4个位</span></span><br><span class="line"><span class="comment">encoding：标识redis对象的编码方式，也就是ptr所指向的数据用何种数据结构作为底层实现方式，占用4个位</span></span><br><span class="line"><span class="comment">lru:最后一次被访问的时间，占用24个位</span></span><br><span class="line"><span class="comment">refcount：引用计数，实现自动内存回收机制。</span></span><br><span class="line"><span class="comment">    1. 当创建一个对象时，其引用计数初始化为1；</span></span><br><span class="line"><span class="comment">    2. 当这个对象被一个新程序使用时，其引用计数加1；</span></span><br><span class="line"><span class="comment">    3. 当这个对象不再被一个程序使用时，其引用计数减1；</span></span><br><span class="line"><span class="comment">    4. 当引用计数为0时，释放该对象，回收内存。</span></span><br><span class="line"><span class="comment">ptr：指向真正的存储结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 七种对象类型 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_MODULE 5    <span class="comment">/* Module object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STREAM 6    <span class="comment">/* Stream object. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 11种对象编码类型，不同的对象类型会根据实际情况选择不同的编码类型 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span> <span class="comment">// sds简单动态字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span> <span class="comment">// long类型的整数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span> <span class="comment">// dict字典</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span> <span class="comment">// 不再使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span> <span class="comment">// adlist双端链表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span> <span class="comment">// ziplist压缩列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span> <span class="comment">// intset整数集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span> <span class="comment">// skiplist跳跃表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span> <span class="comment">// EMBSTR编码的简单动态字符串sds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span> <span class="comment">// quicklist快速列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span> <span class="comment">// stream消息队列</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当字符串小于44字节时，使用EMBSTR编码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Redis object implementation */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span></span>; <span class="comment">// 引用计数减1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCountVoid</span><span class="params">(<span class="keyword">void</span> *o)</span></span>; <span class="comment">// 调用decrRefCount</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span></span>; <span class="comment">// 引用计数加1</span></span><br><span class="line"><span class="function">robj *<span class="title">makeObjectShared</span><span class="params">(robj *o)</span></span>; <span class="comment">// 共享对象，将引用计数设定为一个特殊值OBJ_SHARED_REFCOUNT(INT_MAX)</span></span><br><span class="line"><span class="function">robj *<span class="title">resetRefCount</span><span class="params">(robj *obj)</span></span>; <span class="comment">// 将引用计数置为0</span></span><br><span class="line"><span class="comment">// free object-------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放字符串对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放列表对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放有序集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 释放哈希对象</span></span><br><span class="line"><span class="comment">// ------------------------</span></span><br><span class="line"><span class="comment">// create object-----------</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 创建对象，设定类型</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建SDS的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建EMBSTR编码的字符串对象</span></span><br><span class="line"><span class="comment">// ------------------------</span></span><br><span class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(<span class="keyword">const</span> robj *o)</span></span>; <span class="comment">// 复制string对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSdsRepresentableAsLongLong</span><span class="params">(sds s, <span class="keyword">long</span> <span class="keyword">long</span> *llval)</span></span>; <span class="comment">// sds转为long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isObjectRepresentableAsLongLong</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *llongval)</span></span>; <span class="comment">// 判断一个对象是否能用long long表示</span></span><br><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span></span>; <span class="comment">// 尝试对字符串对象进行编码，以节省空间，如果无法压缩，则增加引用计数</span></span><br><span class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span></span>; <span class="comment">// 获取字符串编码对象的解码版本，能解码则返回一个新的对象，不能则增加引用计数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">stringObjectLen</span><span class="params">(robj *o)</span></span>; <span class="comment">// 获取字符串对象的长度</span></span><br><span class="line"><span class="comment">// create object-----------</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>; <span class="comment">// 根据传入的longlong整型值，创建一个字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLongForValue</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value, <span class="keyword">int</span> humanfriendly)</span></span>; <span class="comment">// 根据传入的long double类型值，创建一个字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createQuicklistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建快速列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建压缩列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建整数集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建hash对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建有序集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建压缩列表编码的有序集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStreamObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建消息队列对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createModuleObject</span><span class="params">(moduleType *mt, <span class="keyword">void</span> *value)</span></span>; <span class="comment">// 创建模块对象</span></span><br><span class="line"><span class="comment">// -------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// getLongLongFromObject函数的封装，如果发生错误可以发回指定响应消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkType</span><span class="params">(client *c, robj *o, <span class="keyword">int</span> type)</span></span>; <span class="comment">// 检查o的类型是否与type一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// getLongLongFromObject的封装，如果发生错误则可以发出指定的错误消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// getDoubleFromObject的封装，如果发生错误可以发回指定响应消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObject</span><span class="params">(<span class="keyword">const</span> robj *o, <span class="keyword">double</span> *target)</span></span>; <span class="comment">// 从字符串对象中解码出一个double类型的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target)</span></span>; <span class="comment">// 从字符串对象中解码出一个long long类型的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongDoubleFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">double</span> *target)</span></span>; <span class="comment">// 从字符串对象中解码出一个long double类型的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongDoubleFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="keyword">long</span> <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>; <span class="comment">// getLongDoubleFromObject的封装，如果发生错误可以发回指定响应消息</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strEncoding</span><span class="params">(<span class="keyword">int</span> encoding)</span></span>; <span class="comment">// 返回编码对应的字符串名称</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 以二进制方式比较两个字符串对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">collateStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 以本地指定的文字排列次序coll方式比较两个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">equalStringObjects</span><span class="params">(robj *a, robj *b)</span></span>; <span class="comment">// 比较两个字符串对象是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span></span>; <span class="comment">// 计算给定对象的闲置时长，使用近似LRU算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimStringObjectIfNeeded</span><span class="params">(robj *o)</span></span>; <span class="comment">// 优化字符串对象中的SDS字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW || objptr-&gt;encoding == OBJ_ENCODING_EMBSTR)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：object.c/server.h&lt;/p&gt;
&lt;p&gt;在之前的文章中，我们介绍了redis底层的数据结构，比如简单动态字符串，双端链表，跳跃表，字典，整数集合，压缩列表，快速列表，基数树，紧凑列表等。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="second-stage" scheme="http://example.com/categories/Redis/second-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-基数统计hyperloglog</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-hyperloglog/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-hyperloglog/</id>
    <published>2020-09-21T09:19:20.000Z</published>
    <updated>2020-09-21T09:52:29.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：hyperloglog.c  </p><p>hyperloglog是一种算法，它提供了不精确的去重计数方案。redis的hyperloglog内部维护了16384个桶来记录各自桶的元素数量，当一个元素到来时，它会散列到其中一个桶，以一定的概率影响到这个桶的计数值。因为是概率算法，所以单个桶的计数值并不准确，但是将所有桶的计数值进行调合均值累加起来后，结果就会非常接近真实的计数值。<br><a id="more"></a><br><a href="http://content.research.neustar.biz/blog/hll.html">算法演示</a></p><p>当数据量很大时，redis采用密集模式，它将分配了16384个桶，每个桶占用6个bit空间，所以hyperloglog实际占用的空间大约为(16384*6bit/8+16=12304byte≈12k)左右的内存空间就可以统计大量的不同元素的基数。<br>当在计数比较小的时候，大多数桶的计数值都是0，此时redis采用了稀疏模式存储，稀疏模式存储的占用空间远远小于12k字节，而密集模式存储占用的空间固定为12k。  </p><p><strong>稀疏模式存储结构：</strong><br><img src="/Redis/first-stage/redis-parse-hyperloglog/hyperloglog_sparse.png" alt="sparse"><br>当连续多个桶的计数值为0时，redis使用一个字节来表示连续有多少个桶的值为0：00xxxxxx。前缀00表示接下来的6bit的整数值<strong>加1</strong>就是连续为0的桶的数量。比如，00101011：表示连续 101011(bin) + 1 = 44(dec)个桶的计数值都为0。6个bit最多表示能表示连续64个桶的值为0，所以redis将用两个字节表示多个多于64个连续0的桶数：01xxxxxx yyyyyyyy，后面的14个bit可以表示连续16384个桶的值为0。这就是hyperloglog数据结构中16384个桶的初始化状态。<br>当连续多个桶的计数值非0时，则使用一个字节：1vvvvvxx表示，其中中间的5个bit vvvvv表示计数值，后面的2个bit xx表示连续几个桶，所以稀疏模式的计数值最大值为11111(bin)+1=32(dec)，最多连续桶为11(bin)+1=4(dec)，当计数值超过32时，redis会立即转为密集模式（不可逆的）。</p><p><strong>密集模式存储结构：</strong><br>是由连续的16384个6bit串成的字符串位图。需要注意，普通的字节位序是左边高位右边低位，而在此处的字节位序是左边低位右边高位，所以需要进行倒置。<br><img src="/Redis/first-stage/redis-parse-hyperloglog/hyperloglog_dense_byte.png" alt="dense_byte"><br>以下是密集模式存储结构：<br><img src="/Redis/first-stage/redis-parse-hyperloglog/hyperloglog_dense.png" alt="dense"><br><a href="https://blog.csdn.net/u013474436/article/details/88945767">参考这篇文章，图文讲解的很清楚</a></p><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">4</span>];      <span class="comment">/* &quot;HYLL&quot;固定值，用于标识hyperloglog键 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> encoding;   <span class="comment">/* HLL_DENSE密集模式 or HLL_SPARSE稀疏模式. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* Reserved for future use, must be zero.保留字段 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* Cached cardinality, little endian.基数缓存，存储上一次计算的基数 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> registers[]; <span class="comment">/* Data bytes. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The cached cardinality MSB is used to signal validity of the cached value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_INVALIDATE_CACHE(hdr) (hdr)-&gt;card[7] |= (1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_VALID_CACHE(hdr) (((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P 14 <span class="comment">/* The greater is P, the smaller the error. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_Q (64-HLL_P) <span class="comment">/* The number of bits of the hash value used for</span></span></span><br><span class="line"><span class="meta"><span class="comment">                            determining the number of leading zeros. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_REGISTERS (1&lt;&lt;HLL_P) <span class="comment">/* With P=14, 16384 registers. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P_MASK (HLL_REGISTERS-1) <span class="comment">/* Mask to index register. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_BITS 6 <span class="comment">/* Enough to count up to 63 leading zeroes. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_REGISTER_MAX ((1&lt;&lt;HLL_BITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_HDR_SIZE sizeof(struct hllhdr) <span class="comment">// hll结构体的大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_SIZE (HLL_HDR_SIZE+((HLL_REGISTERS*HLL_BITS+7)/8)) <span class="comment">// 密集模式占用空间大小（为什么会+7？这里不是很理解）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE 0 <span class="comment">/* Dense encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE 1 <span class="comment">/* Sparse encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_RAW 255 <span class="comment">/* Only used internally, never exposed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_MAX_ENCODING 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *invalid_hll_err = <span class="string">&quot;-INVALIDOBJ Corrupted HLL object detected\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密集模式获取指定桶的数据</span></span><br><span class="line"><span class="comment">/* Store the value of the register at position &#x27;regnum&#x27; into variable &#x27;target&#x27;.</span></span><br><span class="line"><span class="comment"> * &#x27;p&#x27; is an array of unsigned bytes. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_GET_REGISTER(target,p,regnum) do &#123; \</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *_p = (<span class="keyword">uint8_t</span>*) p; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _byte = regnum*HLL_BITS/<span class="number">8</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb = regnum*HLL_BITS&amp;<span class="number">7</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb8 = <span class="number">8</span> - _fb; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b0 = _p[_byte]; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b1 = _p[_byte+<span class="number">1</span>]; \</span><br><span class="line">    target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; HLL_REGISTER_MAX; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密集模式填充指定桶的数据</span></span><br><span class="line"><span class="comment">/* Set the value of the register at position &#x27;regnum&#x27; to &#x27;val&#x27;.</span></span><br><span class="line"><span class="comment"> * &#x27;p&#x27; is an array of unsigned bytes. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_SET_REGISTER(p,regnum,val) do &#123; \</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *_p = (<span class="keyword">uint8_t</span>*) p; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _byte = regnum*HLL_BITS/<span class="number">8</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb = regnum*HLL_BITS&amp;<span class="number">7</span>; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb8 = <span class="number">8</span> - _fb; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _v = val; \</span><br><span class="line">    _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \</span><br><span class="line">    _p[_byte] |= _v &lt;&lt; _fb; \</span><br><span class="line">    _p[_byte+<span class="number">1</span>] &amp;= ~(HLL_REGISTER_MAX &gt;&gt; _fb8); \</span><br><span class="line">    _p[_byte+<span class="number">1</span>] |= _v &gt;&gt; _fb8; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macros to access the sparse representation.</span></span><br><span class="line"><span class="comment"> * The macros parameter is expected to be an uint8_t pointer. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_BIT 0x40 <span class="comment">/* 01xxxxxx */</span> <span class="comment">// 计数值为0的双字节头两位是01</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_BIT 0x80 <span class="comment">/* 1vvvvvxx */</span> <span class="comment">// 计数值非0的单字节头一位是1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_ZERO(p) (((*(p)) &amp; 0xc0) == 0) <span class="comment">/* 00xxxxxx */</span> <span class="comment">// 判断是否是计数值为0的单字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_XZERO(p) (((*(p)) &amp; 0xc0) == HLL_SPARSE_XZERO_BIT) <span class="comment">// 判断是否是计数值为0的双字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_VAL(p) ((*(p)) &amp; HLL_SPARSE_VAL_BIT) <span class="comment">// 判断计数值非0的计数值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_LEN(p) (((*(p)) &amp; 0x3f)+1) <span class="comment">// 获取单字节计数值为0的桶的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_LEN(p) (((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1) <span class="comment">// 获取双字节计数值为0的桶的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_VALUE(p) ((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1) <span class="comment">// 获取计数值非0的计数值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_LEN(p) (((*(p)) &amp; 0x3)+1) <span class="comment">// 获取计数值非0的桶的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_MAX_VALUE 32 <span class="comment">// 计数值最大值为32（超过则转为密集模式）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_MAX_LEN 4 <span class="comment">// 计数值非0的连续桶的个数为4</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_MAX_LEN 64 <span class="comment">// 单字节计数值为0的连续桶的个数为64（连续的桶个数超过64时，用双字节表示）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_MAX_LEN 16384 <span class="comment">// 双字节计数值为0的连续桶的个数为16384</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_SET(p,val,len) do &#123; \</span></span><br><span class="line">    *(p) = (((val)<span class="number">-1</span>)&lt;&lt;<span class="number">2</span>|((len)<span class="number">-1</span>))|HLL_SPARSE_VAL_BIT; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>) <span class="comment">// 设置计数值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_SET(p,len) do &#123; \</span></span><br><span class="line">    *(p) = (len)<span class="number">-1</span>; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>) <span class="comment">// 设置单字节计数值为0的桶的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_SET(p,len) do &#123; \</span></span><br><span class="line">    <span class="keyword">int</span> _l = (len)<span class="number">-1</span>; \</span><br><span class="line">    *(p) = (_l&gt;&gt;<span class="number">8</span>) | HLL_SPARSE_XZERO_BIT; \</span><br><span class="line">    *((p)+<span class="number">1</span>) = (_l&amp;<span class="number">0xff</span>); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>) <span class="comment">// 设置双字节计数值为0的桶的个数（初始化的值： 0111 1111 1111 1111）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_ALPHA_INF 0.721347520444481703680 <span class="comment">/* constant for 0.5/ln(2) */</span></span></span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建hyperloglog对象，默认sparse encoding（稀疏模式），根据需要升级为密集模式</span></span><br><span class="line"><span class="comment">/* Create an HLL object. We always create the HLL using sparse encoding.</span></span><br><span class="line"><span class="comment"> * This will be upgraded to the dense representation as needed. */</span></span><br><span class="line"><span class="function">robj *<span class="title">createHLLObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">uint8_t</span> *p;</span><br><span class="line">     <span class="comment">// sparselen = HLL_HDR_SIZE(16) + 2 = 18, 16是hll的数据结构大小，2个字节是表示01xxxxxx yyyyyyyyy连续16384个桶的计数值为0</span></span><br><span class="line">    <span class="keyword">int</span> sparselen = HLL_HDR_SIZE +</span><br><span class="line">                    (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN<span class="number">-1</span>)) /</span><br><span class="line">                     HLL_SPARSE_XZERO_MAX_LEN)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> aux;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Populate the sparse representation with as many XZERO opcodes as</span></span><br><span class="line"><span class="comment">     * needed to represent all the registers. */</span></span><br><span class="line">    aux = HLL_REGISTERS;</span><br><span class="line">    s = sdsnewlen(<span class="literal">NULL</span>,sparselen);</span><br><span class="line">    p = (<span class="keyword">uint8_t</span>*)s + HLL_HDR_SIZE;</span><br><span class="line">    <span class="keyword">while</span>(aux) &#123;</span><br><span class="line">        <span class="keyword">int</span> xzero = HLL_SPARSE_XZERO_MAX_LEN;</span><br><span class="line">        <span class="keyword">if</span> (xzero &gt; aux) xzero = aux;</span><br><span class="line">        HLL_SPARSE_XZERO_SET(p,xzero);</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">        aux -= xzero;</span><br><span class="line">    &#125;</span><br><span class="line">    serverAssert((p-(<span class="keyword">uint8_t</span>*)s) == sparselen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the actual object. */</span></span><br><span class="line">    o = createObject(OBJ_STRING,s);</span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line">    <span class="built_in">memcpy</span>(hdr-&gt;magic,<span class="string">&quot;HYLL&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    hdr-&gt;encoding = HLL_SPARSE;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加元素:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="comment">/* Call hllDenseAdd() or hllSparseAdd() according to the HLL encoding. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllAdd</span><span class="params">(robj *o, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span> = <span class="title">o</span>-&gt;<span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">switch</span>(hdr-&gt;encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> HLL_DENSE: <span class="keyword">return</span> hllDenseAdd(hdr-&gt;registers,ele,elesize); <span class="comment">// 密集模式</span></span><br><span class="line">    <span class="keyword">case</span> HLL_SPARSE: <span class="keyword">return</span> hllSparseAdd(o,ele,elesize); <span class="comment">// 稀疏模式</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Invalid representation. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于计算hash后的值中第一个1出现的位置</span></span><br><span class="line"><span class="comment">/* Given a string element to add to the HyperLogLog, returns the length</span></span><br><span class="line"><span class="comment"> * of the pattern 000..1 of the element hash. As a side effect &#x27;regp&#x27; is</span></span><br><span class="line"><span class="comment"> * set to the register index this element hashes to. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllPatLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize, <span class="keyword">long</span> *regp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> hash, bit, index;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count the number of zeroes starting from bit HLL_REGISTERS</span></span><br><span class="line"><span class="comment">     * (that is a power of two corresponding to the first bit we don&#x27;t use</span></span><br><span class="line"><span class="comment">     * as index). The max run can be 64-P+1 = Q+1 bits.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that the final &quot;1&quot; ending the sequence of zeroes must be</span></span><br><span class="line"><span class="comment">     * included in the count, so if we find &quot;001&quot; the count is 3, and</span></span><br><span class="line"><span class="comment">     * the smallest count possible is no zeroes at all, just a 1 bit</span></span><br><span class="line"><span class="comment">     * at the first position, that is a count of 1.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This may sound like inefficient, but actually in the average case</span></span><br><span class="line"><span class="comment">     * there are high probabilities to find a 1 after a few iterations. */</span></span><br><span class="line">    hash = MurmurHash64A(ele,elesize,<span class="number">0xadc83b19</span>ULL);</span><br><span class="line">    index = hash &amp; HLL_P_MASK; <span class="comment">/* Register index. */</span> <span class="comment">// 计算应该放在哪个桶中，与操作，保证index在16384范围内</span></span><br><span class="line">    hash &gt;&gt;= HLL_P; <span class="comment">/* Remove bits used to address the register. */</span></span><br><span class="line">    hash |= ((<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;HLL_Q); <span class="comment">/* Make sure the loop terminates</span></span><br><span class="line"><span class="comment">                                     and count will be &lt;= Q+1. */</span> <span class="comment">//为了保证循环能够终止</span></span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">    count = <span class="number">1</span>; <span class="comment">/* Initialized to 1 since we count the &quot;00000...1&quot; pattern. */</span></span><br><span class="line">    <span class="comment">// 查找1出现的位置，并计数</span></span><br><span class="line">    <span class="keyword">while</span>((hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *regp = (<span class="keyword">int</span>) index;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>稀疏模式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏模式添加元素实现</span></span><br><span class="line"><span class="comment">/* &quot;Add&quot; the element in the sparse hyperloglog data structure.</span></span><br><span class="line"><span class="comment"> * Actually nothing is added, but the max 0 pattern counter of the subset</span></span><br><span class="line"><span class="comment"> * the element belongs to is incremented if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is actually a wrapper for hllSparseSet(), it only performs</span></span><br><span class="line"><span class="comment"> * the hashshing of the elmenet to obtain the index and zeros run length. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseAdd</span><span class="params">(robj *o, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">uint8_t</span> count = hllPatLen(ele,elesize,&amp;index);</span><br><span class="line">    <span class="comment">/* Update the register if this element produced a longer run of zeroes. */</span></span><br><span class="line">    <span class="keyword">return</span> hllSparseSet(o,index,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稀疏模式插入，当计数值大于32时，立即转为密集模式并插入</span></span><br><span class="line"><span class="comment">/* Low level function to set the sparse HLL register at &#x27;index&#x27; to the</span></span><br><span class="line"><span class="comment"> * specified value if the current value is smaller than &#x27;count&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The object &#x27;o&#x27; is the String object holding the HLL. The function requires</span></span><br><span class="line"><span class="comment"> * a reference to the object in order to be able to enlarge the string if</span></span><br><span class="line"><span class="comment"> * needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success, the function returns 1 if the cardinality changed, or 0</span></span><br><span class="line"><span class="comment"> * if the register for this element was not updated.</span></span><br><span class="line"><span class="comment"> * On error (if the representation is invalid) -1 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As a side effect the function may promote the HLL representation from</span></span><br><span class="line"><span class="comment"> * sparse to dense: this happens when a register requires to be set to a value</span></span><br><span class="line"><span class="comment"> * not representable with the sparse representation, or when the resulting</span></span><br><span class="line"><span class="comment"> * size would be greater than server.hll_sparse_max_bytes. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseSet</span><span class="params">(robj *o, <span class="keyword">long</span> index, <span class="keyword">uint8_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> oldcount, *sparse, *end, *p, *prev, *next;</span><br><span class="line">    <span class="keyword">long</span> first, span;</span><br><span class="line">    <span class="keyword">long</span> is_zero = <span class="number">0</span>, is_xzero = <span class="number">0</span>, is_val = <span class="number">0</span>, runlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the count is too big to be representable by the sparse representation</span></span><br><span class="line"><span class="comment">     * switch to dense representation. */</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; HLL_SPARSE_VAL_MAX_VALUE) <span class="keyword">goto</span> promote; <span class="comment">// 当计数值大于32时，立即转为密集模式并插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When updating a sparse representation, sometimes we may need to</span></span><br><span class="line"><span class="comment">     * enlarge the buffer for up to 3 bytes in the worst case (XZERO split</span></span><br><span class="line"><span class="comment">     * into XZERO-VAL-XZERO). Make sure there is enough space right now</span></span><br><span class="line"><span class="comment">     * so that the pointers we take during the execution of the function</span></span><br><span class="line"><span class="comment">     * will be valid all the time. */</span></span><br><span class="line">    o-&gt;ptr = sdsMakeRoomFor(o-&gt;ptr,<span class="number">3</span>); <span class="comment">// 扩大3个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: we need to locate the opcode we need to modify to check</span></span><br><span class="line"><span class="comment">     * if a value update is actually needed. */</span></span><br><span class="line">    <span class="comment">// 第一步，需要定位到需要修改的节点位置，判断值是否需要被修改</span></span><br><span class="line">    sparse = p = ((<span class="keyword">uint8_t</span>*)o-&gt;ptr) + HLL_HDR_SIZE;</span><br><span class="line">    end = p + sdslen(o-&gt;ptr) - HLL_HDR_SIZE;</span><br><span class="line"></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    prev = <span class="literal">NULL</span>; <span class="comment">/* Points to previous opcode at the end of the loop. */</span></span><br><span class="line">    next = <span class="literal">NULL</span>; <span class="comment">/* Points to the next opcode at the end of the loop. */</span></span><br><span class="line">    span = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">        <span class="keyword">long</span> oplen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set span to the number of registers covered by this opcode.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is the most performance critical loop of the sparse</span></span><br><span class="line"><span class="comment">         * representation. Sorting the conditionals from the most to the</span></span><br><span class="line"><span class="comment">         * least frequent opcode in many-bytes sparse HLLs is faster. */</span></span><br><span class="line">        oplen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            span = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_VAL(p)) &#123;</span><br><span class="line">            span = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* XZERO. */</span></span><br><span class="line">            span = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">            oplen = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Break if this opcode covers the register as &#x27;index&#x27;. */</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= first+span<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        prev = p;</span><br><span class="line">        p += oplen;</span><br><span class="line">        first += span;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (span == <span class="number">0</span> || p &gt;= end) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Invalid format. */</span></span><br><span class="line"></span><br><span class="line">    next = HLL_SPARSE_IS_XZERO(p) ? p+<span class="number">2</span> : p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (next &gt;= end) next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cache current opcode type to avoid using the macro again and</span></span><br><span class="line"><span class="comment">     * again for something that will not change.</span></span><br><span class="line"><span class="comment">     * Also cache the run-length of the opcode. */</span></span><br><span class="line">    <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">        is_zero = <span class="number">1</span>;</span><br><span class="line">        runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">        is_xzero = <span class="number">1</span>;</span><br><span class="line">        runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        is_val = <span class="number">1</span>;</span><br><span class="line">        runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: After the loop:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#x27;first&#x27; stores to the index of the first register covered</span></span><br><span class="line"><span class="comment">     *  by the current opcode, which is pointed by &#x27;p&#x27;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#x27;next&#x27; ad &#x27;prev&#x27; store respectively the next and previous opcode,</span></span><br><span class="line"><span class="comment">     *  or NULL if the opcode at &#x27;p&#x27; is respectively the last or first.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#x27;span&#x27; is set to the number of registers covered by the current</span></span><br><span class="line"><span class="comment">     *  opcode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * There are different cases in order to update the data structure</span></span><br><span class="line"><span class="comment">     * in place without generating it from scratch:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A) If it is a VAL opcode already set to a value &gt;= our &#x27;count&#x27;</span></span><br><span class="line"><span class="comment">     *    no update is needed, regardless of the VAL run-length field.</span></span><br><span class="line"><span class="comment">     *    In this case PFADD returns 0 since no changes are performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * B) If it is a VAL opcode with len = 1 (representing only our</span></span><br><span class="line"><span class="comment">     *    register) and the value is less than &#x27;count&#x27;, we just update it</span></span><br><span class="line"><span class="comment">     *    since this is a trivial case. */</span></span><br><span class="line">    <span class="keyword">if</span> (is_val) &#123;</span><br><span class="line">        oldcount = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">        <span class="comment">/* Case A. */</span></span><br><span class="line">        <span class="keyword">if</span> (oldcount &gt;= count) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Case B. */</span></span><br><span class="line">        <span class="keyword">if</span> (runlen == <span class="number">1</span>) &#123;</span><br><span class="line">            HLL_SPARSE_VAL_SET(p,count,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">goto</span> updated;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C) Another trivial to handle case is a ZERO opcode with a len of 1.</span></span><br><span class="line"><span class="comment">     * We can just replace it with a VAL opcode with our value and len of 1. */</span></span><br><span class="line">    <span class="keyword">if</span> (is_zero &amp;&amp; runlen == <span class="number">1</span>) &#123;</span><br><span class="line">        HLL_SPARSE_VAL_SET(p,count,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">goto</span> updated;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* D) General case.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The other cases are more complex: our register requires to be updated</span></span><br><span class="line"><span class="comment">     * and is either currently represented by a VAL opcode with len &gt; 1,</span></span><br><span class="line"><span class="comment">     * by a ZERO opcode with len &gt; 1, or by an XZERO opcode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In those cases the original opcode must be split into multiple</span></span><br><span class="line"><span class="comment">     * opcodes. The worst case is an XZERO split in the middle resuling into</span></span><br><span class="line"><span class="comment">     * XZERO - VAL - XZERO, so the resulting sequence max length is</span></span><br><span class="line"><span class="comment">     * 5 bytes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We perform the split writing the new sequence into the &#x27;new&#x27; buffer</span></span><br><span class="line"><span class="comment">     * with &#x27;newlen&#x27; as length. Later the new sequence is inserted in place</span></span><br><span class="line"><span class="comment">     * of the old one, possibly moving what is on the right a few bytes</span></span><br><span class="line"><span class="comment">     * if the new sequence is longer than the older one. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> seq[<span class="number">5</span>], *n = seq;</span><br><span class="line">    <span class="keyword">int</span> last = first+span<span class="number">-1</span>; <span class="comment">/* Last register covered by the sequence. */</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_zero || is_xzero) &#123;</span><br><span class="line">        <span class="comment">/* Handle splitting of ZERO / XZERO. */</span></span><br><span class="line">        <span class="keyword">if</span> (index != first) &#123;</span><br><span class="line">            len = index-first;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; HLL_SPARSE_ZERO_MAX_LEN) &#123;</span><br><span class="line">                HLL_SPARSE_XZERO_SET(n,len);</span><br><span class="line">                n += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HLL_SPARSE_ZERO_SET(n,len);</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HLL_SPARSE_VAL_SET(n,count,<span class="number">1</span>);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span> (index != last) &#123;</span><br><span class="line">            len = last-index;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; HLL_SPARSE_ZERO_MAX_LEN) &#123;</span><br><span class="line">                HLL_SPARSE_XZERO_SET(n,len);</span><br><span class="line">                n += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HLL_SPARSE_ZERO_SET(n,len);</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Handle splitting of VAL. */</span></span><br><span class="line">        <span class="keyword">int</span> curval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != first) &#123;</span><br><span class="line">            len = index-first;</span><br><span class="line">            HLL_SPARSE_VAL_SET(n,curval,len);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        HLL_SPARSE_VAL_SET(n,count,<span class="number">1</span>);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span> (index != last) &#123;</span><br><span class="line">            len = last-index;</span><br><span class="line">            HLL_SPARSE_VAL_SET(n,curval,len);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: substitute the new sequence with the old one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we already allocated space on the sds string</span></span><br><span class="line"><span class="comment">     * calling sdsMakeRoomFor(). */</span></span><br><span class="line">     <span class="keyword">int</span> seqlen = n-seq;</span><br><span class="line">     <span class="keyword">int</span> oldlen = is_xzero ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> deltalen = seqlen-oldlen;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (deltalen &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         sdslen(o-&gt;ptr)+deltalen &gt; server.hll_sparse_max_bytes) <span class="keyword">goto</span> promote;</span><br><span class="line">     <span class="keyword">if</span> (deltalen &amp;&amp; next) memmove(next+deltalen,next,end-next);</span><br><span class="line">     sdsIncrLen(o-&gt;ptr,deltalen);</span><br><span class="line">     <span class="built_in">memcpy</span>(p,seq,seqlen);</span><br><span class="line">     end += deltalen;</span><br><span class="line"></span><br><span class="line">updated:</span><br><span class="line">    <span class="comment">/* Step 4: Merge adjacent values if possible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The representation was updated, however the resulting representation</span></span><br><span class="line"><span class="comment">     * may not be optimal: adjacent VAL opcodes can sometimes be merged into</span></span><br><span class="line"><span class="comment">     * a single one. */</span></span><br><span class="line">    p = prev ? prev : sparse;</span><br><span class="line">    <span class="keyword">int</span> scanlen = <span class="number">5</span>; <span class="comment">/* Scan up to 5 upcodes starting from prev. */</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; end &amp;&amp; scanlen--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">            p += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            p++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We need two adjacent VAL opcodes to try a merge, having</span></span><br><span class="line"><span class="comment">         * the same value, and a len that fits the VAL opcode max len. */</span></span><br><span class="line">        <span class="keyword">if</span> (p+<span class="number">1</span> &lt; end &amp;&amp; HLL_SPARSE_IS_VAL(p+<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">            <span class="keyword">int</span> v2 = HLL_SPARSE_VAL_VALUE(p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = HLL_SPARSE_VAL_LEN(p)+HLL_SPARSE_VAL_LEN(p+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= HLL_SPARSE_VAL_MAX_LEN) &#123;</span><br><span class="line">                    HLL_SPARSE_VAL_SET(p+<span class="number">1</span>,v1,len);</span><br><span class="line">                    memmove(p,p+<span class="number">1</span>,end-p);</span><br><span class="line">                    sdsIncrLen(o-&gt;ptr,<span class="number">-1</span>);</span><br><span class="line">                    end--;</span><br><span class="line">                    <span class="comment">/* After a merge we reiterate without incrementing &#x27;p&#x27;</span></span><br><span class="line"><span class="comment">                     * in order to try to merge the just merged value with</span></span><br><span class="line"><span class="comment">                     * a value on its right. */</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invalidate the cached cardinality. */</span></span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line">    HLL_INVALIDATE_CACHE(hdr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">promote: <span class="comment">/* Promote to dense representation. */</span></span><br><span class="line">    <span class="keyword">if</span> (hllSparseToDense(o) == C_ERR) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Corrupted HLL. */</span></span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to call hllDenseAdd() to perform the operation after the</span></span><br><span class="line"><span class="comment">     * conversion. However the result must be 1, since if we need to</span></span><br><span class="line"><span class="comment">     * convert from sparse to dense a register requires to be updated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that this in turn means that PFADD will make sure the command</span></span><br><span class="line"><span class="comment">     * is propagated to slaves / AOF, so if there is a sparse -&gt; dense</span></span><br><span class="line"><span class="comment">     * conversion, it will be performed in all the slaves as well. */</span></span><br><span class="line">    <span class="keyword">int</span> dense_retval = hllDenseSet(hdr-&gt;registers,index,count);</span><br><span class="line">    serverAssert(dense_retval == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dense_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>稀疏模式转为密集模式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Convert the HLL with sparse representation given as input in its dense</span></span><br><span class="line"><span class="comment"> * representation. Both representations are represented by SDS strings, and</span></span><br><span class="line"><span class="comment"> * the input representation is freed as a side effect.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns C_OK if the sparse representation was valid,</span></span><br><span class="line"><span class="comment"> * otherwise C_ERR is returned if the representation was corrupted. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseToDense</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    sds sparse = o-&gt;ptr, dense;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>, *<span class="title">oldhdr</span> = (<span class="title">struct</span> <span class="title">hllhdr</span>*)<span class="title">sparse</span>;</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, runlen, regval;</span><br><span class="line">    <span class="keyword">uint8_t</span> *p = (<span class="keyword">uint8_t</span>*)sparse, *end = p+sdslen(sparse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the representation is already the right one return ASAP. */</span></span><br><span class="line">    hdr = (struct hllhdr*) sparse;</span><br><span class="line">    <span class="keyword">if</span> (hdr-&gt;encoding == HLL_DENSE) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请HLL_DENSE_SIZE大小的空间用于密集模式</span></span><br><span class="line">    <span class="comment">/* Create a string of the right size filled with zero bytes.</span></span><br><span class="line"><span class="comment">     * Note that the cached cardinality is set to 0 as a side effect</span></span><br><span class="line"><span class="comment">     * that is exactly the cardinality of an empty HLL. */</span></span><br><span class="line">    dense = sdsnewlen(<span class="literal">NULL</span>,HLL_DENSE_SIZE);</span><br><span class="line">    hdr = (struct hllhdr*) dense;</span><br><span class="line">    *hdr = *oldhdr; <span class="comment">/* This will copy the magic and cached cardinality. */</span></span><br><span class="line">    hdr-&gt;encoding = HLL_DENSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将稀疏模式的数据导入到密集模式中</span></span><br><span class="line">    <span class="comment">/* Now read the sparse representation and set non-zero registers</span></span><br><span class="line"><span class="comment">     * accordingly. */</span></span><br><span class="line">    p += HLL_HDR_SIZE;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">            idx += runlen;</span><br><span class="line">            p++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">            runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">            idx += runlen;</span><br><span class="line">            p += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">            regval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">            <span class="keyword">if</span> ((runlen + idx) &gt; HLL_REGISTERS) <span class="keyword">break</span>; <span class="comment">/* Overflow. */</span></span><br><span class="line">            <span class="keyword">while</span>(runlen--) &#123;</span><br><span class="line">                HLL_DENSE_SET_REGISTER(hdr-&gt;registers,idx,regval);</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the sparse representation was valid, we expect to find idx</span></span><br><span class="line"><span class="comment">     * set to HLL_REGISTERS. */</span></span><br><span class="line">    <span class="keyword">if</span> (idx != HLL_REGISTERS) &#123;</span><br><span class="line">        sdsfree(dense);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the old representation and set the new one. */</span></span><br><span class="line">    sdsfree(o-&gt;ptr);</span><br><span class="line">    o-&gt;ptr = dense;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>密集模式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 密集模式添加元素实现</span></span><br><span class="line"><span class="comment">/* &quot;Add&quot; the element in the dense hyperloglog data structure.</span></span><br><span class="line"><span class="comment"> * Actually nothing is added, but the max 0 pattern counter of the subset</span></span><br><span class="line"><span class="comment"> * the element belongs to is incremented if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is just a wrapper to hllDenseSet(), performing the hashing of the</span></span><br><span class="line"><span class="comment"> * element in order to retrieve the index and zero-run count. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllDenseAdd</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">uint8_t</span> count = hllPatLen(ele,elesize,&amp;index);</span><br><span class="line">    <span class="comment">/* Update the register if this element produced a longer run of zeroes. */</span></span><br><span class="line">    <span class="keyword">return</span> hllDenseSet(registers,index,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level function to set the dense HLL register at &#x27;index&#x27; to the</span></span><br><span class="line"><span class="comment"> * specified value if the current value is smaller than &#x27;count&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;registers&#x27; is expected to have room for HLL_REGISTERS plus an</span></span><br><span class="line"><span class="comment"> * additional byte on the right. This requirement is met by sds strings</span></span><br><span class="line"><span class="comment"> * automatically since they are implicitly null terminated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function always succeed, however if as a result of the operation</span></span><br><span class="line"><span class="comment"> * the approximated cardinality changed, 1 is returned. Otherwise 0</span></span><br><span class="line"><span class="comment"> * is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllDenseSet</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">long</span> index, <span class="keyword">uint8_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> oldcount;</span><br><span class="line"></span><br><span class="line">    HLL_DENSE_GET_REGISTER(oldcount,registers,index);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; oldcount) &#123;</span><br><span class="line">        HLL_DENSE_SET_REGISTER(registers,index,count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：hyperloglog.c  &lt;/p&gt;
&lt;p&gt;hyperloglog是一种算法，它提供了不精确的去重计数方案。redis的hyperloglog内部维护了16384个桶来记录各自桶的元素数量，当一个元素到来时，它会散列到其中一个桶，以一定的概率影响到这个桶的计数值。因为是概率算法，所以单个桶的计数值并不准确，但是将所有桶的计数值进行调合均值累加起来后，结果就会非常接近真实的计数值。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-基数树rax</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-rax/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-rax/</id>
    <published>2020-09-21T09:09:04.000Z</published>
    <updated>2020-09-21T09:52:47.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：rax.c/rax.h</p><p>Redis 5.0版本引入的一个新的数据结构。目前主要用在stream这个数据结构上。Rax是一个有序字典树（基数树），按照key的字典序排列，支持快速定位、查找和删除操作。<br><a id="more"></a></p><p><font size="4">一、Rax数据结构：</font><br><img src="/Redis/first-stage/redis-parse-rax/rax_node.png" alt="rax_node"><br>字段说明：</p><ol><li>iskey：占用1个bit。表示该节点是否包含key。<ul><li>0：没有key</li><li>1：表示从头结点到该节点的父节点的路径完整的存储了key，查找的时候按子节点iskey=1判断key是否存在</li></ul></li><li>isnull：占用1个bit。表示该节点是否存储value值。</li><li>iscompr：占用1个bit。表示该节点是否为压缩节点，决定了data的存储结构（如果当前节点有多个子节点，为非压缩结构，如果只有一个子节点，则为压缩结构）。</li><li>size：占用29个bit。<ul><li>非压缩：子节点的数量</li><li>压缩：该节点字符个数</li></ul></li><li><p>data：柔性数组。包含路由键，子节点指针，value指针。为了提高cpu性能，data内存空间对齐(sizeof(void*))，所以会根据计算结果来进行相应的字节填充。</p><ul><li><p>非压缩节点的data伪代码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">     <span class="keyword">char</span>[] childKey; <span class="comment">// 路由键字符列表</span></span><br><span class="line">     raxNode*[] childNodes; <span class="comment">// 多个子节点指针</span></span><br><span class="line">     <span class="keyword">void</span>* value; <span class="comment">// 取决于 header 的 isNull 字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>压缩节点的data伪代码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span>[] childKey; <span class="comment">// 路由键字符列表</span></span><br><span class="line">        raxNode* childNodes; <span class="comment">// 单个子节点指针</span></span><br><span class="line">    &#125; child; <span class="comment">// 取决于 header 的 size 字段是否为零（如果是叶节点，则不存在child）</span></span><br><span class="line">     <span class="keyword">void</span>* value; <span class="comment">// 取决于 header 的 isNull 字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  非压缩与压缩节点图示如下：<br> <img src="/Redis/first-stage/redis-parse-rax/rax_compr.png" alt="data_compre"></p></li></ul></li></ol><p>&lt;/br&gt;</p><p><font size="4">二、Rax创建：</font><br><img src="/Redis/first-stage/redis-parse-rax/rax_new.png" alt="rax_new">  </p><p><font size="4">三、Rax插入：</font><br>ps：以下内容中的padding皆是为了内存对齐填充的空间。  </p><p><font size="3">1. 在空的基数树中插入数据：<dog, "狗是人类的朋友"></dog,></font><br>解析：<br>首先从头结点开始查找，因为这是一个空的基数树，所以直接将”dog”插入到节点中，设置该节点为压缩节点（iscompr=1）,padding部分是为了内存对齐而填充的，创建该节点的叶子结点，叶子结点中，iskey=1是表示从头结点到该节点的父节点是一个完整的key，iskey=1 &amp;&amp; isnull=0表示该叶子结点存储了key的value。<br>结果如下图：<br><img src="/Redis/first-stage/redis-parse-rax/rax_insert_1.png" alt="rax_insert_1"></p><p><font size="3">2. 接着插入数据：<cat, "猫咪很可爱"></cat,></font><br>解析：<br>接着上面的基数树，从头结点开始查找，当前头结点存储的第一个字符是’d’，与要插入的key的第一个字符’c’不相等，所以需要将该节点拆分成两个节点（拆分的过程可看我下面的源码注释），分别存储[d]和[og]，此时基数树有3个节点。随后将字符’c’插入到首节点中，接着创建’c’子节点，将[at]插入到子节点中，并创建子节点的叶节点插入value的指针，此时基数树存在5个节点，元素个数为2。<br>结果如下图：<br><img src="/Redis/first-stage/redis-parse-rax/rax_insert_2.png" alt="rax_insert_2"></p><p><font size="3">3. 接着插入数据：<doggy, "小狗很可爱"></doggy,></font><br>解析：<br>接着上面的基数树，从头结点开始查找key[‘doggy’]，发现头结点只有一个’d’，接着在’d’的子节点node_1中比较[‘oggy’]，找到[‘og’]，’og’的子节点为叶子结点，这时只要直接把[‘gy’]插入到叶子结点中，并创建一个’gy’的叶子结点插入value指针，即可完成插入。此时该基数树的节点数为6，元素个数为3。<br>结果如下图：<br><img src="/Redis/first-stage/redis-parse-rax/rax_insert_3.png" alt="rax_insert_3"></p><p><font size="3">4. 接着插入数据：<carry, "携带"></carry,></font><br>解析：<br>步骤如上一步，当匹配到节点[‘at’]时，需要拆分该节点为[‘a’]节点和[‘rt’]节点， [‘a’]为[‘rt’]的父节点，[‘rt’]节点为非压缩节点，’r’指针指向新的节点[‘ry’]，并创建[‘ry’]的叶子结点，’t’指针指向原先的叶子结点，基数树右边部分保持不变，完成插入操作。此时该基数树的节点数为9，元素个数为4。<br>结果如下图：<br><img src="/Redis/first-stage/redis-parse-rax/rax_insert_4.png" alt="rax_insert_4"></p><p><font size="4">四、Rax查找：</font><br>查找实现函数为：raxLowWalk()<br>从基数树的头节点往下遍历。比较节点的data值，并通过子节点指针往下继续遍历，直到找到完整的key。</p><p><font size="4">五、Rax删除：</font><br>分为几个步骤：  </p><ol><li>通过raxLowWalk()找到要删除的key的节点</li><li>接着判断删除后，附近节点是否可以进行压缩、收敛树的高度</li><li><p>如果可以压缩，则进行压缩合并，合并的条件如下：</p><ul><li>iskey=1的节点</li><li>子节点只有一个字符</li><li>父节点只有一个子节点</li></ul></li></ol><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_NODE_MAX_SIZE ((1&lt;&lt;29)-1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raxNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> iskey:<span class="number">1</span>;       <span class="comment">// 该节点是否包含key，1个bit</span></span><br><span class="line">    <span class="keyword">uint32_t</span> isnull:<span class="number">1</span>;      <span class="comment">// 该该节点是否存储value值，1个bit</span></span><br><span class="line">    <span class="keyword">uint32_t</span> iscompr:<span class="number">1</span>;     <span class="comment">// 该节点是否压缩，1个bit</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size:<span class="number">29</span>;       <span class="comment">// 子节点的数量或者是压缩字符串的长度，29个bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[];   <span class="comment">// 柔性数组，保存节点对应的数据，0bit</span></span><br><span class="line">&#125; raxNode; <span class="comment">// raxNode size：4byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rax</span> &#123;</span></span><br><span class="line">    raxNode *head;      <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">uint64_t</span> numele;    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> numnodes;  <span class="comment">// 节点数</span></span><br><span class="line">&#125; rax;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_STACK_STATIC_ITEMS 32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raxStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> **<span class="built_in">stack</span>; <span class="comment">// 存储每一层节点的地址</span></span><br><span class="line">    <span class="keyword">size_t</span> items, maxitems;</span><br><span class="line">    <span class="keyword">void</span> *static_items[RAX_STACK_STATIC_ITEMS];</span><br><span class="line">    <span class="keyword">int</span> oom;</span><br><span class="line">&#125; raxStack; <span class="comment">// 用于迭代，查找，删除的时候记录节点信息的栈结构，FILO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_ITER_STATIC_LEN 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_ITER_JUST_SEEKED (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_ITER_EOF (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAX_ITER_SAFE (1&lt;&lt;2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raxIterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    rax *rt;                <span class="comment">// 需要迭代的基数树</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *key;     <span class="comment">/* The current string. */</span></span><br><span class="line">    <span class="keyword">void</span> *data;             <span class="comment">/* Data associated to this key. */</span></span><br><span class="line">    <span class="keyword">size_t</span> key_len;         <span class="comment">/* Current key length. */</span></span><br><span class="line">    <span class="keyword">size_t</span> key_max;         <span class="comment">/* Max key len the current key buffer can hold. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key_static_string[RAX_ITER_STATIC_LEN];</span><br><span class="line">    raxNode *node;          <span class="comment">/* Current node. Only for unsafe iteration. */</span></span><br><span class="line">    raxStack <span class="built_in">stack</span>;         <span class="comment">/* Stack used for unsafe iteration. */</span></span><br><span class="line">    raxNodeCallback node_cb; <span class="comment">/* Optional node callback. Normally set to NULL. */</span></span><br><span class="line">&#125; raxIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为了内存对齐填充的字节，为什么需要填充，本质上来说是为了提高cpu性能。填充之后的数据首地址按照</span></span><br><span class="line"><span class="comment"> * sizeof(void*)字节对齐，保证每个节点都是内存对齐的：</span></span><br><span class="line"><span class="comment"> * 在64位系统中(sizeof(void*)=8)，节点大小如下：</span></span><br><span class="line"><span class="comment"> * 1. [header-4][padding-4] = 8byte</span></span><br><span class="line"><span class="comment"> * 2. [header-4][data-2][padding-2] = 8byte</span></span><br><span class="line"><span class="comment"> * 3. [header-4][data-11][padding-1] = 16byte</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1))</span></span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rax *<span class="title">raxNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxInsert</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> *data, <span class="keyword">void</span> **old)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxTryInsert</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> *data, <span class="keyword">void</span> **old)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxRemove</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> **old)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">raxFind</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxFree</span><span class="params">(rax *rax)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxFreeWithCallback</span><span class="params">(rax *rax, <span class="keyword">void</span> (*free_callback)(<span class="keyword">void</span>*))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxStart</span><span class="params">(raxIterator *it, rax *rt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxSeek</span><span class="params">(raxIterator *it, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxNext</span><span class="params">(raxIterator *it)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxPrev</span><span class="params">(raxIterator *it)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxRandomWalk</span><span class="params">(raxIterator *it, <span class="keyword">size_t</span> steps)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxCompare</span><span class="params">(raxIterator *iter, <span class="keyword">const</span> <span class="keyword">char</span> *op, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">size_t</span> key_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxStop</span><span class="params">(raxIterator *it)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxEOF</span><span class="params">(raxIterator *it)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxShow</span><span class="params">(rax *rax)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">raxSize</span><span class="params">(rax *rax)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">raxTouch</span><span class="params">(raxNode *n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxSetDebugMsg</span><span class="params">(<span class="keyword">int</span> onoff)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal API. May be used by the node callback in order to access rax nodes</span></span><br><span class="line"><span class="comment"> * in a low level way, so this function is exported as well. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raxSetData</span><span class="params">(raxNode *n, <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>创建：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建基数树</span></span><br><span class="line"><span class="function">rax *<span class="title">raxNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    rax *rax = rax_malloc(<span class="keyword">sizeof</span>(*rax)); <span class="comment">// sizeof(*rax) = 4</span></span><br><span class="line">    <span class="keyword">if</span> (rax == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    rax-&gt;numele = <span class="number">0</span>;</span><br><span class="line">    rax-&gt;numnodes = <span class="number">1</span>;</span><br><span class="line">    rax-&gt;head = raxNewNode(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// 创建首节点</span></span><br><span class="line">    <span class="keyword">if</span> (rax-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rax_free(rax);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个节点</span></span><br><span class="line"><span class="function">raxNode *<span class="title">raxNewNode</span><span class="params">(<span class="keyword">size_t</span> children, <span class="keyword">int</span> datafield)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nodesize = <span class="keyword">sizeof</span>(raxNode)+children+raxPadding(children)+</span><br><span class="line">                      <span class="keyword">sizeof</span>(raxNode*)*children;</span><br><span class="line">    <span class="keyword">if</span> (datafield) nodesize += <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">    raxNode *node = rax_malloc(nodesize);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">    node-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">    node-&gt;iscompr = <span class="number">0</span>;</span><br><span class="line">    node-&gt;size = children;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">raxLowWalk</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, raxNode **stopnode, raxNode ***plink, <span class="keyword">int</span> *splitpos, raxStack *ts)</span> </span>&#123;</span><br><span class="line">    raxNode *h = rax-&gt;head; <span class="comment">// 从头节点开始往下遍历</span></span><br><span class="line">    raxNode **parentlink = &amp;rax-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>; <span class="comment">/* Position in the string. */</span></span><br><span class="line">    <span class="keyword">size_t</span> j = <span class="number">0</span>; <span class="comment">/* Position in the node children (or bytes if compressed).*/</span></span><br><span class="line">    <span class="keyword">while</span>(h-&gt;size &amp;&amp; i &lt; len) &#123;</span><br><span class="line">        debugnode(<span class="string">&quot;Lookup current node&quot;</span>,h);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *v = h-&gt;data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iscompr) &#123;</span><br><span class="line">            <span class="comment">/* 如果是压缩节点，表明该节点存储的全部字符应该和s中的部分或者全部字符相等</span></span><br><span class="line"><span class="comment">             * 例如：</span></span><br><span class="line"><span class="comment">             * 1. node:[header|&#x27;abcd&#x27;|d-ptr]  s:[&#x27;abc&#x27;]  那么j=3</span></span><br><span class="line"><span class="comment">             * 2. node:[header|&#x27;ab&#x27;|b-ptr] s:[&#x27;abc&#x27;] 继续往下遍历节点(b-ptr)找到字符&#x27;C&#x27;</span></span><br><span class="line"><span class="comment">             *    然后在子节点中确定&#x27;c&#x27;的位置j */</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; h-&gt;size &amp;&amp; i &lt; len; j++, i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j] != s[i]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != h-&gt;size) <span class="keyword">break</span>; <span class="comment">// 表示已经找到节点，退出循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 如果是非压缩节点，找到s[i]字符的位置j</span></span><br><span class="line"><span class="comment">             * 例如：</span></span><br><span class="line"><span class="comment">             * node:[header|&#x27;abc&#x27;|&#x27;a-ptr&#x27;|&#x27;b-ptr&#x27;|&#x27;c-ptr&#x27;]， s[i]:[&#x27;b&#x27;]，那么j=1</span></span><br><span class="line"><span class="comment">             * 然后可以根据j来确定子节点的地址&#x27;b-ptr&#x27;，便可继续往下遍历 */</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; h-&gt;size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j] == s[i]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == h-&gt;size) <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ts) raxStackPush(ts,h); <span class="comment">// 将当前节点压入栈中</span></span><br><span class="line">        raxNode **children = raxNodeFirstChildPtr(h); <span class="comment">// 获取当前节点的第一个子节点指针的地址</span></span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iscompr) j = <span class="number">0</span>; <span class="comment">/* 压缩节点不需要设置偏移量j */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;h,children+j,<span class="keyword">sizeof</span>(h)); <span class="comment">// 根据偏移量j计算得到子节点的指针，并拷贝给h，接着继续while循环往下遍历</span></span><br><span class="line">        parentlink = children+j;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    debugnode(<span class="string">&quot;Lookup stop node is&quot;</span>,h);</span><br><span class="line">    <span class="keyword">if</span> (stopnode) *stopnode = h;</span><br><span class="line">    <span class="keyword">if</span> (plink) *plink = parentlink;</span><br><span class="line">    <span class="keyword">if</span> (splitpos &amp;&amp; h-&gt;iscompr) *splitpos = j;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">raxFind</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    raxNode *h;</span><br><span class="line"></span><br><span class="line">    debugf(<span class="string">&quot;### Lookup: %.*s\n&quot;</span>, (<span class="keyword">int</span>)len, s);</span><br><span class="line">    <span class="keyword">int</span> splitpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> i = raxLowWalk(rax,s,len,&amp;h,<span class="literal">NULL</span>,&amp;splitpos,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (i != len || (h-&gt;iscompr &amp;&amp; splitpos != <span class="number">0</span>) || !h-&gt;iskey)</span><br><span class="line">        <span class="keyword">return</span> raxNotFound;</span><br><span class="line">    <span class="keyword">return</span> raxGetData(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxGenericInsert</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> *data, <span class="keyword">void</span> **old, <span class="keyword">int</span> overwrite)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    raxNode *h, **parentlink;</span><br><span class="line"></span><br><span class="line">    debugf(<span class="string">&quot;### Insert %.*s with value %p\n&quot;</span>, (<span class="keyword">int</span>)len, s, data);</span><br><span class="line">    i = raxLowWalk(rax,s,len,&amp;h,&amp;parentlink,&amp;j,<span class="literal">NULL</span>); <span class="comment">// 确定插入的节点位置，如果是压缩节点，确定分割位置j</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果s已经存在于rax中</span></span><br><span class="line">    <span class="keyword">if</span> (i == len &amp;&amp; (!h-&gt;iscompr || j == <span class="number">0</span>)) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;### Insert: node representing key exists\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!h-&gt;iskey || (h-&gt;isnull &amp;&amp; overwrite)) &#123;</span><br><span class="line">            h = raxReallocForData(h,data); <span class="comment">// 为值指针分配空间</span></span><br><span class="line">            <span class="keyword">if</span> (h) <span class="built_in">memcpy</span>(parentlink,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            errno = ENOMEM;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the existing key if there is already one. */</span></span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iskey) &#123;</span><br><span class="line">            <span class="comment">// 如果该key以存在，则根据需要是否重写value</span></span><br><span class="line">            <span class="keyword">if</span> (old) *old = raxGetData(h);</span><br><span class="line">            <span class="keyword">if</span> (overwrite) raxSetData(h,data);</span><br><span class="line">            errno = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Element already exists. */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Otherwise set the node as a key. Note that raxSetData()</span></span><br><span class="line"><span class="comment">         * will set h-&gt;iskey. */</span></span><br><span class="line">        <span class="comment">// 插入value</span></span><br><span class="line">        raxSetData(h,data);</span><br><span class="line">        rax-&gt;numele++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Element inserted. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------- ALGORITHM 1 --------------------------- */</span></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;iscompr &amp;&amp; i != len) &#123;</span><br><span class="line">        <span class="comment">// 如果遍历后停在压缩节点上</span></span><br><span class="line">        debugf(<span class="string">&quot;ALGO 1: Stopped at compressed node %.*s (%p)\n&quot;</span>,</span><br><span class="line">            h-&gt;size, h-&gt;data, (<span class="keyword">void</span>*)h);</span><br><span class="line">        debugf(<span class="string">&quot;Still to insert: %.*s\n&quot;</span>, (<span class="keyword">int</span>)(len-i), s+i);</span><br><span class="line">        debugf(<span class="string">&quot;Splitting at %d: &#x27;%c&#x27;\n&quot;</span>, j, ((<span class="keyword">char</span>*)h-&gt;data)[j]);</span><br><span class="line">        debugf(<span class="string">&quot;Other (key) letter is &#x27;%c&#x27;\n&quot;</span>, s[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1: Save next pointer. */</span></span><br><span class="line">        raxNode **childfield = raxNodeLastChildPtr(h);</span><br><span class="line">        raxNode *next;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;next,childfield,<span class="keyword">sizeof</span>(next));</span><br><span class="line">        debugf(<span class="string">&quot;Next is %p\n&quot;</span>, (<span class="keyword">void</span>*)next);</span><br><span class="line">        debugf(<span class="string">&quot;iskey %d\n&quot;</span>, h-&gt;iskey);</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iskey) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;key value is %p\n&quot;</span>, raxGetData(h));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set the length of the additional nodes we will need. */</span></span><br><span class="line">        <span class="keyword">size_t</span> trimmedlen = j;</span><br><span class="line">        <span class="keyword">size_t</span> postfixlen = h-&gt;size - j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> split_node_is_key = !trimmedlen &amp;&amp; h-&gt;iskey &amp;&amp; !h-&gt;isnull;</span><br><span class="line">        <span class="keyword">size_t</span> nodesize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2: Create the split node. Also allocate the other nodes we&#x27;ll need</span></span><br><span class="line"><span class="comment">         *    ASAP, so that it will be simpler to handle OOM. */</span></span><br><span class="line">        raxNode *splitnode = raxNewNode(<span class="number">1</span>, split_node_is_key);</span><br><span class="line">        raxNode *trimmed = <span class="literal">NULL</span>;</span><br><span class="line">        raxNode *postfix = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (trimmedlen) &#123;</span><br><span class="line">            nodesize = <span class="keyword">sizeof</span>(raxNode)+trimmedlen+raxPadding(trimmedlen)+</span><br><span class="line">                       <span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey &amp;&amp; !h-&gt;isnull) nodesize += <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">            trimmed = rax_malloc(nodesize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postfixlen) &#123;</span><br><span class="line">            nodesize = <span class="keyword">sizeof</span>(raxNode)+postfixlen+raxPadding(postfixlen)+</span><br><span class="line">                       <span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">            postfix = rax_malloc(nodesize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* OOM? Abort now that the tree is untouched. */</span></span><br><span class="line">        <span class="keyword">if</span> (splitnode == <span class="literal">NULL</span> ||</span><br><span class="line">            (trimmedlen &amp;&amp; trimmed == <span class="literal">NULL</span>) ||</span><br><span class="line">            (postfixlen &amp;&amp; postfix == <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            rax_free(splitnode);</span><br><span class="line">            rax_free(trimmed);</span><br><span class="line">            rax_free(postfix);</span><br><span class="line">            errno = ENOMEM;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        splitnode-&gt;data[<span class="number">0</span>] = h-&gt;data[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 3a: Replace the old node with the split node. */</span></span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey) &#123;</span><br><span class="line">                <span class="keyword">void</span> *ndata = raxGetData(h);</span><br><span class="line">                raxSetData(splitnode,ndata);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(parentlink,&amp;splitnode,<span class="keyword">sizeof</span>(splitnode));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 3b: Trim the compressed node. */</span></span><br><span class="line">            trimmed-&gt;size = j;</span><br><span class="line">            <span class="built_in">memcpy</span>(trimmed-&gt;data,h-&gt;data,j);</span><br><span class="line">            trimmed-&gt;iscompr = j &gt; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            trimmed-&gt;iskey = h-&gt;iskey;</span><br><span class="line">            trimmed-&gt;isnull = h-&gt;isnull;</span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey &amp;&amp; !h-&gt;isnull) &#123;</span><br><span class="line">                <span class="keyword">void</span> *ndata = raxGetData(h);</span><br><span class="line">                raxSetData(trimmed,ndata);</span><br><span class="line">            &#125;</span><br><span class="line">            raxNode **cp = raxNodeLastChildPtr(trimmed);</span><br><span class="line">            <span class="built_in">memcpy</span>(cp,&amp;splitnode,<span class="keyword">sizeof</span>(splitnode));</span><br><span class="line">            <span class="built_in">memcpy</span>(parentlink,&amp;trimmed,<span class="keyword">sizeof</span>(trimmed));</span><br><span class="line">            parentlink = cp; <span class="comment">/* Set parentlink to splitnode parent. */</span></span><br><span class="line">            rax-&gt;numnodes++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 4: Create the postfix node: what remains of the original</span></span><br><span class="line"><span class="comment">         * compressed node after the split. */</span></span><br><span class="line">        <span class="keyword">if</span> (postfixlen) &#123;</span><br><span class="line">            <span class="comment">/* 4a: create a postfix node. */</span></span><br><span class="line">            postfix-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">            postfix-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">            postfix-&gt;size = postfixlen;</span><br><span class="line">            postfix-&gt;iscompr = postfixlen &gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(postfix-&gt;data,h-&gt;data+j+<span class="number">1</span>,postfixlen);</span><br><span class="line">            raxNode **cp = raxNodeLastChildPtr(postfix);</span><br><span class="line">            <span class="built_in">memcpy</span>(cp,&amp;next,<span class="keyword">sizeof</span>(next));</span><br><span class="line">            rax-&gt;numnodes++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 4b: just use next as postfix node. */</span></span><br><span class="line">            postfix = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 5: Set splitnode first child as the postfix node. */</span></span><br><span class="line">        raxNode **splitchild = raxNodeLastChildPtr(splitnode);</span><br><span class="line">        <span class="built_in">memcpy</span>(splitchild,&amp;postfix,<span class="keyword">sizeof</span>(postfix));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 6. Continue insertion: this will cause the splitnode to</span></span><br><span class="line"><span class="comment">         * get a new child (the non common character at the currently</span></span><br><span class="line"><span class="comment">         * inserted key). */</span></span><br><span class="line">        rax_free(h);</span><br><span class="line">        h = splitnode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h-&gt;iscompr &amp;&amp; i == len) &#123;</span><br><span class="line">    <span class="comment">/* ------------------------- ALGORITHM 2 --------------------------- */</span></span><br><span class="line">        <span class="comment">// 如果在压缩节点h中找到了所有的字符，则创建一个子节点插入</span></span><br><span class="line">        debugf(<span class="string">&quot;ALGO 2: Stopped at compressed node %.*s (%p) j = %d\n&quot;</span>,</span><br><span class="line">            h-&gt;size, h-&gt;data, (<span class="keyword">void</span>*)h, j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate postfix &amp; trimmed nodes ASAP to fail for OOM gracefully. */</span></span><br><span class="line">        <span class="keyword">size_t</span> postfixlen = h-&gt;size - j;</span><br><span class="line">        <span class="keyword">size_t</span> nodesize = <span class="keyword">sizeof</span>(raxNode)+postfixlen+raxPadding(postfixlen)+</span><br><span class="line">                          <span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">NULL</span>) nodesize += <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">        raxNode *postfix = rax_malloc(nodesize);</span><br><span class="line"></span><br><span class="line">        nodesize = <span class="keyword">sizeof</span>(raxNode)+j+raxPadding(j)+<span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iskey &amp;&amp; !h-&gt;isnull) nodesize += <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">        raxNode *trimmed = rax_malloc(nodesize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postfix == <span class="literal">NULL</span> || trimmed == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rax_free(postfix);</span><br><span class="line">            rax_free(trimmed);</span><br><span class="line">            errno = ENOMEM;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1: Save next pointer. */</span></span><br><span class="line">        raxNode **childfield = raxNodeLastChildPtr(h);</span><br><span class="line">        raxNode *next;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;next,childfield,<span class="keyword">sizeof</span>(next));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2: Create the postfix node. */</span></span><br><span class="line">        postfix-&gt;size = postfixlen;</span><br><span class="line">        postfix-&gt;iscompr = postfixlen &gt; <span class="number">1</span>;</span><br><span class="line">        postfix-&gt;iskey = <span class="number">1</span>;</span><br><span class="line">        postfix-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(postfix-&gt;data,h-&gt;data+j,postfixlen);</span><br><span class="line">        raxSetData(postfix,data);</span><br><span class="line">        raxNode **cp = raxNodeLastChildPtr(postfix);</span><br><span class="line">        <span class="built_in">memcpy</span>(cp,&amp;next,<span class="keyword">sizeof</span>(next));</span><br><span class="line">        rax-&gt;numnodes++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3: Trim the compressed node. */</span></span><br><span class="line">        trimmed-&gt;size = j;</span><br><span class="line">        trimmed-&gt;iscompr = j &gt; <span class="number">1</span>;</span><br><span class="line">        trimmed-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">        trimmed-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(trimmed-&gt;data,h-&gt;data,j);</span><br><span class="line">        <span class="built_in">memcpy</span>(parentlink,&amp;trimmed,<span class="keyword">sizeof</span>(trimmed));</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;iskey) &#123;</span><br><span class="line">            <span class="keyword">void</span> *aux = raxGetData(h);</span><br><span class="line">            raxSetData(trimmed,aux);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Fix the trimmed node child pointer to point to</span></span><br><span class="line"><span class="comment">         * the postfix node. */</span></span><br><span class="line">        cp = raxNodeLastChildPtr(trimmed);</span><br><span class="line">        <span class="built_in">memcpy</span>(cp,&amp;postfix,<span class="keyword">sizeof</span>(postfix));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Finish! We don&#x27;t need to continue with the insertion</span></span><br><span class="line"><span class="comment">         * algorithm for ALGO 2. The key is already inserted. */</span></span><br><span class="line">        rax-&gt;numele++;</span><br><span class="line">        rax_free(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Key inserted. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We walked the radix tree as far as we could, but still there are left</span></span><br><span class="line"><span class="comment">     * chars in our string. We need to insert the missing nodes. */</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">        raxNode *child;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this node is going to have a single child, and there</span></span><br><span class="line"><span class="comment">         * are other characters, so that that would result in a chain</span></span><br><span class="line"><span class="comment">         * of single-childed nodes, turn it into a compressed node. */</span></span><br><span class="line">        <span class="keyword">if</span> (h-&gt;size == <span class="number">0</span> &amp;&amp; len-i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Inserting compressed node\n&quot;</span>);</span><br><span class="line">            <span class="keyword">size_t</span> comprsize = len-i;</span><br><span class="line">            <span class="keyword">if</span> (comprsize &gt; RAX_NODE_MAX_SIZE)</span><br><span class="line">                comprsize = RAX_NODE_MAX_SIZE;</span><br><span class="line">            raxNode *newh = raxCompressNode(h,s+i,comprsize,&amp;child);</span><br><span class="line">            <span class="keyword">if</span> (newh == <span class="literal">NULL</span>) <span class="keyword">goto</span> oom;</span><br><span class="line">            h = newh;</span><br><span class="line">            <span class="built_in">memcpy</span>(parentlink,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line">            parentlink = raxNodeLastChildPtr(h);</span><br><span class="line">            i += comprsize;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Inserting normal node\n&quot;</span>);</span><br><span class="line">            raxNode **new_parentlink;</span><br><span class="line">            raxNode *newh = raxAddChild(h,s[i],&amp;child,&amp;new_parentlink);</span><br><span class="line">            <span class="keyword">if</span> (newh == <span class="literal">NULL</span>) <span class="keyword">goto</span> oom;</span><br><span class="line">            h = newh;</span><br><span class="line">            <span class="built_in">memcpy</span>(parentlink,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line">            parentlink = new_parentlink;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        rax-&gt;numnodes++;</span><br><span class="line">        h = child;</span><br><span class="line">    &#125;</span><br><span class="line">    raxNode *newh = raxReallocForData(h,data);</span><br><span class="line">    <span class="keyword">if</span> (newh == <span class="literal">NULL</span>) <span class="keyword">goto</span> oom;</span><br><span class="line">    h = newh;</span><br><span class="line">    <span class="keyword">if</span> (!h-&gt;iskey) rax-&gt;numele++;</span><br><span class="line">    raxSetData(h,data);</span><br><span class="line">    <span class="built_in">memcpy</span>(parentlink,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Element inserted. */</span></span><br><span class="line"></span><br><span class="line">oom:</span><br><span class="line">    <span class="comment">/* This code path handles out of memory after part of the sub-tree was</span></span><br><span class="line"><span class="comment">     * already modified. Set the node as a key, and then remove it. However we</span></span><br><span class="line"><span class="comment">     * do that only if the node is a terminal node, otherwise if the OOM</span></span><br><span class="line"><span class="comment">     * happened reallocating a node in the middle, we don&#x27;t need to free</span></span><br><span class="line"><span class="comment">     * anything. */</span></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">        h-&gt;isnull = <span class="number">1</span>;</span><br><span class="line">        h-&gt;iskey = <span class="number">1</span>;</span><br><span class="line">        rax-&gt;numele++; <span class="comment">/* Compensate the next remove. */</span></span><br><span class="line">        assert(raxRemove(rax,s,i,<span class="literal">NULL</span>) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raxRemove</span><span class="params">(rax *rax, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">void</span> **old)</span> </span>&#123;</span><br><span class="line">    raxNode *h;</span><br><span class="line">    raxStack ts;</span><br><span class="line"></span><br><span class="line">    debugf(<span class="string">&quot;### Delete: %.*s\n&quot;</span>, (<span class="keyword">int</span>)len, s);</span><br><span class="line">    raxStackInit(&amp;ts);</span><br><span class="line">    <span class="keyword">int</span> splitpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> i = raxLowWalk(rax,s,len,&amp;h,<span class="literal">NULL</span>,&amp;splitpos,&amp;ts); <span class="comment">// 将基数树路径上的节点压入ts栈中</span></span><br><span class="line">    <span class="keyword">if</span> (i != len || (h-&gt;iscompr &amp;&amp; splitpos != <span class="number">0</span>) || !h-&gt;iskey) &#123;</span><br><span class="line">        raxStackFree(&amp;ts);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old) *old = raxGetData(h); <span class="comment">// 如果需要旧数据，则获取旧数据</span></span><br><span class="line">    h-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">    rax-&gt;numele--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this node has no children, the deletion needs to reclaim the</span></span><br><span class="line"><span class="comment">     * no longer used nodes. This is an iterative process that needs to</span></span><br><span class="line"><span class="comment">     * walk the three upward, deleting all the nodes with just one child</span></span><br><span class="line"><span class="comment">     * that are not keys, until the head of the rax is reached or the first</span></span><br><span class="line"><span class="comment">     * node with more than one child is found. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> trycompress = <span class="number">0</span>; <span class="comment">/* Will be set to 1 if we should try to optimize the</span></span><br><span class="line"><span class="comment">                            tree resulting from the deletion. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;Key deleted in node without children. Cleanup needed.\n&quot;</span>);</span><br><span class="line">        raxNode *child = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(h != rax-&gt;head) &#123;</span><br><span class="line">            child = h;</span><br><span class="line">            debugf(<span class="string">&quot;Freeing child %p [%.*s] key:%d\n&quot;</span>, (<span class="keyword">void</span>*)child,</span><br><span class="line">                (<span class="keyword">int</span>)child-&gt;size, (<span class="keyword">char</span>*)child-&gt;data, child-&gt;iskey);</span><br><span class="line">            rax_free(child);</span><br><span class="line">            rax-&gt;numnodes--;</span><br><span class="line">            h = raxStackPop(&amp;ts);</span><br><span class="line">             <span class="comment">/* If this node has more then one child, or actually holds</span></span><br><span class="line"><span class="comment">              * a key, stop here. */</span></span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey || (!h-&gt;iscompr &amp;&amp; h-&gt;size != <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (child) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Unlinking child %p from parent %p\n&quot;</span>,</span><br><span class="line">                (<span class="keyword">void</span>*)child, (<span class="keyword">void</span>*)h);</span><br><span class="line">            raxNode *<span class="keyword">new</span> = raxRemoveChild(h,child); <span class="comment">// 删除子节点和父节点相关的信息（data和子节点指针）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> != h) &#123;</span><br><span class="line">                raxNode *parent = raxStackPeek(&amp;ts);</span><br><span class="line">                raxNode **parentlink;</span><br><span class="line">                <span class="keyword">if</span> (parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    parentlink = &amp;rax-&gt;head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parentlink = raxFindParentLink(parent,h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(parentlink,&amp;<span class="keyword">new</span>,<span class="keyword">sizeof</span>(<span class="keyword">new</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If after the removal the node has just a single child</span></span><br><span class="line"><span class="comment">             * and is not a key, we need to try to compress it. */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;size == <span class="number">1</span> &amp;&amp; <span class="keyword">new</span>-&gt;iskey == <span class="number">0</span>) &#123; <span class="comment">// 删除后，如果符合压缩节点结构，则压缩该节点</span></span><br><span class="line">                trycompress = <span class="number">1</span>;</span><br><span class="line">                h = <span class="keyword">new</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h-&gt;size == <span class="number">1</span>) &#123; <span class="comment">//</span></span><br><span class="line">        <span class="comment">/* 如果该节点只有一个子节点，则进行压缩 */</span></span><br><span class="line">        trycompress = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是oom错误，则不进行压缩节点操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (trycompress &amp;&amp; ts.oom) trycompress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trycompress) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;After removing %.*s:\n&quot;</span>, (<span class="keyword">int</span>)len, s);</span><br><span class="line">        debugnode(<span class="string">&quot;Compression may be needed&quot;</span>,h);</span><br><span class="line">        debugf(<span class="string">&quot;Seek start node\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从栈中弹出节点，用来判断最高可到达的能进行压缩的节点上。循环结束时，h指向可以尝试压缩的第一个节点，parent表示h的父节点 */</span></span><br><span class="line">        raxNode *parent;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            parent = raxStackPop(&amp;ts); <span class="comment">// 从栈中弹出节点</span></span><br><span class="line">            <span class="keyword">if</span> (!parent || parent-&gt;iskey ||</span><br><span class="line">                (!parent-&gt;iscompr &amp;&amp; parent-&gt;size != <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            h = parent;</span><br><span class="line">            debugnode(<span class="string">&quot;Going up to&quot;</span>,h);</span><br><span class="line">        &#125;</span><br><span class="line">        raxNode *start = h; <span class="comment">/* Compression starting node. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 扫描可以压缩的节点链路 */</span></span><br><span class="line">        <span class="keyword">size_t</span> comprsize = h-&gt;size;</span><br><span class="line">        <span class="keyword">int</span> nodes = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h-&gt;size != <span class="number">0</span>) &#123;</span><br><span class="line">            raxNode **cp = raxNodeLastChildPtr(h);</span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;h,cp,<span class="keyword">sizeof</span>(h));</span><br><span class="line">            <span class="keyword">if</span> (h-&gt;iskey || (!h-&gt;iscompr &amp;&amp; h-&gt;size != <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* 判断节点中size是否超出最大限制 */</span></span><br><span class="line">            <span class="keyword">if</span> (comprsize + h-&gt;size &gt; RAX_NODE_MAX_SIZE) <span class="keyword">break</span>;</span><br><span class="line">            nodes++;</span><br><span class="line">            comprsize += h-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nodes &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果可以压缩收敛，则创建新的节点进行合并 */</span></span><br><span class="line">            <span class="keyword">size_t</span> nodesize =</span><br><span class="line">                <span class="keyword">sizeof</span>(raxNode)+comprsize+raxPadding(comprsize)+<span class="keyword">sizeof</span>(raxNode*);</span><br><span class="line">            raxNode *<span class="keyword">new</span> = rax_malloc(nodesize);</span><br><span class="line">            <span class="comment">/* An out of memory here just means we cannot optimize this</span></span><br><span class="line"><span class="comment">             * node, but the tree is left in a consistent state. */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                raxStackFree(&amp;ts);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">new</span>-&gt;iskey = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">new</span>-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">new</span>-&gt;iscompr = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span>-&gt;size = comprsize;</span><br><span class="line">            rax-&gt;numnodes++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 再次扫描，以进行新节点的内容填充并修复新节点指针，同时释放所有不再使用的节点 */</span></span><br><span class="line">            comprsize = <span class="number">0</span>;</span><br><span class="line">            h = start;</span><br><span class="line">            <span class="keyword">while</span>(h-&gt;size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(<span class="keyword">new</span>-&gt;data+comprsize,h-&gt;data,h-&gt;size);</span><br><span class="line">                comprsize += h-&gt;size;</span><br><span class="line">                raxNode **cp = raxNodeLastChildPtr(h);</span><br><span class="line">                raxNode *tofree = h;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;h,cp,<span class="keyword">sizeof</span>(h));</span><br><span class="line">                rax_free(tofree); rax-&gt;numnodes--;</span><br><span class="line">                <span class="keyword">if</span> (h-&gt;iskey || (!h-&gt;iscompr &amp;&amp; h-&gt;size != <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            debugnode(<span class="string">&quot;New node&quot;</span>,<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 此时h指向的是不参与压缩的节点，将新节点的指针指向它 */</span></span><br><span class="line">            raxNode **cp = raxNodeLastChildPtr(<span class="keyword">new</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(cp,&amp;h,<span class="keyword">sizeof</span>(h));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 父节点指针重新链接到新节点上 */</span></span><br><span class="line">            <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">                raxNode **parentlink = raxFindParentLink(parent,start);</span><br><span class="line">                <span class="built_in">memcpy</span>(parentlink,&amp;<span class="keyword">new</span>,<span class="keyword">sizeof</span>(<span class="keyword">new</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rax-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            debugf(<span class="string">&quot;Compressed %d nodes, %d total bytes\n&quot;</span>,</span><br><span class="line">                nodes, (<span class="keyword">int</span>)comprsize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    raxStackFree(&amp;ts);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">raxNode *<span class="title">raxRemoveChild</span><span class="params">(raxNode *parent, raxNode *child)</span> </span>&#123;</span><br><span class="line">    debugnode(<span class="string">&quot;raxRemoveChild before&quot;</span>, parent);</span><br><span class="line">    <span class="comment">/* 如果父节点是一个压缩节点（即只有一个子节点），那么删除子节点就意味着将其变成一个没有子节点的普通节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;iscompr) &#123;</span><br><span class="line">        <span class="keyword">void</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;iskey) data = raxGetData(parent);</span><br><span class="line">        parent-&gt;isnull = <span class="number">0</span>;</span><br><span class="line">        parent-&gt;iscompr = <span class="number">0</span>;</span><br><span class="line">        parent-&gt;size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;iskey) raxSetData(parent,data);</span><br><span class="line">        debugnode(<span class="string">&quot;raxRemoveChild after&quot;</span>, parent);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise we need to scan for the child pointer and memmove()</span></span><br><span class="line"><span class="comment">     * accordingly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. To start we seek the first element in both the children</span></span><br><span class="line"><span class="comment">     *    pointers and edge bytes in the node. */</span></span><br><span class="line">    raxNode **cp = raxNodeFirstChildPtr(parent);</span><br><span class="line">    raxNode **c = cp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *e = parent-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 确定子节点的指针 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        raxNode *aux;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;aux,c,<span class="keyword">sizeof</span>(aux));</span><br><span class="line">        <span class="keyword">if</span> (aux == child) <span class="keyword">break</span>;</span><br><span class="line">        c++;</span><br><span class="line">        e++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 删除节点上的数据，和相应的子节点指针 */</span></span><br><span class="line">    <span class="keyword">int</span> taillen = parent-&gt;size - (e - parent-&gt;data) - <span class="number">1</span>;</span><br><span class="line">    debugf(<span class="string">&quot;raxRemoveChild tail len: %d\n&quot;</span>, taillen);</span><br><span class="line">    memmove(e,e+<span class="number">1</span>,taillen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 因为删除一个节点，需要删除父节点上关于子节点的data信息和指针信息，所以需要计算父节点上的偏移量，即节点上的数据向左偏移的字节数 */</span></span><br><span class="line">    <span class="keyword">size_t</span> shift = ((parent-&gt;size+<span class="number">4</span>) % <span class="keyword">sizeof</span>(<span class="keyword">void</span>*)) == <span class="number">1</span> ? <span class="keyword">sizeof</span>(<span class="keyword">void</span>*) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在删除之前移动子指针 */</span></span><br><span class="line">    <span class="keyword">if</span> (shift)</span><br><span class="line">        memmove(((<span class="keyword">char</span>*)cp)-shift,cp,(parent-&gt;size-taillen<span class="number">-1</span>)*<span class="keyword">sizeof</span>(raxNode**));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将剩余的尾部指针移动到指定位置 */</span></span><br><span class="line">    <span class="keyword">size_t</span> valuelen = (parent-&gt;iskey &amp;&amp; !parent-&gt;isnull) ? <span class="keyword">sizeof</span>(<span class="keyword">void</span>*) : <span class="number">0</span>;</span><br><span class="line">    memmove(((<span class="keyword">char</span>*)c)-shift,c+<span class="number">1</span>,taillen*<span class="keyword">sizeof</span>(raxNode**)+valuelen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 更新节点size. */</span></span><br><span class="line">    parent-&gt;size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重新分配父节点的空间 */</span></span><br><span class="line">    raxNode *newnode = rax_realloc(parent,raxNodeCurrentLength(parent));</span><br><span class="line">    <span class="keyword">if</span> (newnode) &#123;</span><br><span class="line">        debugnode(<span class="string">&quot;raxRemoveChild after&quot;</span>, newnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Note: if rax_realloc() fails we just return the old address, which</span></span><br><span class="line"><span class="comment">     * is valid. */</span></span><br><span class="line">    <span class="keyword">return</span> newnode ? newnode : parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：rax.c/rax.h&lt;/p&gt;
&lt;p&gt;Redis 5.0版本引入的一个新的数据结构。目前主要用在stream这个数据结构上。Rax是一个有序字典树（基数树），按照key的字典序排列，支持快速定位、查找和删除操作。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-紧凑列表listpack</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-listpack/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-listpack/</id>
    <published>2020-09-21T09:08:58.000Z</published>
    <updated>2020-09-21T09:52:35.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：listpack.c/listpack.h</p><p>Redis 5.0版本引入的一个新的数据结构，它是对ziplist压缩列表的改进，listpack结构更为精简，更加节省内存空间。它的实现方式也和ziplist很类似，所以阅读理解起来并不难。也许该数据结构设计出来是要替代ziplist的，只不过ziplist目前在redis中的应用非常广泛，替换起来复杂度很高，所以目前该数据结构只有在新引入的stream数据结构中使用，可能将来有一天会全面替换ziplist。  </p><p>相对于ziplist，listpack取消了存储前置节点长度的字段，listpack的节点之间是相互独立的，改变前置节点的长度，不会影响到后续节点的长度，所以再也不需要连锁更新操作。<br><a id="more"></a><br>和ziplist一样，没有专门定义的结构体，在内存中的表现如下：<br><strong>listpack结构：</strong><br><img src="/Redis/first-stage/redis-parse-listpack/listpack.png" alt="listpack"><br>|属性       |长度        |用途        |<br>|—-        |—-        |—-        |<br>|lpbyte     |4byte      |表示整个lp的字节数（最大可存储4GB）。可用于快速定位最后一个节点的位置。|<br>|lpsize     |2byte      |表示元素（节点）个数。|<br>|lpentry    |不定长     |节点。存储数据编码类型，数据，和当前元素的长度。|<br>|lpend      |1byte      |lp结束标志，和ziplist一样，恒为0xff。|</p><p><strong>lpentry节点：</strong><br><img src="/Redis/first-stage/redis-parse-listpack/listpack_entry.png" alt="lpentry"><br>encoding：数据的编码类型，如下：<br><img src="/Redis/first-stage/redis-parse-listpack/listpack_encoding.png" alt="encoding"><br>data：元素。<br>backlen：存储encoding+data的长度，这个是用于反向遍历的关键，通过位置指针p-backlen_size-backlen，可移动到上一个节点的位置。编码如下：<br><img src="/Redis/first-stage/redis-parse-listpack/listpack_backlen.png" alt="backlen"></p><p>下面来列举一下主要函数的时间复杂度：<br>|函数|作用 |复杂度|<br>|—-|—-|—-|<br>|lpNew()|创建listpack|O(1)|<br>|lpFree()|释放listpack|O(1)|<br>|lpSeek()|获取指定位置的节点指针|平均O(N)，首尾O(1)|<br>|lpAppend()|指定位置插入元素|O(1)|<br>|lpDelete()|指定位置删除元素|O(1)|</p><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listpack_malloc.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp_malloc zmalloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp_realloc zrealloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lp_free zfree</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_INTBUF_SIZE 21 <span class="comment">/* 20 digits of -2^63 + 1 null term = 21. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// listpack.h</span></span><br><span class="line"><span class="comment">/* lpInsert() where argument possible values: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_BEFORE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_AFTER 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_REPLACE 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// listpack.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_HDR_SIZE 6       <span class="comment">/* 32 bit total len + 16 bit number of elements. */</span> <span class="comment">// 前4个byte表示占用的总字节数，后2个byte表示元素个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_HDR_NUMELE_UNKNOWN UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_MAX_INT_ENCODING_LEN 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_MAX_BACKLEN_SIZE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_MAX_ENTRY_BACKLEN 34359738367ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_INT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_STRING 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_7BIT_UINT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_7BIT_UINT_MASK 0x80 <span class="comment">// 1000 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_7BIT_UINT(byte) (((byte)&amp;LP_ENCODING_7BIT_UINT_MASK)==LP_ENCODING_7BIT_UINT) <span class="comment">// 0xxx xxxx : 7bit正整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_6BIT_STR 0x80 <span class="comment">// 1000 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_6BIT_STR_MASK 0xC0 <span class="comment">// 1100 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_6BIT_STR(byte) (((byte)&amp;LP_ENCODING_6BIT_STR_MASK)==LP_ENCODING_6BIT_STR) <span class="comment">// 10aa aaaa : 6bit字符串编码，前2个bit表示6bit字符串编码，后跟6个bit表示字符串长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_13BIT_INT 0xC0 <span class="comment">// 1100 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_13BIT_INT_MASK 0xE0 <span class="comment">// 1110 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_13BIT_INT(byte) (((byte)&amp;LP_ENCODING_13BIT_INT_MASK)==LP_ENCODING_13BIT_INT) <span class="comment">// 1100 xxxx : 13bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_12BIT_STR 0xE0 <span class="comment">// 1110 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_12BIT_STR_MASK 0xF0 <span class="comment">// 1111 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_12BIT_STR(byte) (((byte)&amp;LP_ENCODING_12BIT_STR_MASK)==LP_ENCODING_12BIT_STR) <span class="comment">// 1100 aaaa aaaa aaaa : 12bit字符串编码，前4个bit表示12bit字符串编码，后跟12个bit表示字符串长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_16BIT_INT 0xF1 <span class="comment">// 1111 0001</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_16BIT_INT_MASK 0xFF <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_16BIT_INT(byte) (((byte)&amp;LP_ENCODING_16BIT_INT_MASK)==LP_ENCODING_16BIT_INT) <span class="comment">// 1110 0001 : 16bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_24BIT_INT 0xF2 <span class="comment">// 1111 0010</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_24BIT_INT_MASK 0xFF <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_24BIT_INT(byte) (((byte)&amp;LP_ENCODING_24BIT_INT_MASK)==LP_ENCODING_24BIT_INT) <span class="comment">// 1111 0010 : 24bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_INT 0xF3 <span class="comment">// 1111 0011</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_INT_MASK 0xFF <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_32BIT_INT(byte) (((byte)&amp;LP_ENCODING_32BIT_INT_MASK)==LP_ENCODING_32BIT_INT) <span class="comment">// 1111 0011 : 32bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_64BIT_INT 0xF4 <span class="comment">// 1111 0100</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_64BIT_INT_MASK 0xFF <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_64BIT_INT(byte) (((byte)&amp;LP_ENCODING_64BIT_INT_MASK)==LP_ENCODING_64BIT_INT) <span class="comment">// 1111 0100 : 64bit整数编码类型判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_STR 0xF0 <span class="comment">// 1111 0000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_STR_MASK 0xFF  <span class="comment">// 1111 1111</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_IS_32BIT_STR(byte) (((byte)&amp;LP_ENCODING_32BIT_STR_MASK)==LP_ENCODING_32BIT_STR) <span class="comment">// 1111 0000 : 32bit字符串编码，前8个bit表示32bit字符串编码，后跟32个bit表示字符串长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_EOF 0xFF <span class="comment">// listpack结束标志</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算6bit字符串类型编码的实际长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_6BIT_STR_LEN(p) ((p)[0] &amp; 0x3F)</span></span><br><span class="line"><span class="comment">// 计算12bit字符串类型编码的实际长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_12BIT_STR_LEN(p) ((((p)[0] &amp; 0xF) &lt;&lt; 8) | (p)[1])</span></span><br><span class="line"><span class="comment">// 计算32bit字符串类型编码的实际长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LP_ENCODING_32BIT_STR_LEN(p) (((uint32_t)(p)[1]&lt;&lt;0) | \</span></span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>) | \</span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">3</span>]&lt;&lt;<span class="number">16</span>) | \</span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">4</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line"><span class="comment">// 获取listpack总字节数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lpGetTotalBytes(p)           (((uint32_t)(p)[0]&lt;&lt;0) | \</span></span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>) | \</span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">2</span>]&lt;&lt;<span class="number">16</span>) | \</span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">3</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line"><span class="comment">// 获取listpack元素个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lpGetNumElements(p)          (((uint32_t)(p)[4]&lt;&lt;0) | \</span></span><br><span class="line">                                      ((<span class="keyword">uint32_t</span>)(p)[<span class="number">5</span>]&lt;&lt;<span class="number">8</span>))</span><br><span class="line"><span class="comment">// 设置listpack的总字节数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lpSetTotalBytes(p,v) do &#123; \</span></span><br><span class="line">    (p)[<span class="number">0</span>] = (v)&amp;<span class="number">0xff</span>; \</span><br><span class="line">    (p)[<span class="number">1</span>] = ((v)&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>; \</span><br><span class="line">    (p)[<span class="number">2</span>] = ((v)&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>; \</span><br><span class="line">    (p)[<span class="number">3</span>] = ((v)&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 设置元素个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lpSetNumElements(p,v) do &#123; \</span></span><br><span class="line">    (p)[<span class="number">4</span>] = (v)&amp;<span class="number">0xff</span>; \</span><br><span class="line">    (p)[<span class="number">5</span>] = ((v)&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpNew</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建listpack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpFree</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// 释放listpack</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **newp)</span></span>; <span class="comment">// 指定节点插入或删除操作（ele为空，则为删除）</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpAppend</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size)</span></span>; <span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **newp)</span></span>; <span class="comment">// 删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">lpLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// listpack节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int64_t</span> *count, <span class="keyword">unsigned</span> <span class="keyword">char</span> *intbuf)</span></span>; <span class="comment">// 获取节点的数据</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpFirst</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// 获取头节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpLast</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// 获取尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>; <span class="comment">// 跳到下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>; <span class="comment">// 跳到上一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">lpBytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span></span>; <span class="comment">// 获取listpack的大小</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpSeek</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">long</span> index)</span></span>; <span class="comment">// 获取指定位置节点的指针</span></span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建listpack</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *lp = lp_malloc(LP_HDR_SIZE+<span class="number">1</span>); <span class="comment">// 申请7byte的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (lp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    lpSetTotalBytes(lp,LP_HDR_SIZE+<span class="number">1</span>);</span><br><span class="line">    lpSetNumElements(lp,<span class="number">0</span>);</span><br><span class="line">    lp[LP_HDR_SIZE] = LP_EOF; <span class="comment">// 节点结束标志（恒为0xFF）</span></span><br><span class="line">    <span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放listpack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpFree</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span> </span>&#123;</span><br><span class="line">    lp_free(lp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编码相关：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素编码类型和长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lpEncodeGetType</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">char</span> *intenc, <span class="keyword">uint64_t</span> *enclen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> v;</span><br><span class="line">    <span class="keyword">if</span> (lpStringToInt64((<span class="keyword">const</span> <span class="keyword">char</span>*)ele, size, &amp;v)) &#123;</span><br><span class="line">        <span class="comment">// 如果能转为整数，则判定元素为整数，根据数值编码到intenc中</span></span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">            <span class="comment">/* Single byte 0-127 integer. */</span></span><br><span class="line">            intenc[<span class="number">0</span>] = v;</span><br><span class="line">            *enclen = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">-4096</span> &amp;&amp; v &lt;= <span class="number">4095</span>) &#123;</span><br><span class="line">            <span class="comment">/* 13 bit integer. */</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v = ((<span class="keyword">int64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">13</span>)+v;</span><br><span class="line">            intenc[<span class="number">0</span>] = (v&gt;&gt;<span class="number">8</span>)|LP_ENCODING_13BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = v&amp;<span class="number">0xff</span>;</span><br><span class="line">            *enclen = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">-32768</span> &amp;&amp; v &lt;= <span class="number">32767</span>) &#123;</span><br><span class="line">            <span class="comment">/* 16 bit integer. */</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v = ((<span class="keyword">int64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">16</span>)+v;</span><br><span class="line">            intenc[<span class="number">0</span>] = LP_ENCODING_16BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = v&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">2</span>] = v&gt;&gt;<span class="number">8</span>;</span><br><span class="line">            *enclen = <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">-8388608</span> &amp;&amp; v &lt;= <span class="number">8388607</span>) &#123;</span><br><span class="line">            <span class="comment">/* 24 bit integer. */</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v = ((<span class="keyword">int64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">24</span>)+v;</span><br><span class="line">            intenc[<span class="number">0</span>] = LP_ENCODING_24BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = v&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">2</span>] = (v&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">3</span>] = v&gt;&gt;<span class="number">16</span>;</span><br><span class="line">            *enclen = <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">-2147483648</span> &amp;&amp; v &lt;= <span class="number">2147483647</span>) &#123;</span><br><span class="line">            <span class="comment">/* 32 bit integer. */</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v = ((<span class="keyword">int64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">32</span>)+v;</span><br><span class="line">            intenc[<span class="number">0</span>] = LP_ENCODING_32BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = v&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">2</span>] = (v&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">3</span>] = (v&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">4</span>] = v&gt;&gt;<span class="number">24</span>;</span><br><span class="line">            *enclen = <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 64 bit integer. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> uv = v;</span><br><span class="line">            intenc[<span class="number">0</span>] = LP_ENCODING_64BIT_INT;</span><br><span class="line">            intenc[<span class="number">1</span>] = uv&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">2</span>] = (uv&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">3</span>] = (uv&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">4</span>] = (uv&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">5</span>] = (uv&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">6</span>] = (uv&gt;&gt;<span class="number">40</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">7</span>] = (uv&gt;&gt;<span class="number">48</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">            intenc[<span class="number">8</span>] = uv&gt;&gt;<span class="number">56</span>;</span><br><span class="line">            *enclen = <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LP_ENCODING_INT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是字符串，则计算字符串的编码长度</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">64</span>) *enclen = <span class="number">1</span>+size;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size &lt; <span class="number">4096</span>) *enclen = <span class="number">2</span>+size;</span><br><span class="line">        <span class="keyword">else</span> *enclen = <span class="number">5</span>+size;</span><br><span class="line">        <span class="keyword">return</span> LP_ENCODING_STRING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把encoding+data的长度编码到backlen中</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">lpEncodeBacklen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">uint64_t</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) buf[<span class="number">0</span>] = l;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; <span class="number">16383</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">            buf[<span class="number">0</span>] = l&gt;&gt;<span class="number">7</span>;</span><br><span class="line">            buf[<span class="number">1</span>] = (l&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; <span class="number">2097151</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">            buf[<span class="number">0</span>] = l&gt;&gt;<span class="number">14</span>;</span><br><span class="line">            buf[<span class="number">1</span>] = ((l&gt;&gt;<span class="number">7</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = (l&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; <span class="number">268435455</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">            buf[<span class="number">0</span>] = l&gt;&gt;<span class="number">21</span>;</span><br><span class="line">            buf[<span class="number">1</span>] = ((l&gt;&gt;<span class="number">14</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = ((l&gt;&gt;<span class="number">7</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = (l&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">            buf[<span class="number">0</span>] = l&gt;&gt;<span class="number">28</span>;</span><br><span class="line">            buf[<span class="number">1</span>] = ((l&gt;&gt;<span class="number">21</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = ((l&gt;&gt;<span class="number">14</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = ((l&gt;&gt;<span class="number">7</span>)&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">            buf[<span class="number">4</span>] = (l&amp;<span class="number">127</span>)|<span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解码出encoding+data的长度</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">lpDecodeBacklen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        val |= (<span class="keyword">uint64_t</span>)(p[<span class="number">0</span>] &amp; <span class="number">127</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> (!(p[<span class="number">0</span>] &amp; <span class="number">128</span>)) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">        p--;</span><br><span class="line">        <span class="keyword">if</span> (shift &gt; <span class="number">28</span>) <span class="keyword">return</span> UINT64_MAX;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串类型编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpEncodeString</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">64</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = len | LP_ENCODING_6BIT_STR;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf+<span class="number">1</span>,s,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; <span class="number">4096</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = (len &gt;&gt; <span class="number">8</span>) | LP_ENCODING_12BIT_STR;</span><br><span class="line">        buf[<span class="number">1</span>] = len &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf+<span class="number">2</span>,s,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = LP_ENCODING_32BIT_STR;</span><br><span class="line">        buf[<span class="number">1</span>] = len &amp; <span class="number">0xff</span>;</span><br><span class="line">        buf[<span class="number">2</span>] = (len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        buf[<span class="number">3</span>] = (len &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        buf[<span class="number">4</span>] = (len &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf+<span class="number">5</span>,s,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入和删除：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpAppend</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> listpack_bytes = lpGetTotalBytes(lp);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *eofptr = lp + listpack_bytes - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> lpInsert(lp,ele,size,eofptr,LP_BEFORE,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **newp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lpInsert(lp,<span class="literal">NULL</span>,<span class="number">0</span>,p,LP_REPLACE,newp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（删除）元素实现，根据ele是否为NULL来判定是哪种操作类型（NULL为删除操作，非NULL为插入操作）</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">uint32_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **newp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> intenc[LP_MAX_INT_ENCODING_LEN]; <span class="comment">// intenc数组用来记录整型元素的编码和元素内容</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> backlen[LP_MAX_BACKLEN_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> enclen; <span class="comment">/* The length of the encoded element. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* An element pointer set to NULL means deletion, which is conceptually</span></span><br><span class="line"><span class="comment">     * replacing the element with a zero-length element. So whatever we</span></span><br><span class="line"><span class="comment">     * get passed as &#x27;where&#x27;, set it to LP_REPLACE. */</span></span><br><span class="line">    <span class="comment">// 如果元素ele为空意味着删除，即用0长度元素去替换，所以where设置为LP_REPLACE</span></span><br><span class="line">    <span class="keyword">if</span> (ele == <span class="literal">NULL</span>) where = LP_REPLACE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we need to insert after the current element, we just jump to the</span></span><br><span class="line"><span class="comment">     * next element (that could be the EOF one) and handle the case of</span></span><br><span class="line"><span class="comment">     * inserting before. So the function will actually deal with just two</span></span><br><span class="line"><span class="comment">     * cases: LP_BEFORE and LP_REPLACE. */</span></span><br><span class="line">    <span class="comment">// 如果想要在位置p后插入元素，则将p跳到下一个元素并在之前处理插入的情况，所以该函数实际上只处理两种情况，LP_BEFORE和LP_REPLACE</span></span><br><span class="line">    <span class="keyword">if</span> (where == LP_AFTER) &#123;</span><br><span class="line">        p = lpSkip(p);</span><br><span class="line">        where = LP_BEFORE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the offset of the element &#x27;p&#x27;, so that we can obtain its</span></span><br><span class="line"><span class="comment">     * address again after a reallocation. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> poff = p-lp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Calling lpEncodeGetType() results into the encoded version of the</span></span><br><span class="line"><span class="comment">     * element to be stored into &#x27;intenc&#x27; in case it is representable as</span></span><br><span class="line"><span class="comment">     * an integer: in that case, the function returns LP_ENCODING_INT.</span></span><br><span class="line"><span class="comment">     * Otherwise if LP_ENCODING_STR is returned, we&#x27;ll have to call</span></span><br><span class="line"><span class="comment">     * lpEncodeString() to actually write the encoded string on place later.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Whatever the returned encoding is, &#x27;enclen&#x27; is populated with the</span></span><br><span class="line"><span class="comment">     * length of the encoded element. */</span></span><br><span class="line">    <span class="keyword">int</span> enctype;</span><br><span class="line">    <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">        <span class="comment">// 获取编码类型和编码长度</span></span><br><span class="line">        enctype = lpEncodeGetType(ele,size,intenc,&amp;enclen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        enctype = <span class="number">-1</span>;</span><br><span class="line">        enclen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to also encode the backward-parsable length of the element</span></span><br><span class="line"><span class="comment">     * and append it to the end: this allows to traverse the listpack from</span></span><br><span class="line"><span class="comment">     * the end to the start. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> backlen_size = ele ? lpEncodeBacklen(backlen,enclen) : <span class="number">0</span>; <span class="comment">// 编码长度</span></span><br><span class="line">    <span class="keyword">uint64_t</span> old_listpack_bytes = lpGetTotalBytes(lp); <span class="comment">// 获取当前lp的字节数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> replaced_len  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (where == LP_REPLACE) &#123;</span><br><span class="line">        <span class="comment">// 如果是删除操作，则计算p位置节点的长度</span></span><br><span class="line">        replaced_len = lpCurrentEncodedSize(p); <span class="comment">// 当前位置p的元素编码字节数</span></span><br><span class="line">        replaced_len += lpEncodeBacklen(<span class="literal">NULL</span>,replaced_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> new_listpack_bytes = old_listpack_bytes + enclen + backlen_size</span><br><span class="line">                                  - replaced_len;</span><br><span class="line">    <span class="keyword">if</span> (new_listpack_bytes &gt; UINT32_MAX) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 单个listpack最大只能是4GB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We now need to reallocate in order to make space or shrink the</span></span><br><span class="line"><span class="comment">     * allocation (in case &#x27;when&#x27; value is LP_REPLACE and the new element is</span></span><br><span class="line"><span class="comment">     * smaller). However we do that before memmoving the memory to</span></span><br><span class="line"><span class="comment">     * make room for the new element if the final allocation will get</span></span><br><span class="line"><span class="comment">     * larger, or we do it after if the final allocation will get smaller. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *dst = lp + poff; <span class="comment">/* May be updated after reallocation. */</span> <span class="comment">// 指向元素将要插入的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Realloc before: we need more room. */</span></span><br><span class="line">    <span class="keyword">if</span> (new_listpack_bytes &gt; old_listpack_bytes) &#123;</span><br><span class="line">        <span class="comment">// 如果是插入，则lp需要分配更多内存空间</span></span><br><span class="line">        <span class="keyword">if</span> ((lp = lp_realloc(lp,new_listpack_bytes)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        dst = lp + poff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the listpack relocating the elements to make the exact room</span></span><br><span class="line"><span class="comment">     * we need to store the new one. */</span></span><br><span class="line">    <span class="keyword">if</span> (where == LP_BEFORE) &#123;</span><br><span class="line">        <span class="comment">// 移动结束位（lpend）到最后</span></span><br><span class="line">        memmove(dst+enclen+backlen_size,dst,old_listpack_bytes-poff);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* LP_REPLACE. */</span></span><br><span class="line">        <span class="comment">// 将删除的节点后面的所有内存数据往前移动到节点的位置上</span></span><br><span class="line">        <span class="keyword">long</span> lendiff = (enclen+backlen_size)-replaced_len;</span><br><span class="line">        memmove(dst+replaced_len+lendiff,</span><br><span class="line">                dst+replaced_len,</span><br><span class="line">                old_listpack_bytes-poff-replaced_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Realloc after: we need to free space. */</span></span><br><span class="line">    <span class="keyword">if</span> (new_listpack_bytes &lt; old_listpack_bytes) &#123;</span><br><span class="line">        <span class="comment">// 如果是删除操作，则lp也需要重新分配内存空间</span></span><br><span class="line">        <span class="keyword">if</span> ((lp = lp_realloc(lp,new_listpack_bytes)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        dst = lp + poff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the entry. */</span></span><br><span class="line">    <span class="keyword">if</span> (newp) &#123;</span><br><span class="line">        <span class="comment">// 将当前位置赋给newp</span></span><br><span class="line">        *newp = dst;</span><br><span class="line">        <span class="comment">/* In case of deletion, set &#x27;newp&#x27; to NULL if the next element is</span></span><br><span class="line"><span class="comment">         * the EOF element. */</span></span><br><span class="line">         <span class="comment">// 如果是删除操作，并且已经到了列表尾了，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!ele &amp;&amp; dst[<span class="number">0</span>] == LP_EOF) *newp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">        <span class="comment">// 插入操作将数据填充到节点</span></span><br><span class="line">        <span class="keyword">if</span> (enctype == LP_ENCODING_INT) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(dst,intenc,enclen);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lpEncodeString(dst,ele,size);</span><br><span class="line">        &#125;</span><br><span class="line">        dst += enclen;</span><br><span class="line">        <span class="comment">// 填充backlen</span></span><br><span class="line">        <span class="built_in">memcpy</span>(dst,backlen,backlen_size);</span><br><span class="line">        dst += backlen_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update header. */</span></span><br><span class="line">    <span class="comment">// 更新lp信息</span></span><br><span class="line">    <span class="keyword">if</span> (where != LP_REPLACE || ele == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> num_elements = lpGetNumElements(lp);</span><br><span class="line">        <span class="keyword">if</span> (num_elements != LP_HDR_NUMELE_UNKNOWN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ele)</span><br><span class="line">                lpSetNumElements(lp,num_elements+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lpSetNumElements(lp,num_elements<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lpSetTotalBytes(lp,new_listpack_bytes);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">/* This code path is normally disabled: what it does is to force listpack</span></span><br><span class="line"><span class="comment">     * to return *always* a new pointer after performing some modification to</span></span><br><span class="line"><span class="comment">     * the listpack, even if the previous allocation was enough. This is useful</span></span><br><span class="line"><span class="comment">     * in order to spot bugs in code using listpacks: by doing so we can find</span></span><br><span class="line"><span class="comment">     * if the caller forgets to set the new pointer where the listpack reference</span></span><br><span class="line"><span class="comment">     * is stored, after an update. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *oldlp = lp;</span><br><span class="line">    lp = lp_malloc(new_listpack_bytes);</span><br><span class="line">    <span class="built_in">memcpy</span>(lp,oldlp,new_listpack_bytes);</span><br><span class="line">    <span class="keyword">if</span> (newp) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> offset = (*newp)-oldlp;</span><br><span class="line">        *newp = lp + offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Make sure the old allocation contains garbage. */</span></span><br><span class="line">    <span class="built_in">memset</span>(oldlp,<span class="string">&#x27;A&#x27;</span>,new_listpack_bytes);</span><br><span class="line">    lp_free(oldlp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>节点遍历相关操作：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是在位置p的节点后进行操作，则先把p跳到该节点的后一个节点上</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpSkip</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前节点encoding+data的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> entrylen = lpCurrentEncodedSize(p);</span><br><span class="line">    <span class="comment">// 获取当前backlen的长度</span></span><br><span class="line">    entrylen += lpEncodeBacklen(<span class="literal">NULL</span>,entrylen);</span><br><span class="line">    <span class="comment">// 指针移动到下一个节点的位置</span></span><br><span class="line">    p += entrylen;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳到下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>) lp); <span class="comment">/* lp is not used for now. However lpPrev() uses it. */</span></span><br><span class="line">    p = lpSkip(p);</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == LP_EOF) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳到上一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-lp == LP_HDR_SIZE) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    p--; <span class="comment">/* Seek the first backlen byte of the last element. */</span></span><br><span class="line">    <span class="comment">// 获取encoding+data的长度</span></span><br><span class="line">    <span class="keyword">uint64_t</span> prevlen = lpDecodeBacklen(p);</span><br><span class="line">    <span class="comment">// 获取backlen的长度</span></span><br><span class="line">    prevlen += lpEncodeBacklen(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">// 指针移动到上一个节点的位置</span></span><br><span class="line">    <span class="keyword">return</span> p-prevlen+<span class="number">1</span>; <span class="comment">/* Seek the first byte of the previous entry. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer to the first element of the listpack, or NULL if the</span></span><br><span class="line"><span class="comment"> * listpack has no elements. */</span></span><br><span class="line"><span class="comment">// 首节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpFirst</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span> </span>&#123;</span><br><span class="line">    lp += LP_HDR_SIZE; <span class="comment">/* Skip the header. */</span></span><br><span class="line">    <span class="keyword">if</span> (lp[<span class="number">0</span>] == LP_EOF) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer to the last element of the listpack, or NULL if the</span></span><br><span class="line"><span class="comment"> * listpack has no elements. */</span></span><br><span class="line"><span class="comment">// 尾节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpLast</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = lp+lpGetTotalBytes(lp)<span class="number">-1</span>; <span class="comment">/* Seek EOF element. */</span></span><br><span class="line">    <span class="keyword">return</span> lpPrev(lp,p); <span class="comment">/* Will return NULL if EOF is the only element. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定位置的节点指针</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpSeek</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *lp, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> forward = <span class="number">1</span>; <span class="comment">/* Seek forward by default. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We want to seek from left to right or the other way around</span></span><br><span class="line"><span class="comment">     * depending on the listpack length and the element position.</span></span><br><span class="line"><span class="comment">     * However if the listpack length cannot be obtained in constant time,</span></span><br><span class="line"><span class="comment">     * we always seek from left to right. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> numele = lpGetNumElements(lp); <span class="comment">// 获取整个listpack的节点数</span></span><br><span class="line">    <span class="comment">// 计算index在listpack中的上半区域还是下半区域</span></span><br><span class="line">    <span class="keyword">if</span> (numele != LP_HDR_NUMELE_UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = (<span class="keyword">long</span>)numele+index;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* Index still &lt; 0 means out of range. */</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= numele) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* Out of range the other side. */</span></span><br><span class="line">        <span class="comment">/* We want to scan right-to-left if the element we are looking for</span></span><br><span class="line"><span class="comment">         * is past the half of the listpack. */</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; numele/<span class="number">2</span>) &#123;</span><br><span class="line">            forward = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* Left to right scanning always expects a negative index. Convert</span></span><br><span class="line"><span class="comment">             * our index to negative form. */</span></span><br><span class="line">            index -= numele;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If the listpack length is unspecified, for negative indexes we</span></span><br><span class="line"><span class="comment">         * want to always scan left-to-right. */</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) forward = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Forward and backward scanning is trivially based on lpNext()/lpPrev(). */</span></span><br><span class="line">    <span class="keyword">if</span> (forward) &#123;</span><br><span class="line">        <span class="comment">// 如果在上半区域，则从头节点开始正向遍历到index的位置</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele = lpFirst(lp);</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; ele) &#123;</span><br><span class="line">            ele = lpNext(lp,ele);</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在下半区域，则尾头节点开始正向遍历到index的位置</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele = lpLast(lp);</span><br><span class="line">        <span class="keyword">while</span> (index &lt; <span class="number">-1</span> &amp;&amp; ele) &#123;</span><br><span class="line">            ele = lpPrev(lp,ele);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取节点p的数据</span></span><br><span class="line"><span class="comment">// 如果数据是字符串，则返回值就是字符串的头指针，count是字符串的长度</span></span><br><span class="line"><span class="comment">// 如果数据是整数，数值填入count，如果不为空，将数值转为字符串填入intbuf</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">lpGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int64_t</span> *count, <span class="keyword">unsigned</span> <span class="keyword">char</span> *intbuf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> val;</span><br><span class="line">    <span class="keyword">uint64_t</span> uval, negstart, negmax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是判断数据的编码类型，如果是字符串，则直接取出返回</span></span><br><span class="line">    <span class="keyword">if</span> (LP_ENCODING_IS_7BIT_UINT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        negstart = UINT64_MAX; <span class="comment">/* 7 bit ints are always positive. */</span></span><br><span class="line">        negmax = <span class="number">0</span>;</span><br><span class="line">        uval = p[<span class="number">0</span>] &amp; <span class="number">0x7f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_6BIT_STR(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        *count = LP_ENCODING_6BIT_STR_LEN(p);</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_13BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = ((p[<span class="number">0</span>]&amp;<span class="number">0x1f</span>)&lt;&lt;<span class="number">8</span>) | p[<span class="number">1</span>];</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">12</span>;</span><br><span class="line">        negmax = <span class="number">8191</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_16BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = (<span class="keyword">uint64_t</span>)p[<span class="number">1</span>] |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>;</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">15</span>;</span><br><span class="line">        negmax = UINT16_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_24BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = (<span class="keyword">uint64_t</span>)p[<span class="number">1</span>] |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">2</span>]&lt;&lt;<span class="number">8</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">3</span>]&lt;&lt;<span class="number">16</span>;</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">23</span>;</span><br><span class="line">        negmax = UINT32_MAX&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_32BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = (<span class="keyword">uint64_t</span>)p[<span class="number">1</span>] |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">2</span>]&lt;&lt;<span class="number">8</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">3</span>]&lt;&lt;<span class="number">16</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">4</span>]&lt;&lt;<span class="number">24</span>;</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">        negmax = UINT32_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_64BIT_INT(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        uval = (<span class="keyword">uint64_t</span>)p[<span class="number">1</span>] |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">2</span>]&lt;&lt;<span class="number">8</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">3</span>]&lt;&lt;<span class="number">16</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">4</span>]&lt;&lt;<span class="number">24</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">5</span>]&lt;&lt;<span class="number">32</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">6</span>]&lt;&lt;<span class="number">40</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">7</span>]&lt;&lt;<span class="number">48</span> |</span><br><span class="line">               (<span class="keyword">uint64_t</span>)p[<span class="number">8</span>]&lt;&lt;<span class="number">56</span>;</span><br><span class="line">        negstart = (<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>;</span><br><span class="line">        negmax = UINT64_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_12BIT_STR(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        *count = LP_ENCODING_12BIT_STR_LEN(p);</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LP_ENCODING_IS_32BIT_STR(p[<span class="number">0</span>])) &#123;</span><br><span class="line">        *count = LP_ENCODING_32BIT_STR_LEN(p);</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        uval = <span class="number">12345678900000000U</span>LL + p[<span class="number">0</span>];</span><br><span class="line">        negstart = UINT64_MAX;</span><br><span class="line">        negmax = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We reach this code path only for integer encodings.</span></span><br><span class="line"><span class="comment">     * Convert the unsigned value to the signed one using two&#x27;s complement</span></span><br><span class="line"><span class="comment">     * rule. */</span></span><br><span class="line">     <span class="comment">// 如果是负整数，则转为有符号整数</span></span><br><span class="line">    <span class="keyword">if</span> (uval &gt;= negstart) &#123;</span><br><span class="line">        <span class="comment">/* This three steps conversion should avoid undefined behaviors</span></span><br><span class="line"><span class="comment">         * in the unsigned -&gt; signed conversion. */</span></span><br><span class="line">        uval = negmax-uval;</span><br><span class="line">        val = uval;</span><br><span class="line">        val = -val<span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = uval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the string representation of the integer or the value itself</span></span><br><span class="line"><span class="comment">     * depending on intbuf being NULL or not. */</span></span><br><span class="line">    <span class="keyword">if</span> (intbuf) &#123;</span><br><span class="line">        *count = <span class="built_in">snprintf</span>((<span class="keyword">char</span>*)intbuf,LP_INTBUF_SIZE,<span class="string">&quot;%lld&quot;</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)val);</span><br><span class="line">        <span class="keyword">return</span> intbuf;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *count = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：listpack.c/listpack.h&lt;/p&gt;
&lt;p&gt;Redis 5.0版本引入的一个新的数据结构，它是对ziplist压缩列表的改进，listpack结构更为精简，更加节省内存空间。它的实现方式也和ziplist很类似，所以阅读理解起来并不难。也许该数据结构设计出来是要替代ziplist的，只不过ziplist目前在redis中的应用非常广泛，替换起来复杂度很高，所以目前该数据结构只有在新引入的stream数据结构中使用，可能将来有一天会全面替换ziplist。  &lt;/p&gt;
&lt;p&gt;相对于ziplist，listpack取消了存储前置节点长度的字段，listpack的节点之间是相互独立的，改变前置节点的长度，不会影响到后续节点的长度，所以再也不需要连锁更新操作。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-快速列表quicklist</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-quicklist/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-quicklist/</id>
    <published>2020-09-21T09:08:53.000Z</published>
    <updated>2020-09-21T09:52:42.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：quicklist.c/quicklist.h</p><p>Redis3.2版本以前的列表底层的编码是ziplist和linkedlist(adlist.c)实现的，3.2版本后引入了quicklist的数据结构，列表底层都由quicklist来实现。本质上，quicklist是由ziplist和linkedlist结合而成。所以，学习quicklist之前，需要明白<a href="../redis-parse-zskiplist">ziplist</a>的原理。<br><a id="more"></a><br><strong>ziplist：</strong><br>优点：存储效率高，内存开销少。<br>缺点：进行插入、修改、删除操作时，需要频繁的申请和释放内存，当ziplist很长时，一次realloc可能会导致很大的内存拷贝。ziplist操作还有可能进行连锁更新操作，时间复杂度增加。<br><strong>linkedlist：</strong><br>优点：便于在两端进行push或pop操作时间复杂度低。<br>缺点：内存开销大，因为是不连续的内存块，所以节点多了容易产生内存碎片。<br><strong>quicklist：</strong><br>quicklist本质上节点为ziplist的双向链表的数据结构，所以quicklist结合了两者的优点。<br>从存储效率上分析：</p><ol><li>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能产生很多无法利用的内存碎片，导致存储效率降低。</li><li>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续的内存空间难度就越大。有可能出现内存里有很多小的空闲空间无法使用，同样会导致存储效率降低。  </li></ol><p>所以ziplist的长度，需要根据实际使用场景来进行调整，redis提供了配置参数list-max-ziplist-size，可供使用者来进行设定。</p><p><strong>quicklist结构：</strong><br><img src="/Redis/first-stage/redis-parse-quicklist/quicklist.png" alt="quicklist"></p><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;           <span class="comment">// 压缩列表ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">// 表示指向ziplist结构的总长度(内存占用长度)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">// ziplist中的节点数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">// ziplist是否压缩。取值：1--ziplist，2--quicklistLZF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">// 存储类型，目前使用固定值2 表示使用ziplist存储</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">// 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span> <span class="comment">// // 测试相关</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span> <span class="comment">// // 扩展字段，暂时没用</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span> <span class="comment">// 压缩后的ziplist大小</span></span><br><span class="line">    <span class="keyword">char</span> compressed[]; <span class="comment">// 柔性数组，存放压缩后的ziplist字节数组</span></span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistBookmark</span> &#123;</span></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">&#125; quicklistBookmark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="keyword">int</span> fill : QL_FILL_BITS;              <span class="comment">/* fill factor for individual nodes */</span> <span class="comment">// 负数代表级别，正数代表个数，配置文件中定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span> <span class="comment">// 压缩级别，配置文件中定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bookmark_count: QL_BM_BITS; <span class="comment">// 书签数，测试用</span></span><br><span class="line">    quicklistBookmark bookmarks[]; <span class="comment">// 书签，测试用</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fill和compress由配置文件redis.conf定义。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">fill成员对应的配置：list-max-ziplist-size -2</span></span><br><span class="line"><span class="comment">当数字为负数，表示以下含义：</span></span><br><span class="line"><span class="comment">-1 每个quicklistNode节点的ziplist字节大小不能超过4kb。（建议）</span></span><br><span class="line"><span class="comment">-2 每个quicklistNode节点的ziplist字节大小不能超过8kb。（默认配置）</span></span><br><span class="line"><span class="comment">-3 每个quicklistNode节点的ziplist字节大小不能超过16kb。（一般不建议）</span></span><br><span class="line"><span class="comment">-4 每个quicklistNode节点的ziplist字节大小不能超过32kb。（不建议）</span></span><br><span class="line"><span class="comment">-5 每个quicklistNode节点的ziplist字节大小不能超过64kb。（正常工作量不建议）</span></span><br><span class="line"><span class="comment">代码中的定义static const size_t optimization_level[] = &#123;4096, 8192, 16384, 32768, 65536&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当数字为正数，表示：ziplist结构所最多包含的entry个数。最大值为 215215。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">compress成员对应的配置：list-compress-depth 0</span></span><br><span class="line"><span class="comment">后面的数字有以下含义：</span></span><br><span class="line"><span class="comment">0： 表示不压缩。（默认）</span></span><br><span class="line"><span class="comment">1： 表示quicklist列表的两端各有1个节点不压缩，中间的节点压缩。</span></span><br><span class="line"><span class="comment">2： 表示quicklist列表的两端各有2个节点不压缩，中间的节点压缩。</span></span><br><span class="line"><span class="comment">3： 表示quicklist列表的两端各有3个节点不压缩，中间的节点压缩。</span></span><br><span class="line"><span class="comment">以此类推，最大为 216216。</span></span><br><span class="line"><span class="comment">首位节点不压缩，是因为支持快速的push/pop操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist;</span><br><span class="line">    quicklistNode *current;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;</span><br><span class="line">    <span class="keyword">long</span> offset; <span class="comment">/* offset in current ziplist */</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; quicklistIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间结构，用于查找、删除等操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist; <span class="comment">// quicklist</span></span><br><span class="line">    quicklistNode *node; <span class="comment">// 当前的节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi; <span class="comment">// ziplist结构指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value; <span class="comment">// 当前entry的数据，是字符串</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval; <span class="comment">// 当前entry的数据，是整数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">// 当前ziplist的字节数</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">// entry的当前偏移量</span></span><br><span class="line">&#125; quicklistEntry;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_TAIL -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist node encodings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_ENCODING_RAW 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_ENCODING_LZF 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist compression disable */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NOCOMPRESS 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist container formats */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_CONTAINER_NONE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_CONTAINER_ZIPLIST 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> quicklistNodeIsCompressed(node)                                        \</span></span><br><span class="line">    ((node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF)</span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototypes */</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建quicklist</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistNew</span><span class="params">(<span class="keyword">int</span> fill, <span class="keyword">int</span> compress)</span></span>; <span class="comment">// 创建quicklist并设定fill和compress</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistSetCompressDepth</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> depth)</span></span>; <span class="comment">// 设置quicklist的compress</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistSetFill</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> fill)</span></span>; <span class="comment">// 设置quicklist的fill</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistSetOptions</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> fill, <span class="keyword">int</span> depth)</span></span>; <span class="comment">// 设置quicklist的fill和compress</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRelease</span><span class="params">(quicklist *quicklist)</span></span>; <span class="comment">// 释放quicklist</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// 头部节点插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// 尾部节点插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> where)</span></span>; <span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistAppendZiplist</span><span class="params">(quicklist *quicklist, <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>; <span class="comment">// 向quicklist中插入一个已定义的ziplist（需要创建quicklistCreateNode）(浅拷贝)</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistAppendValuesFromZiplist</span><span class="params">(quicklist *quicklist,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>; <span class="comment">// 向quicklist复制ziplist中的值（深拷贝）</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistCreateFromZiplist</span><span class="params">(<span class="keyword">int</span> fill, <span class="keyword">int</span> compress,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>; <span class="comment">//创建quicklist并复制ziplist中的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertAfter</span><span class="params">(quicklist *quicklist, quicklistEntry *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertBefore</span><span class="params">(quicklist *quicklist, quicklistEntry *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz)</span></span>; <span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span></span>; <span class="comment">// 删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistReplaceAtIndex</span><span class="params">(quicklist *quicklist, <span class="keyword">long</span> index, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> sz)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> start, <span class="keyword">const</span> <span class="keyword">long</span> stop)</span></span>;</span><br><span class="line"><span class="function">quicklistIter *<span class="title">quicklistGetIterator</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"><span class="function">quicklistIter *<span class="title">quicklistGetIteratorAtIdx</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">int</span> direction, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistNext</span><span class="params">(quicklistIter *iter, quicklistEntry *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistReleaseIterator</span><span class="params">(quicklistIter *iter)</span></span>;</span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistDup</span><span class="params">(quicklist *orig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistIndex</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                   quicklistEntry *entry)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRewind</span><span class="params">(quicklist *quicklist, quicklistIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRewindTail</span><span class="params">(quicklist *quicklist, quicklistIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRotate</span><span class="params">(quicklist *quicklist)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPopCustom</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *sval,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *(*saver)(<span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> sz))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPop</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *slong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">quicklistCount</span><span class="params">(<span class="keyword">const</span> quicklist *ql)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistCompare</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p1, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p2, <span class="keyword">int</span> p2_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">quicklistGetLzf</span><span class="params">(<span class="keyword">const</span> quicklistNode *node, <span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bookmarks */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistBookmarkCreate</span><span class="params">(quicklist **ql_ref, <span class="keyword">const</span> <span class="keyword">char</span> *name, quicklistNode *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistBookmarkDelete</span><span class="params">(quicklist *ql, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">quicklistNode *<span class="title">quicklistBookmarkFind</span><span class="params">(quicklist *ql, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistBookmarksClear</span><span class="params">(quicklist *ql)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>创建与释放：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quicklist创建</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> *<span class="title">quicklist</span>;</span></span><br><span class="line"></span><br><span class="line">    quicklist = zmalloc(<span class="keyword">sizeof</span>(*quicklist));</span><br><span class="line">    quicklist-&gt;head = quicklist-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    quicklist-&gt;len = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;count = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;compress = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;fill = <span class="number">-2</span>;</span><br><span class="line">    quicklist-&gt;bookmark_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> quicklist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quicklistNode创建</span></span><br><span class="line"><span class="function">REDIS_STATIC quicklistNode *<span class="title">quicklistCreateNode</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    node = zmalloc(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">    node-&gt;zl = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;count = <span class="number">0</span>;</span><br><span class="line">    node-&gt;sz = <span class="number">0</span>;</span><br><span class="line">    node-&gt;next = node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;encoding = QUICKLIST_NODE_ENCODING_RAW;</span><br><span class="line">    node-&gt;container = QUICKLIST_NODE_CONTAINER_ZIPLIST;</span><br><span class="line">    node-&gt;recompress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRelease</span><span class="params">(quicklist *quicklist)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    quicklistNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = quicklist-&gt;head;</span><br><span class="line">    len = quicklist-&gt;len;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        zfree(current-&gt;zl);</span><br><span class="line">        quicklist-&gt;count -= current-&gt;count;</span><br><span class="line"></span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        quicklist-&gt;len--;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    quicklistBookmarksClear(quicklist);</span><br><span class="line">    zfree(quicklist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistBookmarksClear</span><span class="params">(quicklist *ql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ql-&gt;bookmark_count)</span><br><span class="line">        zfree(ql-&gt;bookmarks[--ql-&gt;bookmark_count].name);</span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> We do not shrink (realloc) the quick list. main use case for this</span></span><br><span class="line"><span class="comment">     * function is just before releasing the allocation. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>push操作：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="comment">// likely可以让编译器进行代码优化，表示告知编译器，括号里的值为真的可能性更大，这样编译器在编译过程中，会将可能性更大的代码紧跟着前面的代码，从而减少指令跳转带来的性能上的下降</span></span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            <span class="comment">// 判断头节点是否能插入新元素</span></span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 如果能插入，则调用ziplistPush插入新元素</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        <span class="comment">// 更新node的sz指针指向</span></span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不能插入，则创建一个新的quicklistNode用于插入新元素</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        <span class="comment">// 调用ziplistNew创建新的ziplist，并ziplistPush插入新元素</span></span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新node的sz指针指向</span></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新的node结点插入到quicklist头部</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_tail = quicklist-&gt;tail;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;tail-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;tail);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新的node结点插入到quicklist尾部</span></span><br><span class="line">        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;tail-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_tail != quicklist-&gt;tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node,</span><br><span class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ziplist_overhead; <span class="comment">// 根据sz来估算将要插入的entry的大小</span></span><br><span class="line">    <span class="comment">/* size of previous offset */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)   <span class="comment">// 根据ziplist的性质，计算entry的prevlen的编码大小，小于254为1位，大于等于254为5位</span></span><br><span class="line">        ziplist_overhead = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of forward offset */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)    <span class="comment">// 对entry的len进行编码，小于64为ZIP_STR_06B或者整数，1个字节</span></span><br><span class="line">        ziplist_overhead += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>)) <span class="comment">// 小于16384，为ZIP_STR_14B，2个字节</span></span><br><span class="line">        ziplist_overhead += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 否则为ZIP_STR_32B，5个字节</span></span><br><span class="line">        ziplist_overhead += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* new_sz overestimates if &#x27;sz&#x27; encodes to an integer type */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead; <span class="comment">// 插入元素后，大致计算出ziplist的大小（忽略连锁更新）</span></span><br><span class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill))) <span class="comment">// 是否超过ziplist设定的存储限制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz)) <span class="comment">// 判断是不是安全的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill) <span class="comment">// 最后判断个数限制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pop操作：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPop</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *slong)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">    <span class="keyword">if</span> (quicklist-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = quicklistPopCustom(quicklist, where, &amp;vstr, &amp;vlen, &amp;vlong,</span><br><span class="line">                                 _quicklistSaver);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        *data = vstr;</span><br><span class="line">    <span class="keyword">if</span> (slong)</span><br><span class="line">        *slong = vlong;</span><br><span class="line">    <span class="keyword">if</span> (sz)</span><br><span class="line">        *sz = vlen;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPopCustom</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *sval,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *(*saver)(<span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> sz))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">    <span class="keyword">int</span> pos = (where == QUICKLIST_HEAD) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quicklist-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        *data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (sz)</span><br><span class="line">        *sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sval)</span><br><span class="line">        *sval = <span class="number">-123456789</span>;</span><br><span class="line"></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD &amp;&amp; quicklist-&gt;head) &#123;</span><br><span class="line">        node = quicklist-&gt;head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL &amp;&amp; quicklist-&gt;tail) &#123;</span><br><span class="line">        node = quicklist-&gt;tail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = ziplistIndex(node-&gt;zl, pos);</span><br><span class="line">    <span class="keyword">if</span> (ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vlong)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data)</span><br><span class="line">                *data = saver(vstr, vlen);</span><br><span class="line">            <span class="keyword">if</span> (sz)</span><br><span class="line">                *sz = vlen;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data)</span><br><span class="line">                *data = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (sval)</span><br><span class="line">                *sval = vlong;</span><br><span class="line">        &#125;</span><br><span class="line">        quicklistDelIndex(quicklist, node, &amp;p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> </span>&#123;</span><br><span class="line">    quicklistNode *prev = entry-&gt;node-&gt;prev;</span><br><span class="line">    quicklistNode *next = entry-&gt;node-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,</span><br><span class="line">                                         entry-&gt;node, &amp;entry-&gt;zi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* after delete, the zi is now invalid for any future usage. */</span></span><br><span class="line">    iter-&gt;zi = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If current node is deleted, we must update iterator node and offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (deleted_node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</span><br><span class="line">            iter-&gt;current = next;</span><br><span class="line">            iter-&gt;offset = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</span><br><span class="line">            iter-&gt;current = prev;</span><br><span class="line">            iter-&gt;offset = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* else if (!deleted_node), no changes needed.</span></span><br><span class="line"><span class="comment">     * we already reset iter-&gt;zi above, and the existing iter-&gt;offset</span></span><br><span class="line"><span class="comment">     * doesn&#x27;t move again because:</span></span><br><span class="line"><span class="comment">     *   - [1, 2, 3] =&gt; delete offset 1 =&gt; [1, 3]: next element still offset 1</span></span><br><span class="line"><span class="comment">     *   - [1, 2, 3] =&gt; delete offset 0 =&gt; [2, 3]: next element still offset 0</span></span><br><span class="line"><span class="comment">     *  if we deleted the last element at offet N and now</span></span><br><span class="line"><span class="comment">     *  length of this ziplist is N-1, the next call into</span></span><br><span class="line"><span class="comment">     *  quicklistNext() will jump to the next node. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">REDIS_STATIC <span class="keyword">int</span> <span class="title">quicklistDelIndex</span><span class="params">(quicklist *quicklist, quicklistNode *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gone = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    node-&gt;zl = ziplistDelete(node-&gt;zl, p);</span><br><span class="line">    node-&gt;count--;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">        gone = <span class="number">1</span>;</span><br><span class="line">        __quicklistDelNode(quicklist, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count--;</span><br><span class="line">    <span class="comment">/* If we deleted the node, the original node is no longer valid */</span></span><br><span class="line">    <span class="keyword">return</span> gone ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">void</span> __quicklistDelNode(quicklist *quicklist,</span><br><span class="line">                                     quicklistNode *node) &#123;</span><br><span class="line">    <span class="comment">/* Update the bookmark if any */</span></span><br><span class="line">    quicklistBookmark *bm = _quicklistBookmarkFindByNode(quicklist, node);</span><br><span class="line">    <span class="keyword">if</span> (bm) &#123;</span><br><span class="line">        bm-&gt;node = node-&gt;next;</span><br><span class="line">        <span class="comment">/* if the bookmark was to the last node, delete it. */</span></span><br><span class="line">        <span class="keyword">if</span> (!bm-&gt;node)</span><br><span class="line">            _quicklistBookmarkDelete(quicklist, bm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == quicklist-&gt;tail) &#123;</span><br><span class="line">        quicklist-&gt;tail = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == quicklist-&gt;head) &#123;</span><br><span class="line">        quicklist-&gt;head = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we deleted a node within our compress depth, we</span></span><br><span class="line"><span class="comment">     * now have compressed nodes needing to be decompressed. */</span></span><br><span class="line">    __quicklistCompress(quicklist, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    quicklist-&gt;count -= node-&gt;count;</span><br><span class="line"></span><br><span class="line">    zfree(node-&gt;zl);</span><br><span class="line">    zfree(node);</span><br><span class="line">    quicklist-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistIndex</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                   quicklistEntry *entry)</span> </span>&#123;</span><br><span class="line">    quicklistNode *n;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> accum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">int</span> forward = idx &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">/* &lt; 0 -&gt; reverse, 0+ -&gt; forward */</span> <span class="comment">// 正向遍历或者是反向遍历</span></span><br><span class="line"></span><br><span class="line">    initEntry(entry);</span><br><span class="line">    entry-&gt;quicklist = quicklist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向遍历，从头节点开始查找，反向遍历，从尾节点开始查找</span></span><br><span class="line">    <span class="keyword">if</span> (!forward) &#123;</span><br><span class="line">        index = (-idx) - <span class="number">1</span>;</span><br><span class="line">        n = quicklist-&gt;tail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        index = idx;</span><br><span class="line">        n = quicklist-&gt;head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= quicklist-&gt;count)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找index在哪个quicklistNode中</span></span><br><span class="line">    <span class="keyword">while</span> (likely(n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((accum + n-&gt;count) &gt; index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            D(<span class="string">&quot;Skipping over (%p) %u at accum %lld&quot;</span>, (<span class="keyword">void</span> *)n, n-&gt;count,</span><br><span class="line">              accum);</span><br><span class="line">            accum += n-&gt;count;</span><br><span class="line">            n = forward ? n-&gt;next : n-&gt;prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    D(<span class="string">&quot;Found node: %p at accum %llu, idx %llu, sub+ %llu, sub- %llu&quot;</span>, (<span class="keyword">void</span> *)n,</span><br><span class="line">      accum, index, index - accum, (-index) - <span class="number">1</span> + accum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算index在命中的节点中的偏移量</span></span><br><span class="line">    entry-&gt;node = n;</span><br><span class="line">    <span class="keyword">if</span> (forward) &#123;</span><br><span class="line">        <span class="comment">/* forward = normal head-to-tail offset. */</span></span><br><span class="line">        entry-&gt;offset = index - accum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* reverse = need negative offset for tail-to-head, so undo</span></span><br><span class="line"><span class="comment">         * the result of the original if (index &lt; 0) above. */</span></span><br><span class="line">        entry-&gt;offset = (-index) - <span class="number">1</span> + accum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quicklistDecompressNodeForUse(entry-&gt;node); <span class="comment">// listzip如果压缩，则进行解压</span></span><br><span class="line">    entry-&gt;zi = ziplistIndex(entry-&gt;node-&gt;zl, entry-&gt;offset); <span class="comment">// 定位ziplist中指定index的地址</span></span><br><span class="line">    ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval); <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="comment">/* The caller will use our result, so we don&#x27;t re-compress here.</span></span><br><span class="line"><span class="comment">     * The caller can recompress or delete the node as needed. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：quicklist.c/quicklist.h&lt;/p&gt;
&lt;p&gt;Redis3.2版本以前的列表底层的编码是ziplist和linkedlist(adlist.c)实现的，3.2版本后引入了quicklist的数据结构，列表底层都由quicklist来实现。本质上，quicklist是由ziplist和linkedlist结合而成。所以，学习quicklist之前，需要明白&lt;a href=&quot;../redis-parse-zskiplist&quot;&gt;ziplist&lt;/a&gt;的原理。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-压缩列表ziplist</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-ziplist/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-ziplist/</id>
    <published>2020-09-21T09:08:45.000Z</published>
    <updated>2020-09-21T09:52:51.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：ziplist.c/ziplist.h</p><p>ziplist在redis中主要用于Hash与List数据结构的底层实现之一，ziplist没有定义专门的结构体，其在内存块中的表示如下图所示：<br><a id="more"></a><br><strong>ziplist结构：</strong><br><img src="/Redis/first-stage/redis-parse-ziplist/ziplist.png" alt="ziplist"><br>|属性       |类型       |长度        |用途        |<br>|—-        |—-        |—-        |—-        |<br>|zlbytes    |uint<em>32t   |4B         |记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend的位置时使用 |<br>|zltail     |uint_32t   |4B         |记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。|<br>|zllen      |uint_16t   |2B         |记录了压缩列表包含的节点数量： 当这个属性的值小于UINT16</em> MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。|<br>|entry      |列表节点    |不定       |压缩列表包含的各个节点，节点的长度由节点保存的内容决定。|<br>|zlend      |uint_8t    |1B         | 0xFF（255），用于标记压缩列表的末端。|  </p><p><strong>entry结构：</strong><br><img src="/Redis/first-stage/redis-parse-ziplist/ziplist_entry.png" alt="entry"><br>prevrawlen：前置节点的长度  </p><ol><li><p>如果长度小于254个字节，则使用1字节（uint8_t）来存储prevrawlen。</p></li><li><p>如果长度大于或等于254字节，则使用5字节(uint32_t)来存储prevrawlen。  </p></li></ol><p>len/encoding：当前节点的长度（编码类型）<br><img src="/Redis/first-stage/redis-parse-ziplist/ziplist_encoding.png" alt="encoding"></p><p>data：数据  </p><p>实际上，源码里有定义zlentry的结构体，但是这个结构体并不是实际上存储的节点结构，它仅做中间结构操作使用。  </p><p>&lt;/br&gt;</p><p><strong>时间复杂度：</strong><br>| 函数          | 作用          | 时间复杂度 |<br>| —-           |—-           |—-        |<br>|ziplistNew     |创建跳跃表     |O(1)       |<br>|ziplistInsert  |插入节点       |平均O(N)（耗时在连锁更新）       |<br>|ziplistDelete  |删除节点       |平均O(N)（耗时在连锁更新）       |<br>|ziplistFind    |查找节点       |平均O(N)   |<br>&lt;/br&gt;<br>&lt;/br&gt;</p><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ziplist.h:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ziplist.c:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_END 255         <span class="comment">/* Special &quot;end of ziplist&quot; entry. */</span> <span class="comment">// 列表末尾值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_BIG_PREVLEN 254 <span class="comment">/* Max number of bytes of the previous entry, for</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               the &quot;prevlen&quot; field prefixing each entry, to be</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               represented with just a single byte. Otherwise</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               it is represented as FF AA BB CC DD, where</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               AA BB CC DD are a 4 bytes unsigned integer</span></span></span><br><span class="line"><span class="meta"><span class="comment">                               representing the previous entry len. */</span> <span class="comment">// 列表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Different encoding/length possibilities */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_MASK 0xc0           <span class="comment">// 11000000 : 如果encoding小于ZIP_STR_MASK，则为字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_MASK 0x30           <span class="comment">// 00110000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)        <span class="comment">// 00aaaaaa : 高位2个bit00表示len只有一个字节，后面6个bit表示数据长度值，最高可以表示63字节（2^6-1）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)        <span class="comment">// 01aaaaaa aaaaaaaa : 高位2个bit01表示len有两个字节，剩余的14个bit表示数据长度值，最高可以表示16383字节（2^14-1）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)        <span class="comment">// 10______ aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa : 高位2个bit10表示len有五个字节，接下来的6个bit不使用，剩余的bit表示数据长度值，最高可以表示16383字节（2^14-1）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)   <span class="comment">// 11000000 ：int16_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)   <span class="comment">// 11010000 ：int32_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)   <span class="comment">// 11100000 ：int64_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)   <span class="comment">// 11110000 ：24位有符号整数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_8B 0xfe             <span class="comment">// 11111110 ：8位有符号整数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 bit integer immediate encoding |1111xxxx| with xxxx between</span></span><br><span class="line"><span class="comment"> * 0001 and 1101. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MASK 0x0f   <span class="comment">/* Mask to extract the 4 bits value. To add</span></span></span><br><span class="line"><span class="meta"><span class="comment">                                   one is needed to reconstruct the value. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MIN 0xf1    <span class="comment">/* 11110001 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MAX 0xfd    <span class="comment">/* 11111101 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT24_MAX 0x7fffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT24_MIN (-INT24_MAX - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro to determine if the entry is a string. String entries never start</span></span><br><span class="line"><span class="comment"> * with &quot;11&quot; as most significant bits of the first byte. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK) <span class="comment">// 判断是不是字符串</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Utility macros.*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return total bytes a ziplist is composed of. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the offset of the last item inside the ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the length of a ziplist, or UINT16_MAX if the length cannot be</span></span><br><span class="line"><span class="comment"> * determined without scanning the whole ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The size of a ziplist header: two 32 bit integers for the total</span></span><br><span class="line"><span class="comment"> * bytes count and last item offset. One 16 bit integer for the number</span></span><br><span class="line"><span class="comment"> * of items field. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the &quot;end of ziplist&quot; entry. Just one byte. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the pointer to the first entry of a ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the pointer to the last entry of a ziplist, using the</span></span><br><span class="line"><span class="comment"> * last entry offset inside the ziplist header. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the pointer to the last byte of a ziplist, which is, the</span></span><br><span class="line"><span class="comment"> * end of ziplist FF entry. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Increment the number of items field in the ziplist header. Note that this</span></span><br><span class="line"><span class="comment"> * macro should never overflow the unsigned 16 bit integer, since entries are</span></span><br><span class="line"><span class="comment"> * always pushed one at a time. When UINT16_MAX is reached we want the count</span></span><br><span class="line"><span class="comment"> * to stay there to signal that a full scan is needed to get the number of</span></span><br><span class="line"><span class="comment"> * items inside the ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_INCR_LENGTH(zl,incr) &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> (ZIPLIST_LENGTH(zl) &lt; UINT16_MAX) \</span><br><span class="line">        ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩列表的节点</span></span><br><span class="line"><span class="comment">/* We use this function to receive information about a ziplist entry.</span></span><br><span class="line"><span class="comment"> * Note that this is not how the data is actually encoded, is just what we</span></span><br><span class="line"><span class="comment"> * get filled by a function in order to operate more easily. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码 prevrawlen 所需的字节大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="comment">// 前置节点的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="comment">// 编码 len 所需的字节大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="comment">// 当前节点的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="comment">// 当前节点 header 的大小，prevrawlensize + lensize</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="comment">// 类型编码:3种字符编码+6种整数编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_ZERO(zle) &#123; \</span></span><br><span class="line">    (zle)-&gt;prevrawlensize = (zle)-&gt;prevrawlen = <span class="number">0</span>; \</span><br><span class="line">    (zle)-&gt;lensize = (zle)-&gt;len = (zle)-&gt;headersize = <span class="number">0</span>; \</span><br><span class="line">    (zle)-&gt;encoding = <span class="number">0</span>; \</span><br><span class="line">    (zle)-&gt;p = <span class="literal">NULL</span>; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extract the encoding from the byte pointed by &#x27;ptr&#x27; and set it into</span></span><br><span class="line"><span class="comment"> * &#x27;encoding&#x27; field of the zlentry structure. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_ENTRY_ENCODING(ptr, encoding) do &#123;  \</span></span><br><span class="line">    (encoding) = (ptr[<span class="number">0</span>]); \</span><br><span class="line">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&lt;/br&gt;</p><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistMerge</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> **first, <span class="keyword">unsigned</span> <span class="keyword">char</span> **second)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistIndex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **sval, <span class="keyword">unsigned</span> <span class="keyword">int</span> *slen, <span class="keyword">long</span> <span class="keyword">long</span> *lval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDeleteRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistCompare</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistFind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">unsigned</span> <span class="keyword">int</span> skip)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ziplistBlobLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ziplistRepr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>;</span><br></pre></td></tr></table></figure><p>&lt;/br&gt;</p><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>创建：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的压缩列表</span></span><br><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes); <span class="comment">// 大端模式转小端模式</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新分配ziplist内存大小</span></span><br><span class="line"><span class="comment">/* Resize the ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    zl = zrealloc(zl,len);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(len);</span><br><span class="line">    zl[len<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert an entry at &quot;p&quot;. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert item at &quot;p&quot;. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen; <span class="comment">// reqlen用于计算存储当前节点需要的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value</span></span><br><span class="line"><span class="comment">                                    that is easy to see if for some reason</span></span><br><span class="line"><span class="comment">                                    we use it uninitialized. */</span></span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></span><br><span class="line">    <span class="comment">// 以下步骤是为了获取前一个节点的长度</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if the entry can be encoded */</span></span><br><span class="line">    <span class="comment">// 尝试进行整数字符串编码</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is set to the appropriate integer encoding */</span></span><br><span class="line">        reqlen = zipIntSize(encoding); <span class="comment">// 获取数据存储需要的字节数（data部分）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is untouched, however zipStoreEntryEncoding will use the</span></span><br><span class="line"><span class="comment">         * string length to figure out how to encode it. */</span></span><br><span class="line">        reqlen = slen; <span class="comment">// 字符串长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We need space for both the length of the previous entry and</span></span><br><span class="line"><span class="comment">     * the length of the payload. */</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen); <span class="comment">// 存储前节点长度需要的字节数</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen); <span class="comment">// 存储当前节点encoding需要的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the insert position is not equal to the tail, we need to</span></span><br><span class="line"><span class="comment">     * make sure that the next entry can hold this entry&#x27;s length in</span></span><br><span class="line"><span class="comment">     * its prevlen field. */</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>; <span class="comment">// 看是否会引起后面节点的长度变化，如果有变化，需要进行联锁更新</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff); <span class="comment">// 重新分配ziplist的大小，为插入节点做准备，给新的尾部节点赋值FF，更新头部节点zlbyte的值</span></span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class="line">    <span class="comment">// 更新zltail信息</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff); <span class="comment">// 数据往后移动，并根据nextdiff进行调整</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Encode this entry&#x27;s raw length in the next entry. */</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update offset for tail */</span></span><br><span class="line">        <span class="comment">// 更新zltail的值</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">         * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */</span></span><br><span class="line">        zipEntry(p+reqlen, &amp;tail); <span class="comment">// 构造节点</span></span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">// 尾结点的值也需要根据nextdiff进行微调</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This element will be the new tail. */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果后面节点有长度变化，需要更新之后的所有节点的变化</span></span><br><span class="line">        offset = p-zl; <span class="comment">// 记录新节点的偏移量</span></span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen); <span class="comment">// 连锁更新</span></span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the entry */</span></span><br><span class="line">    <span class="comment">// 编辑新节点的值</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编码encoding字段相关：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是不是整数字符串，如果是，确定其编码类型</span></span><br><span class="line"><span class="comment">/* Check if string pointed to by &#x27;entry&#x27; can be encoded as an integer.</span></span><br><span class="line"><span class="comment"> * Stores the integer value in &#x27;v&#x27; and its encoding in &#x27;encoding&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipTryEncoding</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *entry, <span class="keyword">unsigned</span> <span class="keyword">int</span> entrylen, <span class="keyword">long</span> <span class="keyword">long</span> *v, <span class="keyword">unsigned</span> <span class="keyword">char</span> *encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entrylen &gt;= <span class="number">32</span> || entrylen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (string2ll((<span class="keyword">char</span>*)entry,entrylen,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* Great, the string can be encoded. Check what&#x27;s the smallest</span></span><br><span class="line"><span class="comment">         * of our encoding types that can hold this value. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">            *encoding = ZIP_INT_IMM_MIN+value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_8B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_16B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_24B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_32B;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *encoding = ZIP_INT_64B;</span><br><span class="line">        &#125;</span><br><span class="line">        *v = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store integer &#x27;value&#x27; at &#x27;p&#x27;, encoded as &#x27;encoding&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zipSaveInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int64_t</span> value, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_8B) &#123;</span><br><span class="line">        ((<span class="keyword">int8_t</span>*)p)[<span class="number">0</span>] = (<span class="keyword">int8_t</span>)value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        i16 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i16,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">        memrev16ifbe(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_24B) &#123;</span><br><span class="line">        i32 = value&lt;&lt;<span class="number">8</span>;</span><br><span class="line">        memrev32ifbe(&amp;i32);</span><br><span class="line">        <span class="built_in">memcpy</span>(p,((<span class="keyword">uint8_t</span>*)&amp;i32)+<span class="number">1</span>,<span class="keyword">sizeof</span>(i32)-<span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        i32 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i32,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">        memrev32ifbe(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        i64 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i64,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">        memrev64ifbe(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) &#123;</span><br><span class="line">        <span class="comment">/* Nothing to do, the value is stored in the encoding itself. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read integer encoded as &#x27;encoding&#x27; from &#x27;p&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">zipLoadInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_8B) &#123;</span><br><span class="line">        ret = ((<span class="keyword">int8_t</span>*)p)[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i16,p,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">        memrev16ifbe(&amp;i16);</span><br><span class="line">        ret = i16;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i32,p,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">        memrev32ifbe(&amp;i32);</span><br><span class="line">        ret = i32;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_24B) &#123;</span><br><span class="line">        i32 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(((<span class="keyword">uint8_t</span>*)&amp;i32)+<span class="number">1</span>,p,<span class="keyword">sizeof</span>(i32)-<span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        memrev32ifbe(&amp;i32);</span><br><span class="line">        ret = i32&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i64,p,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">        memrev64ifbe(&amp;i64);</span><br><span class="line">        ret = i64;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) &#123;</span><br><span class="line">        ret = (encoding &amp; ZIP_INT_IMM_MASK)<span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Find pointer to the entry equal to the specified entry. Skip &#x27;skip&#x27; entries</span></span><br><span class="line"><span class="comment"> * between every comparison. Returns NULL when the field could not be found. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistFind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">unsigned</span> <span class="keyword">int</span> skip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> skipcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> vencoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vll = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, encoding, lensize, len;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *q;</span><br><span class="line"></span><br><span class="line">        ZIP_DECODE_PREVLENSIZE(p, prevlensize); <span class="comment">// 获取当前节点prelen的size，为了P往后偏移取出encoding</span></span><br><span class="line">        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len); <span class="comment">// 获取当前节点encoding的size和数据size</span></span><br><span class="line">        q = p + prevlensize + lensize; <span class="comment">// q指向该节点存储的数据地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipcnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Compare current entry with specified entry */</span></span><br><span class="line">            <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == vlen &amp;&amp; <span class="built_in">memcmp</span>(q, vstr, vlen) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Find out if the searched field can be encoded. Note that</span></span><br><span class="line"><span class="comment">                 * we do it only the first time, once done vencoding is set</span></span><br><span class="line"><span class="comment">                 * to non-zero and vll is set to the integer value. */</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) &#123;</span><br><span class="line">                        <span class="comment">/* If the entry can&#x27;t be encoded we set it to</span></span><br><span class="line"><span class="comment">                         * UCHAR_MAX so that we don&#x27;t retry again the next</span></span><br><span class="line"><span class="comment">                         * time. */</span></span><br><span class="line">                        vencoding = UCHAR_MAX;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* Must be non-zero by now */</span></span><br><span class="line">                    assert(vencoding);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Compare current entry with specified entry, do it only</span></span><br><span class="line"><span class="comment">                 * if vencoding != UCHAR_MAX because if there is no encoding</span></span><br><span class="line"><span class="comment">                 * possible for the field it can&#x27;t be a valid integer. */</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding != UCHAR_MAX) &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> ll = zipLoadInteger(q, encoding);</span><br><span class="line">                    <span class="keyword">if</span> (ll == vll) &#123;</span><br><span class="line">                        <span class="keyword">return</span> p;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Reset skip count */</span></span><br><span class="line">            skipcnt = skip;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Skip entry */</span></span><br><span class="line">            skipcnt--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Move to next entry */</span></span><br><span class="line">        p = q + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历相关：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回下一个节点的位置</span></span><br><span class="line"><span class="comment">/* Return pointer to next entry in ziplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zl is the pointer to the ziplist</span></span><br><span class="line"><span class="comment"> * p is the pointer to the current element</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The element after &#x27;p&#x27; is returned, otherwise NULL if we are at the end. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>) zl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &quot;p&quot; could be equal to ZIP_END, caused by ziplistDelete,</span></span><br><span class="line"><span class="comment">     * and we should return NULL. Otherwise, we should return NULL</span></span><br><span class="line"><span class="comment">     * when the *next* element is ZIP_END (there is no next entry). */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p += zipRawEntryLength(p);  <span class="comment">// 返回当前节点的长度，然后指针偏移到下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回上一个节点的位置</span></span><br><span class="line"><span class="comment">/* Return pointer to previous entry in ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterating backwards from ZIP_END should return the tail. When &quot;p&quot; is</span></span><br><span class="line"><span class="comment">     * equal to the first element of the list, we&#x27;re already at the head,</span></span><br><span class="line"><span class="comment">     * and should return NULL. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl); <span class="comment">// 获取根据zltail获取末尾节点的指针</span></span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END) ? <span class="literal">NULL</span> : p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == ZIPLIST_ENTRY_HEAD(zl)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果p是头节点，则不存在上一个节点了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); <span class="comment">// 获取前置节点的长度</span></span><br><span class="line">        assert(prevlen &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> p-prevlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取节点p的数据，如果是字符串，则填充到sstr和slen中，如果是整数，则填充到sval中</span></span><br><span class="line"><span class="comment">/* Get entry pointed to by &#x27;p&#x27; and store in either &#x27;*sstr&#x27; or &#x27;sval&#x27; depending</span></span><br><span class="line"><span class="comment"> * on the encoding of the entry. &#x27;*sstr&#x27; is always set to NULL to be able</span></span><br><span class="line"><span class="comment"> * to find out whether the string pointer or the integer value was set.</span></span><br><span class="line"><span class="comment"> * Return 0 if &#x27;p&#x27; points to the end of the ziplist, 1 otherwise. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **sstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> *slen, <span class="keyword">long</span> <span class="keyword">long</span> *sval)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p[<span class="number">0</span>] == ZIP_END) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sstr) *sstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    zipEntry(p, &amp;entry); <span class="comment">// 将内存中该节点的信息构造成中间结构zlentry，便于操作</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sstr) &#123;</span><br><span class="line">            *slen = entry.len;</span><br><span class="line">            *sstr = p+entry.headersize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sval) &#123;</span><br><span class="line">            *sval = zipLoadInteger(p+entry.headersize,entry.encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete a single entry from the ziplist, pointed to by *p.</span></span><br><span class="line"><span class="comment"> * Also update *p in place, to be able to iterate over the</span></span><br><span class="line"><span class="comment"> * ziplist, while deleting entries. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> offset = *p-zl; <span class="comment">// 获取当前节点的偏移量</span></span><br><span class="line">    zl = __ziplistDelete(zl,*p,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store pointer to current element in p, because ziplistDelete will</span></span><br><span class="line"><span class="comment">     * do a realloc which might result in a different &quot;zl&quot;-pointer.</span></span><br><span class="line"><span class="comment">     * When the delete direction is back to front, we might delete the last</span></span><br><span class="line"><span class="comment">     * entry and end up with &quot;p&quot; pointing to ZIP_END, so check this. */</span></span><br><span class="line">    *p = zl+offset;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a range of entries from the ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDeleteRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(zl,index);</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">NULL</span>) ? zl : __ziplistDelete(zl,p,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete &quot;num&quot; entries, starting at &quot;p&quot;. Returns pointer to the ziplist. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistDelete(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, totlen, deleted = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    zlentry first, tail;</span><br><span class="line"></span><br><span class="line">    zipEntry(p, &amp;first); <span class="comment">// 构造中间结构</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; p[<span class="number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</span><br><span class="line">        p += zipRawEntryLength(p); <span class="comment">// 偏移到下一个节点</span></span><br><span class="line">        deleted++; <span class="comment">// 统计删除的节点数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totlen = p-first.p; <span class="comment">/* Bytes taken by the element(s) to delete. */</span> <span class="comment">// 计算需要删除的字节数</span></span><br><span class="line">    <span class="keyword">if</span> (totlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">/* Storing `prevrawlen` in this entry may increase or decrease the</span></span><br><span class="line"><span class="comment">             * number of bytes required compare to the current `prevrawlen`.</span></span><br><span class="line"><span class="comment">             * There always is room to store this, because it was previously</span></span><br><span class="line"><span class="comment">             * stored by an entry that is now being deleted. */</span></span><br><span class="line">            <span class="comment">// 计算</span></span><br><span class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note that there is always space when p jumps backward: if</span></span><br><span class="line"><span class="comment">             * the new previous entry is large, one of the deleted elements</span></span><br><span class="line"><span class="comment">             * had a 5 bytes prevlen header, so there is for sure at least</span></span><br><span class="line"><span class="comment">             * 5 bytes free and we need just 4. */</span></span><br><span class="line">            p -= nextdiff;</span><br><span class="line">            zipStorePrevEntryLength(p,first.prevrawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update offset for tail */</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">             * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">             * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */</span></span><br><span class="line">            zipEntry(p, &amp;tail);</span><br><span class="line">            <span class="keyword">if</span> (p[tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move tail to the front of the ziplist */</span></span><br><span class="line">            memmove(first.p,p,</span><br><span class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The entire tail was deleted. No need to move memory. */</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Resize and update length */</span></span><br><span class="line">        offset = first.p-zl;</span><br><span class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</span><br><span class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</span><br><span class="line">        p = zl+offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">         * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">        <span class="keyword">if</span> (nextdiff != <span class="number">0</span>)</span><br><span class="line">            zl = __ziplistCascadeUpdate(zl,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：ziplist.c/ziplist.h&lt;/p&gt;
&lt;p&gt;ziplist在redis中主要用于Hash与List数据结构的底层实现之一，ziplist没有定义专门的结构体，其在内存块中的表示如下图所示：&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-整数集合intset</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-intset/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-intset/</id>
    <published>2020-09-21T09:08:38.000Z</published>
    <updated>2020-09-21T09:52:32.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：intset.c/intset.h  </p><p>intset用来实现redis的set对象的数据结构之一（当元素较少且为数字类型时）。<br>为了节省内存的使用，创建intset的时候，使用最小的int类型（int16_t），当插入的整数大于int16_t时，将会进行对应的字节提升（int32_t或者int64_t），这种提升是不可逆的。<br><a id="more"></a><br><strong>特点：</strong>  </p><ol><li>元素类型只有数字。</li><li>元素有三种类型，int16_t, int32_t, int64_t</li><li>元素有序且不可重复</li><li>内存连续，类似数组。</li></ol><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 编码类型 int16_t、int32_t、int64_t</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 长度 最大长度:2^32</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">// 柔性数组</span></span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建空的整数集合</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span></span>;</span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetFind</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">intsetRandom</span><span class="params">(intset *is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetGet</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">intsetLen</span><span class="params">(<span class="keyword">const</span> intset *is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">intsetBlobLen</span><span class="params">(intset *is)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><p><strong>私有函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断数值类型</span></span><br><span class="line"><span class="comment">/* Return the required encoding for the provided value. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取intset指定位置的值</span></span><br><span class="line"><span class="comment">/* Return the value at pos, given an encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGetEncoded(intset *is, <span class="keyword">int</span> pos, <span class="keyword">uint8_t</span> enc) &#123;</span><br><span class="line">    <span class="keyword">int64_t</span> v64;</span><br><span class="line">    <span class="keyword">int32_t</span> v32;</span><br><span class="line">    <span class="keyword">int16_t</span> v16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == INTSET_ENC_INT64) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v64,((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v64));</span><br><span class="line">        memrev64ifbe(&amp;v64);</span><br><span class="line">        <span class="keyword">return</span> v64;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enc == INTSET_ENC_INT32) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v32,((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v32));</span><br><span class="line">        memrev32ifbe(&amp;v32);</span><br><span class="line">        <span class="keyword">return</span> v32;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v16,((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v16));</span><br><span class="line">        memrev16ifbe(&amp;v16);</span><br><span class="line">        <span class="keyword">return</span> v16;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGet(intset *is, <span class="keyword">int</span> pos) &#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGetEncoded(is,pos,intrev32ifbe(is-&gt;encoding));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev64ifbe(((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create an empty intset. */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset)); <span class="comment">// 分配空间</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16); <span class="comment">// 默认元素大小为2字节 intrev32ifbe:如果cpu是大端模式，则转为小端模式</span></span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内存重新分配(删除、新增时)</span></span><br><span class="line"><span class="comment">/* Resize the intset */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>增加：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据value的长度获取其编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="comment">// 如果value的编码大于目前的encoding，需要整体提高encoding的大小</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span></span><br><span class="line">        <span class="comment">// 执行扩大已经插入操作</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate &quot;pos&quot; with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="comment">// 查找元素的位置，如果该元素存在，则插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果元素不存在，则给intset扩容一个元素大小的空间</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素到intset中</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    <span class="comment">// 更新intset的length</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提高intset的encoding大小，并插入元素</span></span><br><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding); <span class="comment">// 当前的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value); <span class="comment">// 新的编码</span></span><br><span class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="comment">// prepend用来确定新value的插入位置：第一个还是最后一个，因为它的encoding比is-&gt;encoding要大，所以它要么比目前所有元素都大，要么比所有元素都小，即插入位置要么第一个，要么最后一个。</span></span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>); <span class="comment">// 扩充一个元素大小的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="comment">// 整体提高encoding大小</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在指定位置插入value</span></span><br><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev64ifbe(((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当插入，或者删除时，需要进行元素挪动，比如，在pos位置插入一个元素时，pos后的所有元素都需要往后移（整体移动）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = intrev32ifbe(is-&gt;length)-from;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="keyword">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="keyword">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据位置查找元素</span></span><br><span class="line"><span class="comment">/* Get the value at the given position. When this position is</span></span><br><span class="line"><span class="comment"> * out of range the function returns 0, when in range it returns 1. */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetGet</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) &#123;</span><br><span class="line">        *value = _intsetGet(is,pos);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断intset中是否有此元素</span></span><br><span class="line"><span class="comment">/* Determine whether a value belongs to this set */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetFind</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search for the position of &quot;value&quot;. Return 1 when the value was found and</span></span><br><span class="line"><span class="comment"> * sets &quot;pos&quot; to the position of the value within the intset. Return 0 when</span></span><br><span class="line"><span class="comment"> * the value is not present in the intset and sets &quot;pos&quot; to the position</span></span><br><span class="line"><span class="comment"> * where &quot;value&quot; can be inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="comment">// 如果intset为空，未查找到value，则pos=0</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="comment">// 如果intset末尾的元素小于value，则pos=length，如果value小于intset首位的元素，则pos=0</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二分法查找元素</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果查找到，返回元素的位置，没找到，就返回具体位置</span></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete integer from intset */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查找到元素的位置pos</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> len = intrev32ifbe(is-&gt;length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We know we can delete */</span></span><br><span class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Overwrite value with tail and update length */</span></span><br><span class="line">        <span class="comment">// 查到元素后，删除该元素，并将pos后的所有元素向前移动</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; (len<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</span><br><span class="line">        is = intsetResize(is,len<span class="number">-1</span>); <span class="comment">// 重新分配intset内存</span></span><br><span class="line">        is-&gt;length = intrev32ifbe(len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：intset.c/intset.h  &lt;/p&gt;
&lt;p&gt;intset用来实现redis的set对象的数据结构之一（当元素较少且为数字类型时）。&lt;br&gt;为了节省内存的使用，创建intset的时候，使用最小的int类型（int16_t），当插入的整数大于int16_t时，将会进行对应的字节提升（int32_t或者int64_t），这种提升是不可逆的。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-跳跃表zskiplist</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-zskiplist/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-zskiplist/</id>
    <published>2020-09-21T09:03:25.000Z</published>
    <updated>2020-09-21T09:52:56.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：t_zset.c/server.h</p><p>跳跃表是zset有序集合的底层实现之一。<br><a id="more"></a><br><strong>节点插入：</strong> 跳跃表中，一个节点的插入，分为三个步骤。<br>1.根据新增节点的score值，从最高层开始往下对比查找到新增节点每一层（这里的“每一层”是指以当前跳跃表最高层为准，并不是新增节点的层数，因为此时新增节点还没有随机出层数）的前驱层的节点指针，redis使用update[ZSKIPLIST_MAXLEVEL]数组来记录。计算出从header的每一层到新增节点所经过的节点数，使用rank[ZSKIPLIST_MAXLEVEL]数组来记录。<br>2.使用redis的随机算法，随机出新增节点的层数，如果高于当前层数，则更新跳跃表的最高层数、update数组对应的指向和rank数组对应的值（高出那部分的层数rank值为0）。<br>3.进行跳跃表的插入，就是对新增节点插入位置相邻的节点间，根据update数组进行更改指针指向的操作，根据rank来计算出对应span的值。  </p><p><strong>节点删除：</strong> 和节点插入的原理差不多，也需要用到update数组。根据score找到对应节点后，将节点抽离出来（根据update数组进行指针的重新指向，对应的span值减1），进行删除操作即可。</p><p><strong>节点更新：</strong> 和节点删除的原理差不多，如果跳跃表中没有该数据，则进行插入操作。  </p><p>跳跃表的结构如下：<br><img src="/Redis/first-stage/redis-parse-zskiplist/zskiplist.png" alt="zskiplist结构">  </p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>zslCreate</td><td>创建跳跃表</td><td>O(1)</td></tr><tr><td>zslFree</td><td>释放跳跃表</td><td>O(n)</td></tr><tr><td>zslInsert</td><td>插入节点</td><td>平均O(logN)，最坏O(N)</td></tr><tr><td>zslDelete</td><td>删除节点</td><td>平均O(logN)，最坏O(N)</td></tr><tr><td>zslGetRank</td><td>返回指定分值和成员在跳跃表中的排位</td><td>平均O(logN)，最坏O(N)</td></tr><tr><td>zslGetElementByRank</td><td>返回跳跃表在给定排位的节点</td><td>平均O(logN)，最坏O(N)</td></tr></tbody></table></div><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><p><strong>server.h:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score; <span class="comment">// 分值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 后继指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 前驱指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span; <span class="comment">// 跨度</span></span><br><span class="line">    &#125; level[]; <span class="comment">// 跳跃表的层</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// header为跳跃表的表头节点， tail为表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length; <span class="comment">// 跳跃表的长度</span></span><br><span class="line">    <span class="keyword">int</span> level; <span class="comment">// 跳跃表当前的层数</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32 <span class="comment">/* Should be enough for 2^64 elements */</span> <span class="comment">// 跳跃表层数，最大为32层，理论上当数据达到2^64时，才会能达到最顶层，所以完全足够</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span> <span class="comment">// 用于计算上层被分配到的概率</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Input flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_INCR (1&lt;&lt;0)    <span class="comment">/* Increment the score instead of setting it. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NX (1&lt;&lt;1)      <span class="comment">/* Don&#x27;t touch elements not already existing. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_XX (1&lt;&lt;2)      <span class="comment">/* Only touch elements already existing. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NOP (1&lt;&lt;3)     <span class="comment">/* Operation not performed because of conditionals.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NAN (1&lt;&lt;4)     <span class="comment">/* Only touch elements already existing. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_ADDED (1&lt;&lt;5)   <span class="comment">/* The element was new and was added. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_UPDATED (1&lt;&lt;6) <span class="comment">/* The element already existed, score updated. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Flags only used by the ZADD command but not by zsetAdd() API: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_CH (1&lt;&lt;16)      <span class="comment">/* Return num of elements added or updated. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec by score comparison. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> min, max;</span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zrangespec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    sds min, max;     <span class="comment">/* May be set to shared.(minstring|maxstring) */</span></span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zlexrangespec;</span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><p><strong>server.h:</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建跳跃表，分配指定级别数的跳跃表节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span></span>; <span class="comment">// 释放跳跃表</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span></span>; <span class="comment">// 跳跃表插入新节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele, zskiplistNode **node)</span></span>; <span class="comment">// 删除节点</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslFirstInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span></span>; <span class="comment">// 查找指定范围中的第一个节点</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslLastInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span></span>; <span class="comment">// 查找指定范围中的最后一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslValueGteMin</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslValueLteMax</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFreeLexRange</span><span class="params">(zlexrangespec *spec)</span></span>; <span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslParseLexRange</span><span class="params">(robj *min, robj *max, zlexrangespec *spec)</span></span>;</span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslFirstInLexRange</span><span class="params">(zskiplist *zsl, zlexrangespec *range)</span></span>;</span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslLastInLexRange</span><span class="params">(zskiplist *zsl, zlexrangespec *range)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslLexValueGteMin</span><span class="params">(sds value, zlexrangespec *spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslLexValueLteMax</span><span class="params">(sds value, zlexrangespec *spec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds o)</span></span>; <span class="comment">// 返回指定分值和成员在跳跃表中的排位（位置）</span></span><br></pre></td></tr></table></figure><h2 id="主要函数实现"><a href="#主要函数实现" class="headerlink" title="主要函数实现"></a>主要函数实现</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insert a new node in the skiplist. Assumes the element does not already</span></span><br><span class="line"><span class="comment"> * exist (up to the caller to enforce that). The skiplist takes ownership</span></span><br><span class="line"><span class="comment"> * of the passed SDS string &#x27;ele&#x27;. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; <span class="comment">// update数组用来记录新增节点的每一层的前驱节点指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL]; <span class="comment">// rank数组用来记录从header的每一层到新增节点所经过的节点数</span></span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层开始往下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 判断新增节点在跳跃表中所处的位置</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the element is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, reinserting the same element should never happen since the</span></span><br><span class="line"><span class="comment">     * caller of zslInsert() should test in the hash table if the element is</span></span><br><span class="line"><span class="comment">     * already inside or not. */</span></span><br><span class="line">    <span class="comment">// 随机生成新增节点的层数</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">// 如果随机生成的层数比当前跳跃表的层数高，则初始化高于跳跃表的最高层数的所有层</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新增节点</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="comment">// 根据update数组来进行新增节点的插入操作，根据rank数组来计算新增节点的跨度</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="comment">// 如果新增节点的层数低于跳跃表的层数，则高于新增节点的层数的跨度增加1</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新增节点的前置节点</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete an element with matching score/element from the skiplist.</span></span><br><span class="line"><span class="comment"> * The function returns 1 if the node was found and deleted, otherwise</span></span><br><span class="line"><span class="comment"> * 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If &#x27;node&#x27; is NULL the deleted node is freed by zslFreeNode(), otherwise</span></span><br><span class="line"><span class="comment"> * it is not freed (but just unlinked) and *node is set to the node pointer,</span></span><br><span class="line"><span class="comment"> * so that it is possible for the caller to reuse the node (including the</span></span><br><span class="line"><span class="comment"> * referenced SDS string at node-&gt;ele). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele, zskiplistNode **node)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层开始遍历，查找所要删除节点在跳跃表中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            zslFreeNode(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *node = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Update the score of an elmenent inside the sorted set skiplist.</span></span><br><span class="line"><span class="comment"> * Note that the element must exist and must match &#x27;score&#x27;.</span></span><br><span class="line"><span class="comment"> * This function does not update the score in the hash table side, the</span></span><br><span class="line"><span class="comment"> * caller should take care of it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function attempts to just update the node, in case after</span></span><br><span class="line"><span class="comment"> * the score update, the node would be exactly at the same position.</span></span><br><span class="line"><span class="comment"> * Otherwise the skiplist is modified by removing and re-adding a new</span></span><br><span class="line"><span class="comment"> * element, which is more costly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the updated element skiplist node pointer. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslUpdateScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> curscore, sds ele, <span class="keyword">double</span> newscore)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to seek to element to update to start: this is useful anyway,</span></span><br><span class="line"><span class="comment">     * we&#x27;ll have to update or remove it. */</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; curscore ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Jump to our element: note that this function assumes that the</span></span><br><span class="line"><span class="comment">     * element with the matching score exists. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    serverAssert(x &amp;&amp; curscore == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the node, after the score update, would be still exactly</span></span><br><span class="line"><span class="comment">     * at the same position, we can just update the score without</span></span><br><span class="line"><span class="comment">     * actually removing and re-inserting the element in the skiplist. */</span></span><br><span class="line">    <span class="keyword">if</span> ((x-&gt;backward == <span class="literal">NULL</span> || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;</span><br><span class="line">        (x-&gt;level[<span class="number">0</span>].forward == <span class="literal">NULL</span> || x-&gt;level[<span class="number">0</span>].forward-&gt;score &gt; newscore))</span><br><span class="line">    &#123;</span><br><span class="line">        x-&gt;score = newscore;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No way to reuse the old node: we need to remove and insert a new</span></span><br><span class="line"><span class="comment">     * one at a different place. */</span></span><br><span class="line">    zslDeleteNode(zsl, x, update);</span><br><span class="line">    zskiplistNode *newnode = zslInsert(zsl,newscore,x-&gt;ele);</span><br><span class="line">    <span class="comment">/* We reused the old node x-&gt;ele SDS string, free the node now</span></span><br><span class="line"><span class="comment">     * since zslInsert created a new one. */</span></span><br><span class="line">    x-&gt;ele = <span class="literal">NULL</span>;</span><br><span class="line">    zslFreeNode(x);</span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机层数算法</span></span><br><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free a whole skiplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next;</span><br><span class="line"></span><br><span class="line">    zfree(zsl-&gt;header);</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslFreeNode(node);</span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(zsl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据rank（排位）来查找跳跃表中指定的节点</span></span><br><span class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></span><br><span class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：t_zset.c/server.h&lt;/p&gt;
&lt;p&gt;跳跃表是zset有序集合的底层实现之一。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-字典dict</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-dict/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-dict/</id>
    <published>2020-09-21T09:00:45.000Z</published>
    <updated>2020-09-21T09:52:27.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：dict.c/dict.h  </p><p>Redis的字典是由两个HashTable（后面简称ht[0]、ht[1]）构成，与其他字典不同的是，当当前的hashtable负载过高时，redis的字典会进行rehash（重新计算hash），rehash的过程是渐进式的，并不会一下子把所有的数据转移到另一张hashtable中，否则那样会造成服务短暂时间内无法使用。<br><a id="more"></a><br><strong>rehash的条件</strong>：当哈希表的结点个数（used）是哈希表中节点链表数（size）的5倍时，将进行rehash。  </p><p><strong>rehash的过程</strong>：当满足rehash的条件时，redis将进行expend扩展，扩展的size是ht[0]-&gt;size的2倍。因为是渐进式的rehash，所以redis会初始化ht[1]，给ht[1]分配足够的内存大小（ht[0]-&gt;size<em>2</em>sizeof(dictEntry*)），将字典的rehashidx的值置为0，并且当前不会进行rehash操作。<br>当用户进行查询、插入、删除时，将进行一个节点的rehash操作。直到ht[0]的节点全部rehash完毕后，删除ht[0]并且把ht[1]指针赋予给ht[0]，rehashidx值将回到-1，直到下次满足rehash的条件。  </p><p><strong>确定key的位置（查找、删除、插入操作）</strong>：如果当前正在rehash，则插入到ht[1]中，根据key计算hash值，&amp; sizemask后得到的index（index=hash_value &amp; dict-&gt;ht[table].sizemask）就是该key所在的链表的索引。</p><p>Redis中字典的结构：<br><img src="/Redis/first-stage/redis-parse-dict/dict.png" alt="字典结构">  </p><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Unused arguments generate annoying warnings... */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_NOTUSED(V) ((void) V)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存了用于操作特定类型键值对的函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">// 哈希函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">// 键复制函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj); <span class="comment">// 值复制函数指针</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2); <span class="comment">// 键比较函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key); <span class="comment">// 键析构函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj); <span class="comment">// 值析构函数指针</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"> <span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table; <span class="comment">// 哈希表(字典数组)，俗称桶bucket</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 哈希表大小（字典数组的长度，桶的层数）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 哈希表掩码（值为size-1），通过（hash &amp; sizemask）计算得到哈希表的索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 当前的节点数（键值对数）</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">// 完整的字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// 特定类型的处理函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 2个哈希表</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span> <span class="comment">// 当前未进行rehash时，值为-1，否则为当前rehash的索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span> <span class="comment">// 当前字典的迭代器个数</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d; <span class="comment">// 字典指针</span></span><br><span class="line">    <span class="keyword">long</span> index; <span class="comment">// 索引</span></span><br><span class="line">    <span class="keyword">int</span> table, safe; <span class="comment">// safe为1，则表示是安全的迭代器，迭代期间，可以进行增删改查操作。 table为当前为第几个哈希表</span></span><br><span class="line">    dictEntry *entry, *nextEntry; <span class="comment">// 当前结点指针和下一个结点的指针</span></span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint; <span class="comment">// 不安全迭代器的指纹</span></span><br><span class="line">&#125; dictIterator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(dictScanFunction)</span><span class="params">(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> dictEntry *de)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(dictScanBucketFunction)</span><span class="params">(<span class="keyword">void</span> *privdata, dictEntry **bucketref)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the initial size of every hash table */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HT_INITIAL_SIZE     4  <span class="comment">// 哈希表的链表个数初始化为4</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------- Macros ------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeVal(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;v.val)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetVal(d, entry, _val_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span><br><span class="line">        (entry)-&gt;v.val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        (entry)-&gt;v.val = (_val_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetSignedIntegerVal(entry, _val_) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; (entry)-&gt;v.s64 = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetUnsignedIntegerVal(entry, _val_) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; (entry)-&gt;v.u64 = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetDoubleVal(entry, _val_) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; (entry)-&gt;v.d = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetKey(d, entry, _key_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span><br><span class="line">        (entry)-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        (entry)-&gt;key = (_key_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictCompareKeys(d, key1, key2) \</span></span><br><span class="line">    (((d)-&gt;type-&gt;keyCompare) ? \</span><br><span class="line">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span><br><span class="line">        (key1) == (key2))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetVal(he) ((he)-&gt;v.val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetUnsignedIntegerVal(he) ((he)-&gt;v.u64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetDoubleVal(he) ((he)-&gt;v.d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type, <span class="keyword">void</span> *privDataPtr)</span></span>; <span class="comment">// 创建dict字典</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>; <span class="comment">// 哈希表扩展，当哈希表的冲突率过高时，链表会很长，查询效率降低，所以需要扩展哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>; <span class="comment">// 新增键值对</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span>; <span class="comment">// 新增dictEntity结点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddOrFind</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 查找key的dictEntity结点，如果不存在，则新增</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>; <span class="comment">// 更改val，如果不存在，则增加key-value</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 删除key</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictUnlink</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 删除key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictFreeUnlinkedEntry</span><span class="params">(dict *d, dictEntry *he)</span></span>; <span class="comment">// 释放结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span>; <span class="comment">// 清空字典（释放内存）</span></span><br><span class="line"><span class="function">dictEntry * <span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dictFetchValue</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span>; <span class="comment">// 重新计算size</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span>; <span class="comment">// 获取字典迭代器</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span></span>; <span class="comment">// 获取安全的迭代器</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span>; <span class="comment">// 获取下一个哈希结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span>; <span class="comment">// 释放迭代器</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictGetRandomKey</span><span class="params">(dict *d)</span></span>; <span class="comment">// 获取随机key</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictGetFairRandomKey</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>; <span class="comment">// 获取count个key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictGetStats</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsize, dict *d)</span></span>; <span class="comment">// 获取当前字典的状态</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span><span class="params">(dict *d, <span class="keyword">void</span>(callback)(<span class="keyword">void</span>*))</span></span>; <span class="comment">// 清空字典（不释放内存）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 允许resize，将静态变量dict_can_resize设为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 不允许resize，dict_can_resize为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 进行rehash操作，n为rehash的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span></span>; <span class="comment">// ms时间内进行rehash操作，每次rehash100个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSetHashFunctionSeed</span><span class="params">(<span class="keyword">uint8_t</span> *seed)</span></span>; <span class="comment">// 设置哈希种子，调用默认哈希函数时使用</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">dictGetHashFunctionSeed</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取哈希种子</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> v, dictScanFunction *fn, dictScanBucketFunction *bucketfn, <span class="keyword">void</span> *privdata)</span></span>; <span class="comment">// 扫描字典</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">dictGetHash</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// 获取哈希值</span></span><br><span class="line"><span class="function">dictEntry **<span class="title">dictFindEntryRefByPtrAndHash</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *oldptr, <span class="keyword">uint64_t</span> hash)</span></span>; <span class="comment">// 通过hash值和结点指针查找字典中的结点</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：dict.c/dict.h  &lt;/p&gt;
&lt;p&gt;Redis的字典是由两个HashTable（后面简称ht[0]、ht[1]）构成，与其他字典不同的是，当当前的hashtable负载过高时，redis的字典会进行rehash（重新计算hash），rehash的过程是渐进式的，并不会一下子把所有的数据转移到另一张hashtable中，否则那样会造成服务短暂时间内无法使用。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-双端链表adlist</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-adlist/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-adlist/</id>
    <published>2020-09-21T08:50:59.000Z</published>
    <updated>2020-09-21T09:52:24.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：adlist.c/adlist.h  </p><p>很好理解的双端链表，结构如下，不多做解释了。<br><img src="/Redis/first-stage/redis-parse-adlist/adlist.png" alt="list"><br><a id="more"></a></p><h2 id="结构体与宏定义"><a href="#结构体与宏定义" class="headerlink" title="结构体与宏定义"></a>结构体与宏定义</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前置结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后置结点</span></span><br><span class="line">    <span class="keyword">void</span> *value; <span class="comment">// 数据</span></span><br><span class="line">&#125; listNode;</span><br><span class="line"><span class="comment">// 链表迭代器定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction; <span class="comment">// 方向参数，正序和逆序</span></span><br><span class="line">&#125; listIter;</span><br><span class="line"><span class="comment">// 链表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head; <span class="comment">// 链表的头部结点</span></span><br><span class="line">    listNode *tail; <span class="comment">// 链表的尾部结点</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr); <span class="comment">// 拷贝函数的函数指针，由使用者来实现其功能</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr); <span class="comment">// 释放函数的函数指针，由使用者来实现其功能</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 匹配函数的函数指针，由使用者来实现其功能</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">// 链表大小（结点个数）</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len) <span class="comment">// 获取链表长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head) <span class="comment">// 获取链表头结点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail) <span class="comment">// 获取链表尾结点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev) <span class="comment">// 获取当前结点的前置结点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next) <span class="comment">// 获取当前结点的后置结点指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value) <span class="comment">// 获取当前结点的value</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m)) <span class="comment">// 设定链表的复制函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m)) <span class="comment">// 设定链表的释放函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m)) <span class="comment">// 设定链表的匹配函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup) <span class="comment">// 获取链表的复制函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFreeMethod(l) ((l)-&gt;free) <span class="comment">// 获取链表的释放函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match) <span class="comment">// 获取链表的匹配函数</span></span></span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;</span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个链表</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listEmpty(<span class="built_in">list</span>);</span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在头部新增一个结点</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在尾部新增一个结点</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表的old_node结点前或者后（由after变量指定）插入一个新的结点</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除链表中的node结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取列表迭代器，direction为方向参数，AL_START_HEAD正序和AL_START_TAIL逆序</span></span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过迭代器访问下一个结点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表复制</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    listRewind(orig, &amp;iter);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找key，如果链表有定义match函数，则通过match函数来查找，否则判断结点的value来和key是否相等</span></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    listRewind(<span class="built_in">list</span>, &amp;iter);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取链表中第index的结点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取链表首结点的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取链表尾结点的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表的尾节点移动插入到链表头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表o插入到链表l的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listJoin</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;head)</span><br><span class="line">        o-&gt;head-&gt;prev = l-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;tail)</span><br><span class="line">        l-&gt;tail-&gt;next = o-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l-&gt;head = o-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;tail) l-&gt;tail = o-&gt;tail;</span><br><span class="line">    l-&gt;len += o-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup other as an empty list. */</span></span><br><span class="line">    o-&gt;head = o-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    o-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：adlist.c/adlist.h  &lt;/p&gt;
&lt;p&gt;很好理解的双端链表，结构如下，不多做解释了。&lt;br&gt;&lt;img src=&quot;/Redis/first-stage/redis-parse-adlist/adlist.png&quot; alt=&quot;list&quot;&gt;&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-动态字符串sds</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-sds/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-sds/</id>
    <published>2020-09-21T08:50:01.000Z</published>
    <updated>2020-09-21T09:52:49.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：sds.c/sds.h  </p><p>因为C语言没有实现动态字符串，所以redis实现了sds（simple dynamic string）简单动态字符串。既然是动态的，意味着它是能够支持修改的。​虽然是简单的动态字符串，但是redis为了省内存，快速获得字符串长度等需求，redis作者在结构上可是煞费苦心了。​<br><a id="more"></a><br>sds为了省内存，对不同长度的字符串，采用了不同的内存大小的结构体达到省内存的目的。为了减少内存的频繁分配，sds采用预分配冗余空间的方式来达到目的。<br>SDS结构一共有5种header定义，结构体主要包含以下几个部分：<br>len：字符串的实际长度<br>alloc：字符串的最大容量<br>flags：表示结构体的类型<br>buf：字符串<br><img src="/Redis/first-stage/redis-parse-sds/sds.png" alt="sds结构"></p><h2 id="SDS结构体"><a href="#SDS结构体" class="headerlink" title="SDS结构体"></a>SDS结构体</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7 <span class="comment">// 类型掩码(通过(flags &amp; SDS_TYPE_MASK)可判断sdshdrXX)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); <span class="comment">// 获取header头指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) <span class="comment">// 获取header头指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS) <span class="comment">// 获取sdshdr5的长度</span></span></span><br></pre></td></tr></table></figure><h2 id="函数功能总览"><a href="#函数功能总览" class="headerlink" title="函数功能总览"></a>函数功能总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>; <span class="comment">// 生成新的sds字符串（返回sdshdrXX中的buf头指针）</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>; <span class="comment">// 生成新的sds字符串（调用sdsnewlen()）</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建一个空的sds字符串（调用sdsnewlen(&quot;&quot;, 0)）</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>; <span class="comment">// 复制（深拷贝）s（调用sdsnewlen(&quot;&quot;, 0)）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>; <span class="comment">// 释放sds字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 将字符串s增加到指定长度len（s的实际长度为len）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 字符串s增加len的长度（s的实际长度为len（s） + len）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>; <span class="comment">// 字符串拼接（调用sdscatlen()）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span>; <span class="comment">// 同上（调用sdscatlen()）</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 字符串拷贝</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>; <span class="comment">// 字符串拷贝（调用sdscpylen()）</span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>; <span class="comment">// 字符串格式化，类似于sprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="comment">// 字符串格式化（调用sdscatvprintf()）</span></span></span><br><span class="line"><span class="function">    __<span class="title">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>; <span class="comment">// 字符串格式化（调用sdscatvprintf()）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>; <span class="comment">// 字符串格式化拼接</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>; <span class="comment">// 字符串s剔除指定的cset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">ssize_t</span> start, <span class="keyword">ssize_t</span> end)</span></span>; <span class="comment">// 选取指定长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>; <span class="comment">// 更新s的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>; <span class="comment">// 清空s的内容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span></span>; <span class="comment">// 字符串拷贝</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">ssize_t</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span>; <span class="comment">// 字符串分割，将字符串s根据sep分割符来进行分割，返回字符串数组，count为数组个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>; <span class="comment">// 释放字符串数组tokens</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>; <span class="comment">// 字符串转小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>; <span class="comment">// 字符串转大写</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>; <span class="comment">// long long 转为sds格式</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 将s里不可打印的字符(&#x27;\n&#x27;、&#x27;\t&#x27;等)转义为可用来打印的字符(&#x27;\\n&#x27;、&#x27;\\t&#x27;等)</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span></span>; <span class="comment">// 替换字符串，将s中为from的字符串替换为to</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span></span>; <span class="comment">// 字符串数组连接</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">size_t</span> seplen)</span></span>; <span class="comment">// sds格式的字符串连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level functions exposed to the user API */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span></span>; <span class="comment">// 字符串s增加扩大addlen个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">ssize_t</span> incr)</span></span>; <span class="comment">// 调整sds中len的大小</span></span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span></span>; <span class="comment">// 删除掉sds中的末端空间(local-len)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdsAllocSize</span><span class="params">(sds s)</span></span>; <span class="comment">// 返回整个结构的内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sdsAllocPtr</span><span class="params">(sds s)</span></span>; <span class="comment">// 返回结构体的头指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Export the allocator used by SDS to the program using SDS.</span></span><br><span class="line"><span class="comment"> * Sometimes the program SDS is linked to, may use a different set of</span></span><br><span class="line"><span class="comment"> * allocators, but may want to allocate or free things that SDS will</span></span><br><span class="line"><span class="comment"> * respectively free or allocate. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 分配内存size大小的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sds_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 重新分配内存大小为size的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sds_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：sds.c/sds.h  &lt;/p&gt;
&lt;p&gt;因为C语言没有实现动态字符串，所以redis实现了sds（simple dynamic string）简单动态字符串。既然是动态的，意味着它是能够支持修改的。​虽然是简单的动态字符串，但是redis为了省内存，快速获得字符串长度等需求，redis作者在结构上可是煞费苦心了。​&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-内存分配zmalloc</title>
    <link href="http://example.com/Redis/first-stage/redis-parse-malloc/"/>
    <id>http://example.com/Redis/first-stage/redis-parse-malloc/</id>
    <published>2020-09-21T08:47:10.000Z</published>
    <updated>2020-09-21T09:52:37.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>源码位置：zmalloc.c/zmalloc.h  </p><p>因为Redis没有自己实现内存池，所以系统内存分配器的性能及碎片率会对redis造成一些性能上的影响。<br>Redis采用了3种内存分配器：tcmalloc、jemalloc、malloc。<br>Redis在编译时，首先会判断是否使用tcmalloc，其次是jemalloc，如果都没有使用，则使用libc中的内存管理函数malloc。<br><a id="more"></a></p><h2 id="功能函数总览"><a href="#功能函数总览" class="headerlink" title="功能函数总览"></a>功能函数总览</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用malloc函数申请size大小的内存空间（malloc不初始化，里边的数据是随机的）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用calloc函数申请size大小的内存空间（calloc系统会自动初始化内存为零）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用realloc函数重新分配size大小的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 调用free释放ptr的内存</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>; <span class="comment">// 深拷贝字符串s</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_used_memory</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取以分配的内存空间大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_set_oom_handler</span><span class="params">(<span class="keyword">void</span> (*oom_handler)(<span class="keyword">size_t</span>))</span></span>; <span class="comment">// 可自定义内存溢出的处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取rss信息（Resident Set Size 常驻内存集）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zmalloc_get_allocator_info</span><span class="params">(<span class="keyword">size_t</span> *allocated, <span class="keyword">size_t</span> *active, <span class="keyword">size_t</span> *resident)</span></span>; <span class="comment">// 获取jemalloc分配的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_jemalloc_bg_thread</span><span class="params">(<span class="keyword">int</span> enable)</span></span>; <span class="comment">// flushdb没有通信后，让jemalloc异步清除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jemalloc_purge</span><span class="params">()</span></span>; <span class="comment">// 手动清理内存碎片</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_private_dirty</span><span class="params">(<span class="keyword">long</span> pid)</span></span>; <span class="comment">// 获取smap中的Private_Dirty大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid)</span></span>; <span class="comment">// 获取smap中的某字段大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_memory_size</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取物理内存的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlibc_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 释放内存，不更新used_memory（不知道为啥，等以后看懂了再注释）</span></span><br></pre></td></tr></table></figure><h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录以使用的内存总大小，对该变量的操作都是原子操作</span></span><br><span class="line"><span class="comment">// 在redis-cli使用info命令可以查看</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用系统函数malloc申请size大小的内存空间，PREFIX_SIZE根据不同平台和HAVE_MALLOC_SIZE控制的。</span></span><br><span class="line"><span class="comment">// 如果分配失败，则调用zmalloc_oom_handler()函数来打印异常，并返回空值。</span></span><br><span class="line"><span class="comment">// 若分配成功，会在update_zmalloc_stat_alloc()宏定义函数中更新used_memory这个静态变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用系统函数calloc申请size大小的内存空间，功能函数与zmalloc()相同</span></span><br><span class="line"><span class="comment">// malloc与calloc的区别在于，malloc申请的内存不进行初始化，内存里的值是随机的，calloc申请的内存系统会讲其初始化为零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据新的size进行内存分配，并且更新used_memory变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        zfree(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = zmalloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放ptr的内存空间，并更新used_memory变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝字符串s，创建字符串副本</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取used_memory的值</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_used_memory</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line">    atomicGet(used_memory,um);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可自定义分配失败时的处理方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_set_oom_handler</span><span class="params">(<span class="keyword">void</span> (*oom_handler)(<span class="keyword">size_t</span>))</span> </span>&#123;</span><br><span class="line">    zmalloc_oom_handler = oom_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取rss信息（Resident Set Size 常驻内存集）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">size_t</span> rss;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">&quot;/proc/%d/stat&quot;</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    rss *= page;</span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取jemalloc分配的信息，在jemalloc前提下使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zmalloc_get_allocator_info</span><span class="params">(<span class="keyword">size_t</span> *allocated,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *active,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *resident)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> epoch = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> sz;</span><br><span class="line">    *allocated = *resident = *active = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Update the statistics cached by mallctl. */</span></span><br><span class="line">    sz = <span class="keyword">sizeof</span>(epoch);</span><br><span class="line">    je_mallctl(<span class="string">&quot;epoch&quot;</span>, &amp;epoch, &amp;sz, &amp;epoch, sz);</span><br><span class="line">    sz = <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="comment">/* Unlike RSS, this does not include RSS from shared libraries and other non</span></span><br><span class="line"><span class="comment">     * heap mappings. */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.resident&quot;</span>, resident, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Unlike resident, this doesn&#x27;t not include the pages jemalloc reserves</span></span><br><span class="line"><span class="comment">     * for re-use (purge will clean that). */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.active&quot;</span>, active, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Unlike zmalloc_used_memory, this matches the stats.resident by taking</span></span><br><span class="line"><span class="comment">     * into account all allocations done by this process (not only zmalloc). */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.allocated&quot;</span>, allocated, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flushdb没有通信后，让jemalloc异步清除，在jemalloc前提下使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_jemalloc_bg_thread</span><span class="params">(<span class="keyword">int</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* let jemalloc do purging asynchronously, required when there&#x27;s no traffic </span></span><br><span class="line"><span class="comment">     * after flushdb */</span></span><br><span class="line">    <span class="keyword">char</span> val = !!enable;</span><br><span class="line">    je_mallctl(<span class="string">&quot;background_thread&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;val, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整理内存碎片，在jemalloc前提下使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jemalloc_purge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* return all unused (reserved) pages to the OS */</span></span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> narenas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>);</span><br><span class="line">    <span class="keyword">if</span> (!je_mallctl(<span class="string">&quot;arenas.narenas&quot;</span>, &amp;narenas, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;arena.%d.purge&quot;</span>, narenas);</span><br><span class="line">        <span class="keyword">if</span> (!je_mallctl(tmp, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取smap中的Private_Dirty（映射中已由此进程写入但未被任何其他进程引用的页面）大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_private_dirty</span><span class="params">(<span class="keyword">long</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zmalloc_get_smap_bytes_by_field(<span class="string">&quot;Private_Dirty:&quot;</span>,pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取进程的smap文件中，某字段字节的大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">size_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flen = <span class="built_in">strlen</span>(field);</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        fp = fopen(<span class="string">&quot;/proc/self/smaps&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> filename[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(filename,<span class="keyword">sizeof</span>(filename),<span class="string">&quot;/proc/%ld/smaps&quot;</span>,pid);</span><br><span class="line">        fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fgets(line,<span class="keyword">sizeof</span>(line),fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line,field,flen) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> *p = <span class="built_in">strchr</span>(line,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                bytes += strtol(line+flen,<span class="literal">NULL</span>,<span class="number">10</span>) * <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取物理内存的大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_memory_size</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__unix) || defined(unix) || \</span></span><br><span class="line">    (defined(__APPLE__) &amp;&amp; defined(__MACH__))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CTL_HW) &amp;&amp; (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_MEMSIZE)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_MEMSIZE;            <span class="comment">/* OSX. --------------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PHYSMEM64)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM64;          <span class="comment">/* NetBSD, OpenBSD. --------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int64_t</span> size = <span class="number">0</span>;               <span class="comment">/* 64-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl( mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_SC_PHYS_PAGES) &amp;&amp; defined(_SC_PAGESIZE)</span></span><br><span class="line">    <span class="comment">/* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>)sysconf(_SC_PHYS_PAGES) * (<span class="keyword">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CTL_HW) &amp;&amp; (defined(HW_PHYSMEM) || defined(HW_REALMEM))</span></span><br><span class="line">    <span class="comment">/* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_REALMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_REALMEM;        <span class="comment">/* FreeBSD. ----------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PHYSMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM;        <span class="comment">/* Others. ------------------ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="number">0</span>;      <span class="comment">/* 32-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown method to get the data. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown OS. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用对应的内存分配器的free函数进行内存释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlibc_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码位置：zmalloc.c/zmalloc.h  &lt;/p&gt;
&lt;p&gt;因为Redis没有自己实现内存池，所以系统内存分配器的性能及碎片率会对redis造成一些性能上的影响。&lt;br&gt;Redis采用了3种内存分配器：tcmalloc、jemalloc、malloc。&lt;br&gt;Redis在编译时，首先会判断是否使用tcmalloc，其次是jemalloc，如果都没有使用，则使用libc中的内存管理函数malloc。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    <category term="first-stage" scheme="http://example.com/categories/Redis/first-stage/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
</feed>
